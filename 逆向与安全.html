<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  逆向与安全 - 
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="https://github.com/Caolongs">Alongs</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="https://github.com/Caolongs">Alongs</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="UML.html">UML</a></li>
        
            <li><a href="%E6%91%84%E5%BD%B1.html">摄影</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7.html">工具</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="%E6%9E%B6%E6%9E%84.html">架构</a></li>
        
            <li><a href="CI.html">CI</a></li>
        
            <li><a href="OpenGL.html">OpenGL</a></li>
        
            <li><a href="%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html">逆向与安全</a></li>
        
            <li><a href="AI.html">AI</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91.html">音视频</a></li>
        
            <li><a href="Shell.html">Shell</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15283573748540.html">
                
                  <h1>iOS逆向-砸壳（Clutch & dumpdecrypted）</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>MachO文件 -&gt; 苹果加密 -&gt; 加壳文件</p>

<p>加壳文件 -&gt; 苹果解密 -&gt; MachO文件（DYLD）</p>

<p>解密过程：</p>

<ol>
<li>DRM（数字版权管理）检查</li>
<li>找到合适结构进行解密</li>
<li>使用DYLD加载解密的MachO</li>
</ol>
</blockquote>

<h2 id="toc_0">砸壳工具：</h2>

<p>Clutch 静态砸壳<br/>
dumpdecrypted 动态加壳</p>

<p>静态砸壳：调用系统的解密程序<br/>
动态砸壳：得到系统解密后的MachO文件</p>

<h2 id="toc_1">Clutch 静态砸壳</h2>

<p>前提条件：手机已越狱</p>

<h3 id="toc_2">1. 下载安装Clutch到手机</h3>

<p>github下载 <a href="https://github.com/KJCracks/Clutch/releases">Clutch</a> 并命名为 <code>Clutch</code></p>

<h3 id="toc_3">2. 将该文件拷贝到设备（手机）中</h3>

<pre><code class="language-text">scp ./build/Clutch root@&lt;your.device.ip&gt;:/usr/bin/Clutch
    
若有端口映射
scp -P 2222 ./build/Clutch root@localhost:/usr/bin/Clutch
</code></pre>

<h3 id="toc_4">3. Clutch 增加可执行权限</h3>

<pre><code class="language-text"># chmod +x Clutch
</code></pre>

<h3 id="toc_5">4. 使用</h3>

<pre><code class="language-text">Clutch [OPTIONS]
-b --binary-dump     Only dump binary files from specified bundleID
-d --dump            Dump specified bundleID into .ipa file
-i --print-installed Print installed application
--clean              Clean /var/tmp/clutch directory
--version            Display version and exit
-? --help            Display this help and exit
</code></pre>

<ul>
<li><p><code>$ Clutch i</code>列出可砸壳应用</p>
<pre><code class="language-text">1: 微信 &lt;com.tencent.xin&gt;
2: ....
</code></pre></li>
<li><p>砸壳</p>
<pre><code class="language-text"># Clutch -d [标示或bundleID]
如：<br/>
Clutch -d 1
</code></pre>
<p>成功后可看见砸壳后的文件</p></li>
</ul>

<h2 id="toc_6">dumpdecrypted 动态加壳</h2>

<h3 id="toc_7">1. 下载并执行</h3>

<p>github <a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a> <code>clone and Download</code></p>

<p>当前文件夹下执行<code>make</code></p>

<pre><code class="language-text">$ make
</code></pre>

<p>生成 <code>dumpdecrypted.dylib</code> 和 <code>dumpdecrypted.o</code> 文件</p>

<h3 id="toc_8">2. 将动态库<code>.dylib</code>从本地拷贝到手机上</h3>

<pre><code class="language-text">scp dumpdecrypted.dylib root@&lt;your.device.ip&gt;:~/
    
若有端口映射
scp -P 2222 ./build/Clutch root@localhost:~/
</code></pre>

<h3 id="toc_9">3. 将动态库<code>.dylib</code>依附到要砸壳的app进程中</h3>

<p>利用 <code>DYLD</code> 环境变量 DYLD_INSERT_LIBRARIES=</p>

<pre><code class="language-text"># DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib [进程路径]

如：
DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/.../WeChat.app/WeChat
</code></pre>

<p>注：进程路径可通过 <code>ps -A</code> 查看</p>

<h3 id="toc_10">4. ipa包</h3>

<p>执行之后 当前目录下 <code>ls</code> 得到 <code>WeChat.decrypted</code>可执行文件<br/>
其他文件可在<code>/var/mobile/.../WeChat.app</code>拷贝组合成砸壳后的ipa包</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15264613640203.html">
                
                  <h1>Logos语法</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p><a href="http://iphonedevwiki.net/index.php/Logos">logos</a> 语法主要是对<a href="http://iphonedevwiki.net/index.php/Cydia_Substrate">Cydia Substrate</a>的MSHookMessageEx函数作了一层封装。</p>

<p><strong>1.%hook</strong> <br/>
指定需要hook的class,必须以％end结尾。</p>

<p><strong>2.％log</strong> <br/>
该指令在%hook内部使用，将函数的类名、参数等信息写入syslog,可以％log([(),…..])的格式追加其他打印信息。</p>

<p><strong>3.％orig</strong> <br/>
该指令在%hook内部使用，执行被hook的函数的原始代码；也可以用％orig更改原始函数的参数。</p>

<p><strong>4.%group</strong> <br/>
该指令用于将%hook分组，便于代码管理及按条件初始化分组，必须以%end结尾。 <br/>
一个％group可以包含多个%hook,所有不属于某个自定义group的％hook会被隐式归类到％group_ungrouped中。</p>

<p><strong>5.%init</strong> <br/>
该指令用于初始化某个％group，必须在%hook或％ctor内调用；如果带参数，则初始化指定的group，如果不带参数，则初始化_ungrouped. <br/>
注： <br/>
切记，只有调用了％ini,对应的%group才能起作用！</p>

<p><strong>6.%ctor</strong> <br/>
tweak的constructor,完成初始化工作；如果不显示定义，Theos会自动生成一个%ctor,并在其中调用%init(_ungrouped)。</p>

<p><strong>7.%new</strong> <br/>
在%hook内部使用，给一个现有class添加新函数，功能与class_addMethod相同。 <br/>
注： <br/>
Objective-C的category与class_addMethod的区别： <br/>
前者是静态的而后者是动态的。</p>

<p><strong>8.%c</strong> <br/>
该指令的作用等同于objc_getClass或NSClassFromString,即动态获取一个类的定义，在%hook或％ctor内使用。</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15262813725894.html">
                
                  <h1>HOOK</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">一、HOOK概述</h2>

<blockquote>
<p>HOOK(钩子) 其实就是改变程序执行流程的一种技术的统称!</p>
</blockquote>

<h2 id="toc_1">二、iOS中HOOK技术的几种方式</h2>

<h3 id="toc_2">1、Method Swizzle</h3>

<p>利用OC的<strong>Runtime</strong>特性，动态改变SEL（方法编号）和IMP（方法实现）的对应关系，达到OC方法调用流程改变的目的。主要用于<strong>OC</strong>方法。</p>

<h3 id="toc_3">2、fishhook</h3>

<p><a href="https://github.com/facebook/fishhook">fishhook</a> 是Facebook提供的一个动态修改链接mach-O文件的工具。利用MachO文件加载原理，通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的。</p>

<h4 id="toc_4">* How it works</h4>

<p>通过更新Mach-O二进制文件的<code>__DATA</code>段的特定部分中的指针，<code>dyld</code>绑定了惰性和非惰性符号。<strong>fishhook</strong>通过确定传递给<code>rebind_symbols</code>的每个符号名称的更新位置，然后写出相应的替换项来重新绑定这些符号。 <br/>
对于给定的<code>image</code>，<code>__DATA</code>段可能包含两个与动态符号绑定相关的部分：<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code>。 <code>__nl_symbol_ptr</code>是指向非延迟绑定数据的指针数组（这些指针在加载库时被绑定），而<code>__la_symbol_ptr</code>是指向导入函数的指针数组，通常在第一次调用该符号期间由一个名为<code>dyld_stub_binder</code>的例程填充（也可以告诉<code>dyld</code>在启动时绑定这些）。为了找到与这些部分中的某个部分中的特定位置相对应的符号的名称，我们必须跳过几个间接层。对于两个相关的部分，the section headers（来自<code>&lt;mach-o / loader.h&gt;</code>的结构）提供了一个<code>offset</code>（在<code>reserved1</code>字段中），称为间接符号表。位于二进制文件的<code>__LINKEDIT</code>段中的间接符号表仅仅是符号表（也在<code>__LINKEDIT</code>中）的索引数组，其顺序与非惰性和惰性符号部分中的指针顺序相同。因此，给定结构节<code>nl_symbol_ptr</code>，该节中第一个地址的符号表中相应的索引是<code>indirect_symbol_table [nl_symbol_ptr-&gt; reserved1]</code>。符号表本身是一个<code>struct nlists</code>数组（参见<code>&lt;mach-o / nlist.h&gt;</code>），并且每个<code>nlist</code>在<code>__LINKEDIT</code>中包含一个到字符串表中的索引，其中存储了实际的符号名称。因此，对于每个指针<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code>，我们可以找到相应的符号，然后找到相应的字符串与请求的符号名称进行比较，如果匹配，我们用该替换替换该部分中的指针。</p>

<p>在惰性或非惰性指针表中查找给定条目的名称的过程如下所示：<br/>
<img src="media/15262813725894/15262819366331.jpg" alt="通过符号表查找字符串"/></p>

<p>原理</p>

<ol>
<li><p>MachO 是被谁加载的  DYLD动态加载</p></li>
<li><p>ASLR（地址空间配置随机加载）  MachO文件加载的时候是随机地址</p></li>
<li><p>PIC 位置代码独立</p>
<ul>
<li>如果MachO内部需要调用系统的库函数时</li>
<li>现在——DATA段中简历一个指针，指向外部函数</li>
<li>DYLD会动态的进行绑定！将MachO中的DATA段中的指针，指向外部函数</li>
</ul></li>
</ol>

<h3 id="toc_5">3、Cydia Substrate</h3>

<p><strong>Cydia Substrate</strong> 原名为 <strong>Mobile Substrate</strong> ，它的主要作用是针对OC方法、C函数以及函数地址进行HOOK操作。当然它并不是仅仅针对iOS而设计的，安卓一样可以用。官方地址：<a href="http://www.cydiasubstrate.com/">http://www.cydiasubstrate.com/</a></p>

<p><strong>Cydia Substrate</strong>主要由3部分组成：</p>

<p><strong>MobileHooker</strong></p>

<p>   MobileHooker顾名思义用于HOOK。它定义一系列的宏和函数，底层调用<code>objc</code>的<code>runtime</code>和<code>fishhook</code>来替换系统或者目标应用的函数.<br/>
其中有两个函数:</p>

<ul>
<li><p>MSHookMessageEx 主要作用于Objective-C方法</p>
<pre><code class="language-text">void MSHookMessageEx(Class class, SEL selector, IMP replacement, IMP result)
</code></pre></li>
<li><p>MSHookFunction 主要作用于C和C++函数</p>
<pre><code class="language-text">void MSHookFunction(voidfunction,void* replacement,void** p_original)
</code></pre></li>
</ul>

<blockquote>
<p>Logos语法的%hook 就是对此函数做了一层封装</p>
</blockquote>

<p><strong>MobileLoader</strong><br/>
   MobileLoader用于加载第三方dylib在运行的应用程序中。启动时MobileLoader会根据规则把指定目录的第三方的动态库加载进去，第三方的动态库也就是我们写的破解程序.</p>

<p><strong>safe mode</strong><br/>
   因为APP程序质量参差不齐崩溃再所难免，破解程序本质是dylib，寄生在别人进程里。 系统进程一旦出错，可能导致整个进程崩溃,崩溃后就会造成iOS瘫痪。所以CydiaSubstrate引入了安全模式,在安全模 式下所有基于CydiaSubstratede 的三方dylib都会被禁用，便于查错与修复。</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15261041285565.html">
                
                  <h1>iOS App MachO注入 - Dylib注入</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">dylib 注入</h2>

<h3 id="toc_1">1. 新建<code>TARGETS</code></h3>

<p><img src="media/15259432014565/15260315279124.jpg" alt=""/></p>

<h3 id="toc_2">2. 添加依赖关系</h3>

<ul>
<li>在<code>Buildd Phases</code>选择<code>New Copy Files Phase</code>新建依赖库文件，选择<code>Destination</code>为<code>Framework</code>。添加刚刚新建的frammework库</li>
</ul>

<p><img src="media/15259432014565/15260317398242.jpg" alt=""/></p>

<h3 id="toc_3">3. 修改平台</h3>

<ul>
<li><p>修改<code>Architectures</code>为<code>iOS</code><br/>
<img src="media/15259432014565/15260325712384.jpg" alt=""/></p></li>
<li><p>修改<code>Signing</code>为<code>iOS</code><br/>
<img src="media/15259432014565/15260326574559.jpg" alt=""/></p></li>
</ul>

<h3 id="toc_4">4. 修改MachO文件的Load Commands（将<code>Dylib</code>库注入到可执行文件中）</h3>

<ul>
<li>使用<code>yololib</code>工具注入（手动）</li>
</ul>

<pre><code class="language-text">$ yololib WeChact Frameworks/libHookDylib.dylib
</code></pre>

<ul>
<li>使用<code>yololib</code>工具注入（脚本）</li>
</ul>

<pre><code class="language-text"># 需要注入的动态库的路径(写死了)
INJECT_FRAMEWORK_RELATIVE_PATH=&quot;Frameworks/libHookDylib.dylib&quot;

## 通过工具实现注入
&quot;/${SRCROOT}&quot;/yololib &quot;$TARGET_APP_PATH/$APP_BINARY&quot; &quot;$INJECT_FRAMEWORK_RELATIVE_PATH&quot;
</code></pre>

<h3 id="toc_5">5. 注入代码</h3>

<p>实现<code>load</code>方法，利用<code>Method Swizzle</code>实现修改</p>

<p><img src="media/15259432014565/15260335898629.jpg" alt=""/></p>

<h3 id="toc_6">GitHub</h3>

<p><a href="https://github.com/Caolongs/iOSInjectFramework">GitHub Demo</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15259432014565.html">
                
                  <h1>iOS App MachO注入 - Framework注入</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">Framework注入</h2>

<h3 id="toc_1">1. 新建<code>TARGETS</code></h3>

<p><img src="media/15259432014565/15259460082674.jpg" alt=""/></p>

<h3 id="toc_2">2. 添加依赖关系</h3>

<ul>
<li>在<code>Buildd Phases</code>选择<code>New Copy Files Phase</code>新建依赖库文件，选择<code>Destination</code>为<code>Framework</code>。添加刚刚新建的frammework库</li>
</ul>

<p><img src="media/15259432014565/15260229574177.jpg" alt=""/></p>

<p><img src="media/15259432014565/15260231241298.jpg" alt=""/></p>

<ul>
<li>验证<code>frammewor</code>注入库添加依赖是否成功<br/>
编译程序，打开<code>Products</code>下app文件，包内容下<code>Frameworks</code>文件下已生成对应注入库
<img src="media/15259432014565/15260234170472.jpg" alt=""/></li>
</ul>

<h3 id="toc_3">3. 修改MachO文件的Load Commands（将<code>frammewor</code>库注入到可执行文件中）</h3>

<ul>
<li>使用<code>yololib</code>工具注入（手动）</li>
</ul>

<pre><code class="language-text">$ yololib WeChact Frameworks/HookFramework.framework/HookFramework
</code></pre>

<ul>
<li>使用<code>yololib</code>工具注入（脚本）</li>
</ul>

<pre><code class="language-text"># 需要注入的动态库的路径(写死了)
INJECT_FRAMEWORK_RELATIVE_PATH=&quot;Frameworks/HookFramework.framework/HookFramework&quot;

## 通过工具实现注入
&quot;/${SRCROOT}&quot;/yololib &quot;$TARGET_APP_PATH/$APP_BINARY&quot; &quot;$INJECT_FRAMEWORK_RELATIVE_PATH&quot;
</code></pre>

<ul>
<li>使用<code>MachOView</code>工具查看是否注入成功</li>
</ul>

<p><img src="media/15259432014565/15260305277989.jpg" alt=""/></p>

<h3 id="toc_4">4. 注入代码</h3>

<p>在<code>HookFramework</code>库下创文件，实现<code>load</code>方法，利用<code>Method Swizzle</code>实现修改<br/>
<img src="media/15259432014565/15260310477278.jpg" alt=""/></p>

<h3 id="toc_5">GitHub</h3>

<p><a href="https://github.com/Caolongs/iOSInjectFramework">GitHub Demo</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15258540971098.html">
                
                  <h1>iOS App 签名过程及重签</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">目的：</h2>

<p>保证 iOS 平台对第三方 APP 有绝对的控制权，每一个安装到 iOS 上的 APP 都是经过苹果官方允许的。</p>

<h2 id="toc_1">签名过程</h2>

<p><img src="media/15258540971098/15258559672530.png" alt=""/></p>

<ol>
<li>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local</li>
<li>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple</li>
<li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li>
<li>在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。</li>
<li>在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。</li>
<li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。</li>
<li>确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。</li>
</ol>

<h2 id="toc_2">概念和操作</h2>

<p>上面的步骤对应到我们平常具体的操作和概念是这样的：</p>

<ol>
<li>第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。</li>
<li>第 2 步苹果处理，不用管。</li>
<li>第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。</li>
<li>第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。</li>
<li>第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。</li>
<li>第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。</li>
</ol>

<p>这里再总结一下这些概念：</p>

<ol>
<li><strong>证书</strong>：内容是公钥或私钥，由其他机构对其签名组成的数据包。</li>
<li><strong>Entitlements</strong>：包含了 App 权限开关列表。</li>
<li><strong>CertificateSigningRequest</strong>：本地公钥。</li>
<li><strong>p12</strong>：本地私钥，可以导入到其他电脑。</li>
<li><strong>Provisioning Profile</strong>：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</li>
</ol>

<h2 id="toc_3">iOS APP 重签名具体操作(手动)</h2>

<ol>
<li>干掉插件Plugins文件夹里面的内容!</li>
<li>Watch 文件删除</li>
<li><p>对 Frameworks 进行签名!</p>
<pre><code class="language-text">`$ codesign -fs &quot;证书&quot; xxx.framework`
</code></pre></li>
<li><p>给可执行文件执行权限! <code>chmod +x WeChat</code></p></li>
<li><p>拷贝描述文件(可新建工程，获取app包中<code>embedded.mobileprovision</code>)</p></li>
<li><p>修改info.plist 的Bundle ID(与描述文件工程一致)</p></li>
<li><p>生成plist的权限文件<code>en.plist</code>(复制<code>embedded.mobileprovision</code>权限内容)，放到<code>Payload</code>目录下</p>
<pre><code class="language-text">&lt;key&gt;keychain-access-groups&lt;/key&gt;
        &lt;array&gt;<br/>
            &lt;string&gt;X7Y****CQ.*&lt;/string&gt;<br/>
        &lt;/array&gt;<br/>
        &lt;key&gt;get-task-allow&lt;/key&gt;<br/>
        &lt;true/&gt;<br/>
        &lt;key&gt;application-identifier&lt;/key&gt;<br/>
        &lt;string&gt;X7Y****JCQ.*&lt;/string&gt;<br/>
        &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;<br/>
        &lt;string&gt;X7Y****CQ&lt;/string&gt;
</code></pre></li>
<li><p>签名整个APP!</p>
<pre><code class="language-text">$ codesign -fs &quot;iPhone Developer: xxxxxx (6ZBE4C573L)&quot;  --no-strict --entitlements=en.plist WeChat.app
</code></pre></li>
<li><p>打包其实就是一个zip</p>
<pre><code class="language-text">$ zip -ry WeChat.ipa Payload
</code></pre>
<p>iPhone Developer: shan jingjing (3QDN5929LL)</p></li>
<li><p>安装到手机</p></li>
</ol>

<p><code>Xcode</code>-&gt;<code>Window</code>-&gt;<code>Devices and Simulators</code>-&gt;<code>Devices INSTALL APP</code> 点击<code>+</code>选中<code>WeChat.ipa</code></p>

<h2 id="toc_4">iOS APP 利用Xcode重签名</h2>

<ol>
<li>创建工程，替换Product下的app</li>
<li>修改<code>Bundle identifier</code>与新建工程一致</li>
<li>Plugins、Watch 文件删除</li>
<li><p>Framework重签名</p>
<pre><code class="language-text">`$ codesign -fs &quot;证书&quot; xxx.framework`
</code></pre></li>
<li><p>给可执行文件执行权限! <code>chmod +x WeChat</code></p></li>
<li><p>Xcode 运行安装至手机</p></li>
</ol>

<h2 id="toc_5">iOS APP 脚本自动化重签名</h2>

<ol>
<li><p>新建工程，添加<code>Run Script</code>脚本</p>
<p><img src="media/15258540971098/15259319285089.jpg" alt=""/></p></li>
</ol>

<pre><code class="language-text"># ${SRCROOT} 它是工程文件所在的目录
TEMP_PATH=&quot;${SRCROOT}/Temp&quot;
#资源文件夹
ASSETS_PATH=&quot;${SRCROOT}/TargetAPP&quot;
#ipa包路径
TARGET_IPA_PATH=&quot;${ASSETS_PATH}/*.ipa&quot;

#新建Temp文件夹
rm -rf &quot;${SRCROOT}/Temp&quot;
mkdir -p &quot;${SRCROOT}/Temp&quot;

#----------------------------------------
# 1. 解压IPA到Temp下
unzip -oqq &quot;$TARGET_IPA_PATH&quot; -d &quot;$TEMP_PATH&quot;
# 拿到解压的临时的APP的路径
TEMP_APP_PATH=$(set -- &quot;$TEMP_PATH/Payload/&quot;*.app;echo &quot;$1&quot;)
# echo &quot;路径是:$TEMP_APP_PATH&quot;


#----------------------------------------
# 2. 将解压出来的.app拷贝进入工程下
# BUILT_PRODUCTS_DIR 工程生成的APP包的路径
# TARGET_NAME target名称
TARGET_APP_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app&quot;
echo &quot;app路径:$TARGET_APP_PATH&quot;

rm -rf &quot;$TARGET_APP_PATH&quot;
mkdir -p &quot;$TARGET_APP_PATH&quot;
cp -rf &quot;$TEMP_APP_PATH/&quot; &quot;$TARGET_APP_PATH&quot;


#----------------------------------------
# 3. 删除extension和WatchAPP.个人证书没法签名Extention
rm -rf &quot;$TARGET_APP_PATH/PlugIns&quot;
rm -rf &quot;$TARGET_APP_PATH/Watch&quot;


#----------------------------------------
# 4. 更新info.plist文件 CFBundleIdentifier
#  设置:&quot;Set : KEY Value&quot; &quot;目标文件路径&quot;
/usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;


#----------------------------------------
# 5. 给MachO文件上执行权限
# 拿到MachO文件的路径
APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\&gt;|cut -f1 -d\&lt;`
#上可执行权限
chmod +x &quot;$TARGET_APP_PATH/$APP_BINARY&quot;


#----------------------------------------
# 6. 重签名第三方 FrameWorks
TARGET_APP_FRAMEWORKS_PATH=&quot;$TARGET_APP_PATH/Frameworks&quot;

if [ -d &quot;$TARGET_APP_FRAMEWORKS_PATH&quot; ];
then
for FRAMEWORK in &quot;$TARGET_APP_FRAMEWORKS_PATH/&quot;*
do

    if test -f  $FRAMEWORK
    then
    #签名
    /usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$FRAMEWORK&quot;
    fi
done
fi

</code></pre>

<hr/>

<hr/>

<h2 id="toc_6">命令</h2>

<pre><code class="language-text">查看描述文件信息: $ security cms -D -i 描述文件路径

查看APP的签名信息
$ codesign -vv -d APP路径(.app)

查看本机所有证书
$ security find-identity -v -p codesigning

查看可执行文件的加密信息!
$ otool -l WeChat | grep crypt

签名
$ codesign -fs &quot;证书&quot; 需要签名的文件
</code></pre>

<h2 id="toc_7">参考</h2>

<p><a href="http://blog.cnbang.net/tech/3386/">iOS App 签名的原理</a></p>

<ul>
<li>
<a href="#toc_0">目的：</a>
</li>
<li>
<a href="#toc_1">签名过程</a>
</li>
<li>
<a href="#toc_2">概念和操作</a>
</li>
<li>
<a href="#toc_3">iOS APP 重签名具体操作(手动)</a>
</li>
<li>
<a href="#toc_4">iOS APP 利用Xcode重签名</a>
</li>
<li>
<a href="#toc_5">iOS APP 脚本自动化重签名</a>
</li>
<li>
<a href="#toc_6">命令</a>
</li>
<li>
<a href="#toc_7">参考</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15253297909641.html">
                
                  <h1>加密（哈希、AES、RSA）</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">一、哈希（散列）函数</h3>

<ul>
<li>MD5 </li>
<li>SHA1 </li>
<li>SHA256/512</li>
<li>HMAC</li>
</ul>

<h4 id="toc_1">特点：</h4>

<ul>
<li>算法公开</li>
<li>对不同数据加密结果是定长的!32位字符!!</li>
<li>信息摘要(加密之后的数据是不可逆!!)</li>
</ul>

<h4 id="toc_2">应用：</h4>

<ul>
<li>一般用来做密码加密!</li>
<li>版权问题，MD5值!</li>
<li>搜索引擎</li>
<li>云盘秒传（服务器上只要有这个文件,那么用户可以实现秒传）</li>
<li>签名验证 (信息+信息MD5发送给服务器)</li>
<li>HMAC （可用于设备锁）</li>
</ul>

<blockquote>
<p>较为安全的hash登录加密方案：<br/>
（HMAC+<code>网络时间戳</code>).MD5</p>
</blockquote>

<h4 id="toc_3">终端</h4>

<p>Mac系统有一个开源的密码库openssl，几乎集成所有的加密算法<br/>
opsenssl是一个最具说服力的标准</p>

<ul>
<li>计算MD5加密</li>
</ul>

<pre><code class="language-text">$ md5 -s &quot;string&quot;
</code></pre>

<ul>
<li>计算SHA1散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha1
</code></pre>

<ul>
<li>计算SHA256散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha256
</code></pre>

<ul>
<li>计算SHA 512散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha512
</code></pre>

<hr/>

<ul>
<li>计算HMAC MD5散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl dgst -md5 -hmac &quot;key&quot;
</code></pre>

<ul>
<li>计算HMAC SHA1散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha1 -hmac &quot;key&quot;
</code></pre>

<ul>
<li>计算HMAC SHA256散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha256 -hmac &quot;key&quot;
</code></pre>

<ul>
<li>计算HMAC SHA512散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha512 -hmac &quot;key&quot;
</code></pre>

<hr/>

<ul>
<li>计算文件的MD5散列结果</li>
</ul>

<pre><code class="language-text">$ md5 file.dat
</code></pre>

<ul>
<li>计算文件的SHA1散列结果</li>
</ul>

<pre><code class="language-text">$ openssl sha -sha1 file.dat
</code></pre>

<ul>
<li>计算文件的SHA256散列结果</li>
</ul>

<pre><code class="language-text">$ openssl sha -sha256 file.dat
</code></pre>

<ul>
<li>计算文件的SHA512散列结果</li>
</ul>

<pre><code class="language-text">$ openssl sha -sha512 file.dat
</code></pre>

<h3 id="toc_4">二、对称加密算法（传统加密算法）</h3>

<p>加密和解密都是同一个密钥</p>

<ul>
<li>DES   目前几乎不用，强度不够</li>
<li>3DES  使用3个密钥,对相同的数据执行三次加密,强度增强</li>
<li>AES   高级密码标准,苹果钥匙串访问</li>
</ul>

<h4 id="toc_5">每个对称加密算法有两种加密方式</h4>

<ul>
<li>1. ECB加密： 电子代码本，就是简单的将数据拆包，每一块独立加密</li>
<li>2. CBC（密码块链）加密： 也是独立加密一块数据，但是第二块数据和第一块数据有密切的联系</li>
</ul>

<h4 id="toc_6">终端</h4>

<pre><code class="language-text">/**
 *  终端测试指令
 *
 *  DES(ECB)加密
 *  $ echo -n hello | openssl enc -des-ecb -K 616263 -nosalt | base64
 *
 *  DES(CBC)加密
 *  $ echo -n hello | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt | base64
 *
 *  AES(ECB)加密
 *  $ echo -n hello | openssl enc -aes-128-ecb -K 616263 -nosalt | base64
 *
 *  AES(CBC)加密
 *  $ echo -n hello | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt | base64
 *
 *  DES(ECB)解密
 *  $ echo -n HQr0Oij2kbo= | base64 -D | openssl enc -des-ecb -K 616263 -nosalt -d
 *
 *  DES(CBC)解密
 *  $ echo -n alvrvb3Gz88= | base64 -D | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -d
 *
 *  AES(ECB)解密
 *  $ echo -n d1QG4T2tivoi0Kiu3NEmZQ== | base64 -D | openssl enc -aes-128-ecb -K 616263 -nosalt -d
 *
 *  AES(CBC)解密
 *  $ echo -n u3W/N816uzFpcg6pZ+kbdg== | base64 -D | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt -d
 *
 *  提示：
 *      1&gt; 加密过程是先加密，再base64编码
 *      2&gt; 解密过程是先base64解码，再解密
 */
</code></pre>

<h4 id="toc_7">iOS 加密核心函数</h4>

<pre><code class="language-text">CCCryptorStatus CCCrypt(
    CCOperation op,         /* 加密/解密 */
    CCAlgorithm alg,        /* 加密算法 */
    CCOptions options,      /* CBC/ECB */
    const void *key,        /* 加密密钥 */
    size_t keyLength,       /* 密钥长度 */
    const void *iv,         /* iv初始化向量 */
    const void *dataIn,     /* 加密的数据 */
    size_t dataInLength,    /* 加密的数据长度  */
    void *dataOut,          /* 密文的缓冲区 */
    size_t dataOutAvailable,/* 缓冲区的大小 */
    size_t *dataOutMoved)   /* 加密结果的大小 */                                     
</code></pre>

<h3 id="toc_8">三、非对称加密算法（现在加密算法）</h3>

<p>私钥加密 公钥解密<br/>
公钥加密 私钥解密</p>

<ul>
<li>终端生成密钥</li>
</ul>

<p>生成私钥：</p>

<pre><code class="language-text">$ openssl genrsa -out private.pem 512
</code></pre>

<p>生成公钥：</p>

<pre><code class="language-text">$ openssl rsa -in private.pem -out public.pem -pubout
</code></pre>

<ul>
<li>算法</li>
</ul>

<blockquote>
<ol>
<li>选两个质数 p 和 q，相乘得出一个大整数n，例如 p = 61，q = 53，n = pq = 3233</li>
<li>选 1-n 间的随便一个质数e，例如 e = 17</li>
<li>经过一系列数学公式，算出一个数字 d，满足:
<ul>
<li>通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。</li>
<li>如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。</li>
</ul></li>
</ol>

<p>上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用私钥加密，公钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥 (只知道 n 和 e)的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而 n 数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。</p>
</blockquote>

<h2 id="toc_9">目录</h2>

<ul>
<li>
<a href="#toc_0">一、哈希（散列）函数</a>
<ul>
<li>
<a href="#toc_1">特点：</a>
</li>
<li>
<a href="#toc_2">应用：</a>
</li>
<li>
<a href="#toc_3">终端</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">二、对称加密算法（传统加密算法）</a>
<ul>
<li>
<a href="#toc_5">每个对称加密算法有两种加密方式</a>
</li>
<li>
<a href="#toc_6">终端</a>
</li>
<li>
<a href="#toc_7">iOS 加密核心函数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">三、非对称加密算法（现在加密算法）</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">目录</a>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15253114095127.html">
                
                  <h1>LLDB 使用</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>LLDB(Low Lever Debug)命令结构</p>

<pre><code class="language-text">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]
</code></pre>

<blockquote>
<p>其中：</p>

<ol>
<li><command>(命令)和<subcommand>(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</li>
<li><action>：我们想在前面的命令序列的上下文中执行的一些操作。</li>
<li><options>：行为修改器(action modifiers)。通常带有一些值。</li>
<li><argument>：根据使用的命令的上下文来表示各种不同的东西。</li>
</ol>
</blockquote>

<h2 id="toc_0">设置断点</h2>

<ul>
<li>breakpoint</li>
</ul>

<pre><code class="language-text">$ breakpoint set -n [方法字符串]

例如：
$ breakpoint set -n &quot;viewDidLoad&quot;

`其中 -n 是 --name缩写`
</code></pre>

<ul>
<li>显示当前断点</li>
</ul>

<pre><code class="language-text">$ breakpoint list
</code></pre>

<ul>
<li>禁用</li>
</ul>

<pre><code class="language-text">$ breakpoint disable [编号]
</code></pre>

<ul>
<li>启用</li>
</ul>

<pre><code class="language-text">$ breakpoint enable [编号]
</code></pre>

<ul>
<li>删除（只能按组删除，不能删除组中的某个）</li>
</ul>

<pre><code class="language-text">$ breakpoint delete 【编号】
</code></pre>

<ul>
<li>根据selector方法设置断点</li>
</ul>

<pre><code class="language-text">$ breakpoint set —-selector [方法]

例如：
$ breakpoint set --selector dealloc
</code></pre>

<ul>
<li>根据某个文件中的selector方法设置断点</li>
</ul>

<pre><code class="language-text">$ breakpoint set —file [文件] —-selector [方法]
</code></pre>

<ul>
<li>遍历项目中所有包含 testFunc 字符串的方法并设置断点</li>
</ul>

<pre><code class="language-text">$ breakpoint set -r [方法字符串]

例如：
$ breakpoint set -r &quot;testFunc&quot;
</code></pre>

<h2 id="toc_1">流程控制</h2>

<ul>
<li>继续执行</li>
</ul>

<pre><code class="language-text">$ c continue
</code></pre>

<ul>
<li>单步运行,将子函数当做整体一步执行</li>
</ul>

<pre><code class="language-text">$ n next
</code></pre>

<ul>
<li>单步运行,遇到子函数会进去</li>
</ul>

<pre><code class="language-text">$ s 
</code></pre>

<ul>
<li>按住 <code>ctrl</code> 汇编级别 </li>
</ul>

<pre><code class="language-text">$ ni
$ si
</code></pre>

<h2 id="toc_2">expresion</h2>

<p>执行代码，例如当你需要改变一些东西,但是因为某种原因不能编译</p>

<pre><code class="language-text">$ expresion [代码]
</code></pre>

<p>例：</p>

<pre><code class="language-text">$ expression self.view.backgroundColor = [UIColor redColor];
</code></pre>

<p>换行<code>ctrl</code>+<code>enter</code></p>

<h2 id="toc_3">调用栈 bt</h2>

<p>Show the current thread&#39;s call stack. </p>

<ul>
<li>显示调用栈</li>
</ul>

<pre><code class="language-text">$ bt
</code></pre>

<ul>
<li>上一个方法的调用者</li>
</ul>

<pre><code class="language-text">$ up
</code></pre>

<ul>
<li>下一个方法的调用者</li>
</ul>

<pre><code class="language-text">$ down
</code></pre>

<ul>
<li>调到指定调用者</li>
</ul>

<pre><code class="language-text">$ frame select [bt 显示的frame 编号]
</code></pre>

<h2 id="toc_4">watchpoint</h2>

<p>内存断点，断点对象属性，类似kvo</p>

<p>根据变量名称</p>

<pre><code class="language-text">$ watchpoint set variable  [self-&gt;name]
</code></pre>

<p>根据内存地址</p>

<pre><code class="language-text">$ watchpoint set expresion  [内存地址]
</code></pre>

<h2 id="toc_5">breakpoint command</h2>

<ul>
<li>断点触发 指令（触发时执行指令添加）</li>
</ul>

<pre><code class="language-text">$ break command add [编号]
</code></pre>

<p>例如：</p>

<pre><code class="language-text">(lldb) breakpoint command add 5.1
Enter your debugger command(s).  Type &#39;DONE&#39; to end.
&gt; 
</code></pre>

<ul>
<li>查看</li>
</ul>

<pre><code class="language-text">$ break command list [编号]
</code></pre>

<ul>
<li>删除</li>
</ul>

<pre><code class="language-text">$ break command delete [编号]
</code></pre>

<h2 id="toc_6">target stop-hook</h2>

<p>每次stop的时候去执行一些命令，只对breakpoint，watchpoint有效</p>

<pre><code class="language-text">//每次stop执行frame variable
$ target stop-hook add -o &quot;frame variable&quot; 

$ target stop-hook list

$ target stop-hook delete
</code></pre>

<h2 id="toc_7">frame</h2>

<ul>
<li>Print out a list of all variables in the current frame</li>
</ul>

<pre><code class="language-text">$ frame variable
</code></pre>

<ul>
<li>Need to know where you are?</li>
</ul>

<pre><code class="language-text">$ frame info
</code></pre>

<h2 id="toc_8">thread</h2>

<ul>
<li>代码回滚，之后代码将不会执行</li>
</ul>

<pre><code class="language-text">$ thread return
</code></pre>

<h2 id="toc_9">.lldbinit 文件配置</h2>

<p>目录 <code>/Users/caolongjian/.lldbinit</code><br/>
lldb每次启动都会调用，用于导入配置文件</p>

<h2 id="toc_10">其他常用</h2>

<ul>
<li>数组越界崩溃信息查看</li>
</ul>

<pre><code class="language-text">$ image lookup -a [地址0x]
</code></pre>

<ul>
<li>快速查看类</li>
</ul>

<pre><code class="language-text">$ image lookup -t [类 Person]
</code></pre>

<ul>
<li>List current executable and dependent shared library images.</li>
</ul>

<pre><code class="language-text">$ image list
</code></pre>

<h2 id="toc_11">help</h2>

<p>获取帮助信息<br/>
<code>help &lt;command-name&gt;</code> 、<code>help &lt;command-name&gt; &lt;option&gt;</code></p>

<pre><code class="language-text">$ help
$ help breakpoint
</code></pre>

<ul>
<li>
<a href="#toc_0">设置断点</a>
</li>
<li>
<a href="#toc_1">流程控制</a>
</li>
<li>
<a href="#toc_2">expresion</a>
</li>
<li>
<a href="#toc_3">调用栈 bt</a>
</li>
<li>
<a href="#toc_4">watchpoint</a>
</li>
<li>
<a href="#toc_5">breakpoint command</a>
</li>
<li>
<a href="#toc_6">target stop-hook</a>
</li>
<li>
<a href="#toc_7">frame</a>
</li>
<li>
<a href="#toc_8">thread</a>
</li>
<li>
<a href="#toc_9">.lldbinit 文件配置</a>
</li>
<li>
<a href="#toc_10">其他常用</a>
</li>
<li>
<a href="#toc_11">help</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15246450401949.html">
                
                  <h1>初识汇编</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>我们在学习逆向开发之前,我们要了解一个基本的逆向原理.首先我们是逆向iOS系统上面的APP.那么我们知道,一个APP安装在手机上面的可执行文件本质上是二进制文件.因为iPhone手机本质上执行的指令是二进制.是由手机上的CPU执行的.所以逆向开发是建立在分析二进制上面.所以今天我们接下来的课程从非常基础的东西开始讲解.</p>

<h2 id="toc_0">汇编语言的发展</h2>

<h3 id="toc_1">机器语言</h3>

<blockquote>
<p>由0和1组成的机器指令.</p>
</blockquote>

<ul>
<li>加：0100 0000</li>
<li>减：0100 1000</li>
<li>乘：1111 0111 1110 0000 </li>
<li>除：1111 0111 1111 0000 </li>
</ul>

<h3 id="toc_2">汇编语言(assembly language)</h3>

<blockquote>
<p>使用助记符代替机器语言<br/>
如:</p>
</blockquote>

<ul>
<li>加：INC EAX     通过编译器 0100 0000</li>
<li>减：DEC EAX     通过编译器 0100 1000</li>
<li>乘：MUL EAX         通过编译器 1111 0111 1110 0000</li>
<li>除：DIV EAX     通过编译器 1111 0111 1111 0000</li>
</ul>

<h3 id="toc_3">高级语言（High-level programming language)</h3>

<blockquote>
<p>C\C++\Java\OC\Swift,更加接近人类的自然语言<br/>
比如C语言:</p>
</blockquote>

<ul>
<li>加：A+B     通过编译器           0100 0000</li>
<li>减：A-B     通过编译器           0100 1000</li>
<li>乘：A*B     通过编译器           1111 0111 1110 0000</li>
<li>除：A/B     通过编译器           1111 0111 1111 0000</li>
</ul>

<p>我们的代码在终端设备上是这样的过程:<br/>
<img src="media/15246450401949/15193669666308.jpg" alt="15193669666308"/></p>

<ul>
<li> <strong>汇编语言</strong>与<strong>机器语言</strong>一一对应，每一条机器指令都有与之对应的汇编指令</li>
<li> <strong>汇编语言</strong>可以通过编译得到<strong>机器语言</strong>，<strong>机器语言</strong>可以通过反汇编得到<strong>汇编语言</strong></li>
<li> <strong>高级语言</strong>可以通过编译得到<strong>汇编语言</strong> \ <strong>机器语言</strong>，但汇编语言\机器语言几乎不可能还原成<strong>高级语言</strong></li>
</ul>

<h3 id="toc_4">汇编语言的特点</h3>

<ul>
<li><p>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</p></li>
<li><p>能够不受编译器的限制，对生成的二进制代码进行完全的控制</p></li>
<li><p>目标代码简短，占用内存少，执行速度快</p></li>
<li><p>汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</p></li>
<li><p>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</p></li>
<li><p>不区分大小写，比如mov和MOV是一样的</p></li>
</ul>

<h3 id="toc_5">汇编的用途(哥么我学了能干啥?)</h3>

<ul>
<li>编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li>
<li>对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li>
<li>软件安全
<ul>
<li>病毒分析与防治</li>
<li>逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li>
</ul></li>
<li>理解整个计算机系统的最佳起点和最有效途径</li>
<li>为编写高效代码打下基础</li>
<li>弄清代码的本质
<ul>
<li>函数的本质究竟是什么?</li>
<li>++a + ++a + ++a 底层如何执行的?</li>
<li>编译器到底帮我们干了什么?</li>
<li>DEBUG模式和RELEASE模式有什么关键的地方被我们忽略</li>
<li>......</li>
</ul></li>
</ul>

<p>最后来句装13的话</p>

<blockquote>
<p>越底层越单纯!真正的程序员都需要了解的一门非常重要的语言,汇编!</p>
</blockquote>

<h3 id="toc_6">汇编语言的种类</h3>

<ul>
<li><p>目前讨论比较多的汇编语言有</p>
<ul>
<li>8086汇编（8086处理器是16bit的CPU）</li>
<li>Win32汇编</li>
<li>Win64汇编</li>
<li>ARM汇编（嵌入式、Mac、iOS）</li>
<li>......</li>
</ul></li>
<li><p>我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同.</p></li>
</ul>

<table>
<thead>
<tr>
<th>架构</th>
<th>设备</th>
</tr>
</thead>

<tbody>
<tr>
<td>armv6</td>
<td>iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td>arm64</td>
<td>iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后</td>
</tr>
</tbody>
</table>

<h3 id="toc_7">几个必要的常识</h3>

<ul>
<li>要想学好汇编,首先需要了解CPU等硬件结构</li>
<li>APP/程序的执行过程</li>
</ul>

<p><img src="media/15246450401949/15193672391363.jpg" alt="15193672391363"/></p>

<ul>
<li>硬件相关最为重要是CPU/内存</li>
<li>在汇编中,大部分指令都是和CPU与内存相关的</li>
</ul>

<h3 id="toc_8">总线</h3>

<p><img src="media/15246450401949/15193692496345.jpg" alt="15193692496345"/><br/>
<img src="media/15246450401949/15193692648349.jpg" alt="15193692648349"/></p>

<ul>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互</li>
<li>总线：一根根导线的集合</li>
<li>总线的分类
<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul></li>
</ul>

<p><img src="media/15246450401949/15193693448725.jpg" alt="15193693448725"/></p>

<p><strong>举个例子</strong></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-bfac743167c4e554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来至书上的截图"/></p>

<ul>
<li><strong>地址总线</strong>
<ul>
<li>它的宽度决定了CPU的_寻址能力_</li>
<li>8086的地址总线宽度是_20_，所以寻址能力是_1M_（ 2<sup>20</sup>  ）</li>
</ul></li>
</ul>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-b22c5ebccc4e6a9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<ul>
<li><strong>数据总线</strong>
<ul>
<li>它的宽度决定了CPU的单次数据传送量，也就是数据_传送速度_</li>
<li>8086的数据总线宽度是_16_，所以单次最大传递_2个字节_的数据</li>
</ul></li>
<li><strong>控制总线</strong>
<ul>
<li>它的宽度决定了CPU对其他器件的_控制能力_、能有多少种控制</li>
</ul></li>
</ul>

<p><strong>做个小练习</strong></p>

<ul>
<li>一个CPU 的寻址能力为8KB,那么它的地址总线的宽度为____</li>
<li>8080,8088,80286,80386 的<strong>地址总线</strong>宽度分别为16根,20根,24根,32根.那么他们的寻址能力分别为多少____KB, ____MB,____MB,____GB?</li>
<li>8080,8088,8086,80286,80386 的<strong>数据总线</strong>宽度分别为8根,8根,16根,16根,32根.那么它们一次可以传输的数据为:____B,____B,____B,____B,____B,</li>
<li>从内存中读取1024字节的数据,8086至少要读____次,80386至少要读取____次.</li>
</ul>

<p><strong>答案</strong></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-c9eddd9d28a8cb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="练习"/></p>

<h3 id="toc_9">内存</h3>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-cb3c46652c7bad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储区的逻辑连接"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-49e73b88a2e7af92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储器的逻辑连接-物理地址对应图"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-d723c11cce5cdaaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储器的物理地址情况"/></p>

<ul>
<li><p>内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2<sup>20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB</sup></p></li>
<li><p>0x00000~0x9FFFF：主存储器。可读可写</p></li>
<li><p>0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写</p></li>
<li><p>0xC0000~0xFFFFF：存储各种硬件\系统信息。只读</p></li>
</ul>

<h2 id="toc_10">进制</h2>

<p><strong>学习进制的障碍</strong></p>

<blockquote>
<p>很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的.<br/>
我们为什么一定要转换十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换.<br/>
每一种进制都是完美的,想学好进制首先要忘掉十进制，也要忘掉进制间的转换！</p>
</blockquote>

<h3 id="toc_11">进制的定义</h3>

<ul>
<li>八进制由8个符号组成:0 1 2 3 4 5 6 7 逢八进一</li>
<li>十进制由10个符号组成:0 1 2 3 4 5 6 7 8 9逢十进一</li>
<li>N进制就是由N个符号组成:逢N进一</li>
</ul>

<h5 id="toc_12">做个练习</h5>

<ul>
<li>1 + 1 在____情况下等于 3 ?</li>
</ul>

<pre><code class="language-思考">.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>

<blockquote>
<p>十进制由10个符号组成: 0 1 3 2 8 A B E S 7 逢十进一</p>
</blockquote>

<p>如果这样定义十进制: 1 + 1 = 3!就对了!</p>

<p><strong>这样的目的何在?</strong><br/>
传统我们定义的十进制和自定义的十进制不一样.那么这10个符号如果我们不告诉别人这个符号表,别人是没办法拿到我们的具体数据的!用于加密!</p>

<blockquote>
<p><strong>十进制</strong>由十个<strong>符号</strong>组成,逢十进一,<strong>符号</strong>是可以<strong>自定义</strong>的!!</p>
</blockquote>

<h3 id="toc_13">进制的运算</h3>

<h5 id="toc_14">做个练习</h5>

<ul>
<li>八进制运算
<ul>
<li>2 + 3 = __ , 2 * 3 = __ ,4 + 5 = __ ,4 * 5 = __.</li>
<li>277 + 333 = __ , 276 * 54 = __ , 237 - 54 = __ , 234 / 4 = __ .</li>
</ul></li>
</ul>

<h5 id="toc_15">八进制加法表</h5>

<pre><code class="language-text"> 0  1  2  3  4  5  6  7 
10 11 12 13 14 15 16 17
20 21 22 23 24 25 26 27
...

1+1 = 2                     
1+2 = 3   2+2 = 4               
1+3 = 4   2+3 = 5   3+3 = 6
1+4 = 5   2+4 = 6   3+4 = 7   4+4 = 10  
1+5 = 6   2+5 = 7   3+5 = 10  4+5 = 11  5+5 = 12
1+6 = 7   2+6 = 10  3+6 = 11  4+6 = 12  5+6 = 13  6+6 = 14
1+7 = 10  2+7 = 11  3+7 = 12  4+7 = 13  5+7 = 14  6+7 = 15  7+7 = 16
</code></pre>

<h5 id="toc_16">八进制乘法表</h5>

<pre><code class="language-text">0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27...
1*1 = 1                     
1*2 = 2   2*2 = 4               
1*3 = 3   2*3 = 6   3*3 = 11    
1*4 = 4   2*4 = 10  3*4 = 14  4*4 = 20
1*5 = 5   2*5 = 12  3*5 = 17  4*5 = 24  5*5 = 31
1*6 = 6   2*6 = 14  3*6 = 22  4*6 = 30  5*6 = 36  6*6 = 44
1*7 = 7   2*7 = 16  3*7 = 25  4*7 = 34  5*7 = 43  6*7 = 52  7*7 = 61
</code></pre>

<h5 id="toc_17">实战四则运算</h5>

<pre><code class="language-text">   277         236         276         234
+  333       -  54       *  54       /   4
--------    --------    --------    --------    
</code></pre>

<h3 id="toc_18">二进制的简写形式</h3>

<pre><code class="language-text">       二进制: 1 0 1 1 1 0 1 1 1 1 0 0
三个二进制一组: 101 110 111 100
       八进制:   5   6   7   4
四个二进制一组: 1011 1011 1100
     十六进制:    b    b    c
</code></pre>

<blockquote>
<p>二进制：从0 写到 1111<br/>
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 <br/>
这种二进制使用起来太麻烦，改成更简单一点的符号：<br/>
0 1 2 3 4 5 6 7 8 9 A B C D E F 这就是十六进制了</p>
</blockquote>

<h3 id="toc_19">数据的宽度</h3>

<p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p>

<pre><code class="language-objectivec">#import &lt;UIKit/UIKit.h&gt;
#import &quot;AppDelegate.h&quot;

int test(){
    int cTemp = 0x1FFFFFFFF;
    return cTemp;
}

int main(int argc, char * argv[]) {
    printf(&quot;%x\n&quot;,test());
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>

<h3 id="toc_20">计算机中常见的数据宽度</h3>

<ul>
<li>位(Bit): 1个位就是1个二进制位.0或者1</li>
<li>字节(Byte): 1个字节由8个Bit组成(8位).内存中的最小单元Byte.</li>
<li>字(Word): 1个字由2个字节组成(16位),这2个字节分别称为高字节和低字节.</li>
<li>双字(Doubleword): 1个双字由两个字组成(32位)</li>
</ul>

<p>那么计算机存储数据它会分为有符号数和无符号数.那么关于这个看图就理解了!<br/>
<img src="media/15246450401949/15178439312380.jpg" alt="15178439312380"/></p>

<pre><code class="language-text">无符号数,直接换算!
有符号数:
正数:  0    1    2    3    4    5    6    7 
负数:  F    E    D    B    C    A    9    8
      -1   -2   -3   -4   -5   -6   -7   -8
</code></pre>

<h3 id="toc_21">自定义进制符号</h3>

<h5 id="toc_22">练习</h5>

<ul>
<li>现在有10进制数 10个符号分别是：2，9，1，7，6，5，4， 8，3 , A 逢10进1 那么： 123 + 234 = ____</li>
</ul>

<pre><code class="language-text">
十进制:    0  1  2  3  4  5  6  7  8  9
自定义:    2  9  1  7  6  5  4  8  3  A
         92 99 91 97 96 95 94 98 93 9A
         12 19 11 17 16 15 14 18 13 1A
         72 79 71 77 76 75 74 78 73 7A
         62 69 61 67 66 65 64 68 63 6A
         52 59 51 57 56 55 54 58 53 5A
         42 49 41 47 46 45 44 48 43 4A
         82 89 81 87 86 85 84 88 83 8A
         32 39 31 37 36 35 34 38 33 3A
         922
</code></pre>

<p>那么刚才通过10进制运算可以转化10进制然后查表!但是如果是其他进制.我们就不能转换,要直接学会查表</p>

<ul>
<li>现在有9进制数 9个符号分别是：2，9，1，7，6，5，4， 8，3 逢9进1 那么： 123 + 234 = ____</li>
</ul>

<pre><code class="language-text">
十进制:    0  1  2  3  4  5  6  7  8  
自定义:    2  9  1  7  6  5  4  8  3  
         92 99 91 97 96 95 94 98 93 
         12 19 11 17 16 15 14 18 13 
         72 79 71 77 76 75 74 78 73 
         62 69 61 67 66 65 64 68 63 
         52 59 51 57 56 55 54 58 53 
         42 49 41 47 46 45 44 48 43 
         82 89 81 87 86 85 84 88 83 
         32 39 31 37 36 35 34 38 33 
         922
</code></pre>

<h3 id="toc_23">寄存器</h3>

<p><strong>内部部件之间由总线连接</strong><br/>
<img src="media/15246450401949/15193738988252.jpg" alt="15193738988252"/></p>

<ul>
<li>对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制</li>
<li>不同的CPU，寄存器的个数、结构是不相同的</li>
</ul>

<h3 id="toc_24">通用寄存器</h3>

<ul>
<li><p>ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）</p>
<ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!</li>
</ul>
<p><img src="media/15246450401949/15193699098685.jpg" alt="15193699098685"/></p></li>
<li><p>通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算</p></li>
<li><p>假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间<br/>
<img src="media/15246450401949/15193738988252.jpg" alt="15193738988252"/></p>
<ul>
<li>CPU首先会将红色内存空间的值放到X0寄存器中：mov X0,红色内存空间</li>
<li>然后让X0寄存器与1相加：add X0,1</li>
<li>最后将值赋值给内存空间：mov 蓝色内存空间,X0</li>
</ul></li>
</ul>

<h3 id="toc_25">pc寄存器(program counter)</h3>

<ul>
<li>为指令指针寄存器，它指示了CPU当前要读取指令的地址</li>
<li>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</li>
<li>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
<ul>
<li>比如 1110 0000 0000 0011 0000 1000 1010 1010 </li>
<li>可以当做数据   0xE003008AA </li>
<li>也可以当做指令  mov    x0, x8</li>
</ul></li>
<li>CPU根据什么将内存中的信息看做指令？
<ul>
<li>CPU将pc指向的内存单元的内容看做指令</li>
<li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li>
</ul></li>
</ul>

<h3 id="toc_26">bl指令</h3>

<ul>
<li>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令</li>
<li>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如
<ul>
<li>mov x0,#10、mov x1,#20</li>
</ul></li>
<li><p>但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p></li>
<li><p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p></li>
</ul>

<h3 id="toc_27">bl指令 -- 练习</h3>

<p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p>

<pre><code class="language-text">_A:
    mov x0,#0xa0
    mov x1,#0x00
    add x1, x0, #0x14
    mov x0,x1
    bl _B
    mov x0,#0x0
    ret

_B:
    add x0, x0, #0x10
    ret
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/Caolongs" title="GitHub">GitHub</a>

  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="UML.html"><strong>UML</strong></a>
        
            <a href="%E6%91%84%E5%BD%B1.html"><strong>摄影</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="%E6%9E%B6%E6%9E%84.html"><strong>架构</strong></a>
        
            <a href="CI.html"><strong>CI</strong></a>
        
            <a href="OpenGL.html"><strong>OpenGL</strong></a>
        
            <a href="%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html"><strong>逆向与安全</strong></a>
        
            <a href="AI.html"><strong>AI</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91.html"><strong>音视频</strong></a>
        
            <a href="Shell.html"><strong>Shell</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16025805243229.html">Xcode 12 问题</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15927958863936.html">反射C函数</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15870916897984.html">Xcode 配置常用变量</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15668937540139.html">Python 读取xlsx文件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15659419408474.html">如何确定我是否在调试器下运行</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
