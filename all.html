<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="https://github.com/Caolongs">Alongs</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="https://github.com/Caolongs">Alongs</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="UML.html">UML</a></li>
        
            <li><a href="%E6%91%84%E5%BD%B1.html">摄影</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7.html">工具</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="%E6%9E%B6%E6%9E%84.html">架构</a></li>
        
            <li><a href="CI.html">CI</a></li>
        
            <li><a href="OpenGL.html">OpenGL</a></li>
        
            <li><a href="%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html">逆向与安全</a></li>
        
            <li><a href="AI.html">AI</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91.html">音视频</a></li>
        
            <li><a href="Shell.html">Shell</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16010179174173.html">
                
                  <h1>Android基础入门路线图![androidmap_00](media/16010179174173/androidmap_00.jpg)</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!--  -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/9/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="16006805464877.html">
                
                  <h1>Fragment 向 Activity 传值</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <ul>
<li>在fragment中 定义接口声明接口属性 并绑定Activity</li>
</ul>

<pre><code class="language-text">
//定义接口
  public interface IOnMessClick{
      void onClick(String text);
  }
  
  // 接口属性
 private IOnMessClick listener;
  
  // 绑定activity
  @Override
  public void onAttach(Context context) {
      super.onAttach(context);
      try {
          listener = (IOnMessClick) context;
      }catch (ClassCastException e){
          throw new ClassCastException(&quot;Activity 必须实现 IOnMessageClick接口&quot;);
      }
  }
  
</code></pre>

<ul>
<li>在fragment中 实现传值的调用</li>
</ul>

<pre><code class="language-text">
listener.onClick(&quot;你好&quot;);
</code></pre>

<p>2.在Activity中实现接口</p>

<pre><code class="language-text">
//实现AFragment.IOnMessClick
      @Override
      public void onClick(String text) {
          mTvTitle.setText(text );
      }
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/9/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15927958863936.html">
                
                  <h1>反射C函数</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>int testFunc(int n, int m) {<br/>
  printf(&quot;testFunc&quot;);<br/>
  return 1;<br/>
}</p>

<p>int main() {<br/>
  // ①<br/>
  int (*funcPointer)(int, int) = dlsym(RTLD_DEFAULT, &quot;testFunc&quot;);<br/>
  funcPointer(1, 2);</p>

<p>return 0;<br/>
}</p>

<p><a href="https://blog.cnbang.net/tech/3219/">参见:https://blog.cnbang.net/tech/3219/</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/6/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15870916897984.html">
                
                  <h1>Xcode 配置常用变量</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>PROJECT = HelloWorld</p>

<pre><code class="language-text">PROJECT_DIR = ~/Projects/HelloWorld
PROJECT_FILE_PATH = ${PROJECT_DIR}/HelloWorld.xcodeproj
PROJECT_NAME = HelloWorld

SOURCE_ROOT =${PROJECT_DIR}
SRCROOT =${PROJECT_DIR}

SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk

SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk

SDK_NAME = macosx10.9

</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/4/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15668937540139.html">
                
                  <h1>Python 读取xlsx文件</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">安装 openpyxl</h2>

<pre><code class="language-text">pip3 install openpyxl
</code></pre>

<h2 id="toc_1">示例</h2>

<pre><code class="language-text"> from openpyxl import load_workbook
 
workbook = load_workbook(&#39;strings3.xlsx&#39;)
#booksheet = workbook.active                #获取当前活跃的sheet,默认是第一个sheet
booksheet = workbook[&#39;Sheet 1&#39;]
 
rows = booksheet.rows
columns = booksheet.columns
#迭代所有的行
for row in rows:
    line = [col.value for col in row]
    print(line)

</code></pre>

<p><a href="https://zhuanlan.zhihu.com/p/55332266">参考</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15659419408474.html">
                
                  <h1>如何确定我是否在调试器下运行</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <pre><code class="language-text">#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;sys / types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys / sysctl.h&gt;

static bool AmIBeingDebugged（void）
    //如果正在调试当前进程，则返回true（或者 
    //在调试器下运行或事后连接调试器）。
{
    int junk;
    你NEI [4];
    struct kinfo_proc info;
    size_t大小;

    //初始化标志，以便，如果sysctl失败了一些奇怪的事情 
    //原因，我们得到了可预测的结果。

    info.kp_proc.p_flag = 0;

    //初始化mib，在这种情况下告诉sysctl我们想要的信息
    //我们正在寻找有关特定进程ID的信息。

    mib [0] = CTL_KERN;
    mib [1] = KERN_PROC;
    mib [2] = KERN_PROC_PID;
    mib [3] = getpid（）;

    //调用sysctl。

    size = sizeof（info）;
    junk = sysctl（mib，sizeof（mib）/ sizeof（* mib），＆info，＆size，NULL，0）;
    断言（垃圾== 0）;

    //如果设置了P_TRACED标志，我们正在调试。

    return（（info.kp_proc.p_flag＆P_TRACED）！= 0）;
}
</code></pre>

<p><strong>重要说明</strong>：  由于kinfo_proc结构（in <sys/sysctl.h>）的定义是以条件为条件的__APPLE_API_UNSTABLE，因此您应该将上述代码的使用限制在程序的调试版本中。</p>

<h3 id="toc_0">参考 <a href="https://developer.apple.com/library/archive/qa/qa1361/_index.html#//apple_ref/doc/uid/DTS10003368">Detecting the Debugger</a></h3>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15657731633691.html">
                
                  <h1>iOS 制作静态库自动编译脚本</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">编译framework的shell脚本</h3>

<pre><code class="language-text">#!/bin/sh
#要build的target名
TARGET_NAME=${PROJECT_NAME}
if [[ $1 ]]
then
TARGET_NAME=$1
fi
UNIVERSAL_OUTPUT_FOLDER=&quot;${SRCROOT}/${PROJECT_NAME}_Products/&quot;

#创建输出目录，并删除之前的framework文件
mkdir -p &quot;${UNIVERSAL_OUTPUT_FOLDER}&quot;
rm -rf &quot;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework&quot;

#分别编译模拟器和真机的Framework
xcodebuild -target &quot;${TARGET_NAME}&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build
xcodebuild -target &quot;${TARGET_NAME}&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build

#拷贝framework到univer目录
cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGET_NAME}.framework&quot; &quot;${UNIVERSAL_OUTPUT_FOLDER}&quot;

#合并framework，输出最终的framework到build目录
lipo -create -output &quot;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework/${TARGET_NAME}&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGET_NAME}.framework/${TARGET_NAME}&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${TARGET_NAME}.framework/${TARGET_NAME}&quot;

#删除编译之后生成的无关的配置文件
dir_path=&quot;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework/&quot;
for file in ls $dir_path
do
if [[ ${file} =~ &quot;.xcconfig&quot; ]]
then
rm -f &quot;${dir_path}/${file}&quot;
fi
done

#判断build文件夹是否存在，存在则删除
if [ -d &quot;${SRCROOT}/build&quot; ]
then
rm -rf &quot;${SRCROOT}/build&quot;
fi

rm -rf &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos&quot;

#打开合并后的文件夹
open &quot;${UNIVERSAL_OUTPUT_FOLDER}&quot;
</code></pre>

<h3 id="toc_1">编译library的脚本</h3>

<pre><code class="language-text">#!/bin/sh

#要build的target名
target_Name=${PROJECT_NAME}
if [[ $1 ]]
then
target_Name=$1
fi

UNIVERSAL_OUTPUT_FOLDER=&quot;${SRCROOT}/${PROJECT_NAME}_Products&quot;

# 创建输出目录，并删除之前的文件
rm -rf &quot;${UNIVERSAL_OUTPUT_FOLDER}&quot;
mkdir -p &quot;${UNIVERSAL_OUTPUT_FOLDER}&quot;

# 分别编译真机和模拟器版本
xcodebuild -target &quot;${target_Name}&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos  BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build
xcodebuild -target &quot;${target_Name}&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build

#复制头文件到目标文件夹
HEADER_FOLDER=&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/include/${target_Name}&quot;
if [[ -d &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/usr/local/include&quot; ]]
then
    HEADER_FOLDER=&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/usr/local/include&quot;
fi
cp -R &quot;${HEADER_FOLDER}&quot; &quot;${UNIVERSAL_OUTPUT_FOLDER}&quot;

#合成模拟器和真机.a包
lipo -create &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/lib${target_Name}.a&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/lib${target_Name}.a&quot; -output &quot;${UNIVERSAL_OUTPUT_FOLDER}/lib${target_Name}.a&quot;

# 判断build文件夹是否存在，存在则删除
if [ -d &quot;${SRCROOT}/build&quot; ]
then
rm -rf &quot;${SRCROOT}/build&quot;
fi

#打开目标文件夹
open &quot;${UNIVERSAL_OUTPUT_FOLDER}&quot;
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15610124385065.html">
                
                  <h1>数组操作</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>这将返回一个数组，其中包含myCars数组中每个项目的licensePlate的值：</p>

<pre><code class="language-text">NSArray *licensePlates = [myCars valueForKeyPath:@&quot;licensePlate&quot;]
</code></pre>

<p>如果你只想要唯一的项目(例如)，你可以这样做：</p>

<pre><code class="language-text">NSArray *licensePlates = [myCars valueForKeyPath:@&quot;@distinctUnionOfObjects.licensePlate&quot;];
</code></pre>

<p>筛选数组</p>

<pre><code class="language-text">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;ownerCode == %@&quot;, serviceType];
        NSArray *filteredArray = [self.serviceTypeOptionArr filteredArrayUsingPredicate:predicate];
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/6/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15562444778035.html">
                
                  <h1>NS_UNAVAILABLE</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>NS_UNAVAILABLE的作用是直接禁止此方法的使用，一般常见用法如下：</p>

<pre><code class="language-text">+ (instancetype)new NS_UNAVAILABLE;
+ (instancetype)init NS_UNAVAILABLE;
</code></pre>

<p>这样就不能直接使用这两种创建实例的方法，而需要使用开源库自定义的初始化方法，从而确保了创建实例的统一性</p>

<h3 id="toc_0">NS_EDSIGNATED_INITIALIZER</h3>

<p>NS_EDSIGNATED_INITIALIZER的作用是指定构造器，通常来说指定初始化函数对一个类来说非常重要，参数也会比较多，为了适应不同的初始化需求就有了便利初始化函数。</p>

<pre><code class="language-text">- (instancetype)initWithName:(NSString *)name NS_EDSIGNATED_INITIALIZER;

</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/4/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15553847404538.html">
                
                  <h1>iOS 集合如何弱引用对象</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">一. 使用 NSValue</h2>

<p>NSValue 可以弱引用保存一个对象，我们可以使用这种方法间接的引用。</p>

<pre><code class="language-text">
NSMutableArray *array = @[].mutableCopy;
// 添加
NSObject *obj = [NSObject new];
[array addObject:[NSValue valueWithNonretainedObject:obj]];
// 读取
NSValue *value = array[0];
NSObject *obj2 = [value nonretainedObjectValue];

</code></pre>

<blockquote>
<p><strong>注意</strong>：使用 NSValue 的方式，确实可以实现对对象的弱引用（即被添加到集合中时，对象的引用计数不会+1），但是当对象被释放的时候，数组中对应的对象会变成野指针，因此需要手动删除 NSArray 中对应对象的值，否则会在执行 [value nonretainedObjectValue] 时崩溃；而使用 NSPointerArray 不会有这个问题，对象的释放会使得集合中的对象变为 NULL</p>
</blockquote>

<h2 id="toc_1">二.  使用 NSPointerArray，NSMapTable，NSHashTable</h2>

<p>在iOS6.0之后出现了NSPointerArray，NSMapTable，NSHashTable。<br/>
用法分别对应 NSMutableArray，NSMutableDictionary，NSMutableSet。</p>

<h3 id="toc_2">- 1. NSPointerArray</h3>

<h4 id="toc_3">特性介绍</h4>

<p>NSPointerArray 是 NSArray 的通用版本，和 NSArray/NSMutableArray 不同的是，NSPointerArray 具有下面这些特性：</p>

<ul>
<li>与 NSArray/NSMutableArray 相对应，NSArray/NSMutableArray 强引用集合对象</li>
<li>NSPointerArray 可以弱引用集合对象，一旦对象没人持有了，NSPointerArray 中对应的项会被变成 NULL</li>
<li>NSPointerArray 是可变的，没有不可变的版本</li>
<li>NSPointerArray 可以存储 NULL，NULL 参与 count 计算</li>
<li>NSPointerArray 的 count 可以被设置，如果直接设置 count，多余的位置会使用 NULL 占位</li>
<li>NSPointerArray 存储的是指针类型 void * 而不是对象，所以需要 __bridge 进行转换</li>
<li>使用 addPointer 和 pointerAtIndex 来存取指针</li>
</ul>

<pre><code class="language-text">- (instancetype)initWithOptions:(NSPointerFunctionsOptions)options;
- (instancetype)initWithPointerFunctions:(NSPointerFunctions *)functions;

</code></pre>

<p>NSPointerFunctionsOptions 枚举定义着内存管理策略、方法特性和内存标识，以下是几个常用的枚举值：<br/>
内存管理策略：<br/>
NSPointerFunctionsStrongMemory：强引用成员<br/>
NSPointerFunctionsMallocMemory：  用于 Mach 的 虚拟内存管理<br/>
NSPointerFunctionsMachVirtualMemory： 用于 Mach 的 虚拟内存管理<br/>
NSPointerFunctionsWeakMemory：弱引用成员</p>

<p>方法特性：<br/>
NSPointerFunctionsObjectPersonality：hash、isEqual、对象描述<br/>
NSPointerFunctionsOpaquePersonality：pointer 的 hash 、直接判等</p>

<p>内存标识：<br/>
NSPointerFunctionsCopyIn 添加成员时进行 copy 操作</p>

<h4 id="toc_4">提供 compact 方法剔除 NULL 元素</h4>

<p>NSPointerArray 可以存储 NULL，作为补充，它也提供了 compact 方法，用于剔除数组中为 NULL 的成员。但是 compact 函数有个已经报备的 bug，每次 compact 之前需要添加一个 NULL，否则会 compact 失败</p>

<h4 id="toc_5">弱引用测试代码</h4>

<pre><code class="language-text">NSPointerArray *pointerArray = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory];
@autoreleasepool{
    NSObject *obj = [NSObject new];
    [pointerArray addPointer:(__bridge void *)obj];
    NSLog(@&quot;NSPointerArray is: %p count: %@&quot;, [pointerArray pointerAtIndex:0], @(pointerArray.count));
    // 输出 NSPointerArray is: 0x60000000e800 count: 1
}
NSLog(@&quot;After Release NSPointerArray is: %p count: %@&quot;, [pointerArray pointerAtIndex:0], @(pointerArray.count));
// 输出 After Release NSPointerArray is: 0x0 count: 1
    
// 每次 compact 之前需要添加 NULL，规避系统 Bug
[pointerArray addPointer:NULL];
    
[pointerArray compact];
    
NSLog(@&quot;After Compact NSPointerArray count: %@&quot;, @(pointerArray.count));
// 输出 After Compact NSPointerArray count: 0
</code></pre>

<h3 id="toc_6">- 2. NSHashTable</h3>

<h4 id="toc_7">特性介绍</h4>

<p>NSHashTable 是 NSSet 的通用版本，和 NSSet / NSMutableSet 不同的是，NSHashTable 具有下面这些特性:</p>

<ul>
<li>与 NSSet/NSMutableSet 相对应，NSSet/NSMutableSet 强引用集合对象</li>
<li>NSHashTable 可以弱引用集合对象，一旦对象没人持有了，NSHashTable 中的值也会被移除</li>
<li>NSHashTable 是可变的，没有不可变的版本</li>
<li>除了存储对象，NSHashTable 也可以存储任意指针，比如 void *</li>
</ul>

<h4 id="toc_8">初始化参数</h4>

<pre><code class="language-text">+ (NSHashTable&lt;ObjectType&gt; *)hashTableWithOptions:(NSPointerFunctionsOptions)options;

</code></pre>

<p>NSHashTableOptions 的取值如下：</p>

<ul>
<li>NSHashTableStrongMemory: 默认值，强引用集合对象，与 NSSet 一样</li>
<li>NSHashTableWeakMemory: 弱引用集合对象</li>
<li>NSHashTableZeroingWeakMemory: 废弃，请使用 NSHashTableWeakMemory</li>
<li>NSHashTableCopyIn: 在将对象添加到集合之前，会拷贝对象</li>
<li>NSHashTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等</li>
</ul>

<h4 id="toc_9">弱引用测试代码</h4>

<pre><code class="language-text">NSHashTable *hashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];
@autoreleasepool {
    NSObject *obj = [NSObject new];
    [hashTable addObject:obj];
    NSLog(@&quot;hashTable is: %@&quot;, hashTable);
    // hashTable is: NSHashTable {[3] &lt;NSObject: 0x6000035e3f60&gt;}
}
    
NSLog(@&quot;hashTable is: %@&quot;, hashTable);
// hashTable is: NSHashTable {}
</code></pre>

<h3 id="toc_10">- 3. NSMapTable</h3>

<h4 id="toc_11">特性介绍</h4>

<p>NSMapTable 是 NSDictionary 的通用版本，和 NSDictionary/NSMutableDictionary 不同的是，NSMapTable 具有下面这些特性:</p>

<ul>
<li>与 NSDictionary/NSMutableDictionary 相对应，NSDictionary/NSMutableDictionary 对 Key 拷贝，对 Value 强引用</li>
<li>key 和 value 的内存管理方式可以分开，如：key 是强引用，value 是弱引用</li>
<li>NSMapTable 可以弱引用 Key 和 Value，一旦 Key 或 Value 中的某一个没人持有了，NSMapTable 中对应的项也会被移除</li>
<li>NSMapTable 是可变的，没有不可变的版本</li>
<li>除了存储对象，NSMapTable 也可以存储任意指针，比如 void *</li>
</ul>

<p>总结起来一共有 4 种可能：</p>

<ul>
<li>key 为 strong，value 为 strong</li>
<li>key 为 strong，value 为 weak</li>
<li>key 为 weak，value 为 strong</li>
<li>key 为 weak，value 为 weak<br/>
当用 weak 修饰 key 或 value 时，有一方被释放，则该键值对移除</li>
</ul>

<h4 id="toc_12">初始化参数</h4>

<p>可以在初始化 NSMapTable 时指定 NSPointerFunctionsOptions 来分别确定对 Key 和 Value 的内存引用</p>

<pre><code class="language-text">+ (NSMapTable&lt;KeyType, ObjectType&gt; *)mapTableWithKeyOptions:(NSPointerFunctionsOptions)keyOptions valueOptions:(NSPointerFunctionsOptions)valueOptions;

</code></pre>

<ul>
<li>NSMapTableStrongMemory: 默认值，强引用 Key/Value</li>
<li>NSMapTableWeakMemory: 弱引用 Key/Value</li>
<li>NSHashTableZeroingWeakMemory: 废弃，请使用 NSMapTableWeakMemory</li>
<li>NSMapTableCopyIn: 在将对象添加到集合之前，会拷贝对象</li>
<li>NSMapTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等</li>
</ul>

<h4 id="toc_13">弱引用测试代码</h4>

<pre><code class="language-text">NSMapTable *mapTable = [NSMapTable weakToStrongObjectsMapTable];
@autoreleasepool {
    NSObject *key = [NSObject new];
    NSObject *value = [NSObject new];
    [mapTable setObject:value forKey:key];
    NSLog(@&quot;mapTable is: %@&quot;, mapTable);
    // mapTable is: NSMapTable {&lt;NSObject: 0x6000008df890&gt; -&gt; &lt;NSObject: 0x6000008df870&gt;}
}
    
NSLog(@&quot;mapTable is: %@&quot;, mapTable);
// mapTable is: NSMapTable {}
// key 是 weak 引用，所以析构之后 NSMapTable 就会移除对应的项
</code></pre>

<h2 id="toc_14">参照</h2>

<p>参考： <a href="https://norcy.github.io/wiki/iOS/%E5%BC%B1%E5%BC%95%E7%94%A8%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1/">弱引用集合对象</a></p>

<ul>
<li>
<a href="#toc_0">一. 使用 NSValue</a>
</li>
<li>
<a href="#toc_1">二.  使用 NSPointerArray，NSMapTable，NSHashTable</a>
<ul>
<li>
<a href="#toc_2">- 1. NSPointerArray</a>
<ul>
<li>
<a href="#toc_3">特性介绍</a>
</li>
<li>
<a href="#toc_4">提供 compact 方法剔除 NULL 元素</a>
</li>
<li>
<a href="#toc_5">弱引用测试代码</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">- 2. NSHashTable</a>
<ul>
<li>
<a href="#toc_7">特性介绍</a>
</li>
<li>
<a href="#toc_8">初始化参数</a>
</li>
<li>
<a href="#toc_9">弱引用测试代码</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">- 3. NSMapTable</a>
<ul>
<li>
<a href="#toc_11">特性介绍</a>
</li>
<li>
<a href="#toc_12">初始化参数</a>
</li>
<li>
<a href="#toc_13">弱引用测试代码</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_14">参照</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/4/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15514205211153.html">
                
                  <h1>曝光铁三角 - 光圈、快门、ISO</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p><img src="media/15514205211153/15514214382368.jpg" alt=""/><br/>
“曝光量一定”，在最终成像的照片的亮度不变的前提下进行曝光铁三角的讨论。</p>

<h3 id="toc_0">光圈</h3>

<ul>
<li>像一扇窗，大时进光量多，小时进光量少；</li>
<li>光圈会用「f/xxx」来表示，例如 f/8；</li>
<li>数字小 = 光圈大，例如 f/1.4 是大光圈，f/22是小光圈，不要弄错</li>
</ul>

<p>总结：<br/>
    - 光圈可以控制镜头进光量，同样对景深有着很大的影响。<br/>
    - 光圈越大，景深越浅，背景虚化能力越强，比较适合拍摄静物、人像等题材的照片；<br/>
    - 光圈越小，景深越大，背景虚化能力弱，比较适合拍风光题材的照片。</p>

<h3 id="toc_1">快门</h3>

<ul>
<li>高速快门进入光线少，慢快门进入光线多；</li>
<li>高速快门常会看到 1/xxx 秒，例如 1/250s、1/4000s；</li>
<li>一般相机最快可以设定 1/4000s 或 1/8000s，最慢通常是 30s</li>
<li>超过 30 秒的快门可以用 B / Bulb 快门代替</li>
</ul>

<p>总结：</p>

<ul>
<li>在ISO感光度和光圈大小不变的情况下，快门时间越长，画面就越亮；快门时间越短，画面越暗。</li>
<li>控制快门速度可以表现不同的画面张力，如高速快门可以拍摄高速运行中的物体，比如在田径场上驰骋的运动员，海中翻腾的浪花等；慢速快门可以用来拍摄线条感，如小溪中涓涓的流水，夜幕中过往的车流等</li>
</ul>

<h3 id="toc_2">ISO 感光度</h3>

<ul>
<li>底片/感光器对光的敏感度</li>
<li>ISO 越高，更能于暗的环境下吸收光线，或是光圈小，快门快的情况下吸受光</li>
<li>ISO 越高，讯噪越明显，相片质素越差</li>
<li>ISO 由 50 – 12800 或更高不等，视乎相机</li>
</ul>

<p>总结：</p>

<ul>
<li>在光圈大小和快门时间不变的情况下，ISO感光度越高，画面就越亮；ISO感光度越低，画面越暗。</li>
<li>但ISO感光度高有一个致命的缺点：降低了画质，在画面中会产生颗粒状的噪点。</li>
</ul>

<p><img src="media/15514205211153/15514207563396.jpg" alt=""/></p>

<h3 id="toc_3">示例</h3>

<p>在拍摄时考虑设定「光圈、快门和ISO」的步骤<br/>
假设是「手持拍摄」</p>

<ul>
<li>选定拍摄模式，例如光圈先决 (A/Av-Mode)</li>
<li>观看要拍摄的题材，例如是风景 (Landscape) 相片</li>
<li>因为是在光圈先决模式，我们要自行设定「光圈」和「ISO」</li>
<li>通常最先设定 ISO
<ul>
<li>如果光线充足，使用低 ISO 来保持相片质素，例如 50、100或200</li>
<li>如果环境偏暗，使用适当的高 ISO (一开始可以自行估计)，例如 800、1600、3200 等</li>
</ul></li>
<li>再设定光圈
<ul>
<li>如果光线充足，应倾向使用小一点的光圈，但不要最小，f/8-11 为最佳的光圈值</li>
<li>如果光线偏暗，放大光圈，如 f/2.8-4</li>
<li>如果要拍出浅景深效果(例如拍人像)，放大光圈；否则缩少光圈(例如拍风景)</li>
</ul></li>
<li>检查快门值：如果快门偏慢，甚至低于「安全快门」，应按情况提升ISO，或是放大一点光圈( f/xxx 数字变小)，直至快门提升至安全水平</li>
<li>按下按钮拍摄<br/>
以上便是拍摄时调较「光圈、快门和ISO」的一些简单步骤，当然进阶一点的会再考虑 白平衡、构图、相片气氛 等因素，但对于初学者，掌握以上的思考方法已经为学习摄影打好一大好基础了，因此不妨多思考为甚么要这样设定，而不要靠运气去拍出好相片！</li>
</ul>

<h3 id="toc_4">其他</h3>

<p><strong>景深</strong>：在对焦点附近画面呈现清晰图像的范围。<br/>
<strong>安全快门</strong>：安全快门是手持相机拍摄的安全快门速度，安全快门速度是所选焦距的倒数，即：使用50mm焦距的镜头拍摄时，快门速度不能低于1/50秒，使用300mm的焦距拍摄时，快门速度不能低于1/300，否则拍出来的照片就有可能拍花了。</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/3/1</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%91%84%E5%BD%B1.html'>摄影</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15477997794055.html">
                
                  <h1>UML 类图</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">类之间的关系</h2>

<h3 id="toc_1">1. 泛化关系(generalization)</h3>

<p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：<br/>
泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p>

<p><img src="media/15477997794055/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"/><br/>
注：最终代码中，泛化关系表现为继承非抽象类；</p>

<h3 id="toc_2">2. 实现关系(realize)</h3>

<p>实现关系用一条带空心箭头的虚线表示；<br/>
<img src="media/15477997794055/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-1-.png" alt="未命名文件 -1-"/><br/>
注：最终代码中，实现关系表现为继承抽象类；</p>

<h3 id="toc_3">3. 聚合关系(aggregation)</h3>

<p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p>

<p><img src="media/15477997794055/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-2-.png" alt="未命名文件 -2-"/><br/>
A:员工  B:部门</p>

<ul>
<li>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</li>
<li>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</li>
</ul>

<h3 id="toc_4">4. 组合关系(composition)</h3>

<p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p>

<p><img src="media/15477997794055/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-3-.png" alt="未命名文件 -3-"/></p>

<ul>
<li>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</li>
<li>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</li>
</ul>

<h3 id="toc_5">5. 关联关系(association)</h3>

<p>关联关系是用一条直线表示的；<br/>
<img src="media/15477997794055/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-4-.png" alt="未命名文件 -4-"/></p>

<ul>
<li>它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；</li>
<li>它一般用来定义对象之间静态的、天然的结构； </li>
<li>关联关系是一种“强关联”的关系；比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</li>
<li>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</li>
</ul>

<p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p>

<h3 id="toc_6">6. 依赖关系(dependency)</h3>

<p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；<br/>
<img src="media/15477997794055/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-5-.png" alt="未命名文件 -5-"/></p>

<ul>
<li><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p></li>
<li><p>依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p></li>
</ul>

<p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/1/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UML.html'>UML</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15428530050944.html">
                
                  <h1>iOS 录音</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>录音方案<br/>
<strong>AVFoundation</strong>：提供AVAudioPlayer，AVAudioRecorder类，以及简单的OC接口，录音过程是把音频录制成音频文件，播放过程是播放音频文件，适合处理非实时的场景。<br/>
<strong>Audio Unit</strong>：Audio Unit在音频开发中处于最底层，可以实时获取和播放PCM数据，具有响应快，低延迟的优点，适用于低延迟实时场景。<br/>
<strong>Audio ToolBox</strong>：基于Audio Unit，提供Core Audio中层和高层服务的接口，包括Audio Session Services，AudioQueueService（音频队列）。音频队列是另一种录音方案，将录制的音频放置在队列中，取出播放。<br/>
<strong>OpenAL</strong>：基于Audio Unit，主要提供跨平台的接口。<br/>
可以看到，实时录音方案有两种，本文主要讲述这两种方式的特点。</p>

<h2 id="toc_0">Audio Queue]</h2>

<p><a href="https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/AboutAudioQueues/AboutAudioQueues.html">Audio Queue Services Programming Guide</a></p>

<h2 id="toc_1">Audio Unit</h2>

<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/AudioUnit.html#//apple_ref/doc/uid/TP40014214-CH22-SW1">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/AudioUnit.html#//apple_ref/doc/uid/TP40014214-CH22-SW1</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%9F%B3%E8%A7%86%E9%A2%91.html'>音视频</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15421737791379.html">
                
                  <h1>iOS 编写高质量Objective-C代码</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p><a href="https://www.jianshu.com/p/76ac67f1bd95">https://www.jianshu.com/p/76ac67f1bd95</a></p>

<h3 id="toc_0">为了减少编译时间，.h文件中尽量少引入其他头文件。</h3>

<h3 id="toc_1">多用字面量语法，少用等价方法</h3>

<p>好处：简明易读，提高代码的可读性和可维护性<br/>
局限性：用字面量预防创建数组或字典时，值不能有nil，否则会抛出异常。</p>

<h3 id="toc_2">多用类型常量，少用#define预处理指令</h3>

<pre><code class="language-text">#define ANIMATION_DURATION 0.5

// 替换成
static const NSTimeInterval kAnimationDuration = 0.5;

// 全局常量
// QiShare.h
extern const NSTimeInterval QiShareAnimationDuration;

// QiShare.m
const NSTimeInterval QiShareAnimationDuration = 0.3;

作者：QiShare
链接：https://www.jianshu.com/p/76ac67f1bd95
來源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
</code></pre>

<h3 id="toc_3">多用枚举表示状态、选项、状态码</h3>

<h3 id="toc_4">理解“ 属性 ”这一概念</h3>

<p>在iOS开发中，99.99..%的属性都会声明为nonatomic。<br/>
一是atomic会严重影响性能，<br/>
二是atomic只能保证读/写操作的过程是可靠的，并不能保证线程安全。</p>

<h3 id="toc_5">在对象内部尽量直接访问实例变量</h3>

<h3 id="toc_6">以 “自动释放池块” 降低内存峰值</h3>

<p>默认情况下：自动释放池需要等待线程执行下一次事件循环时才清空，通常for循环会不断创建新对象加入自动释放池里，循环结束才释放。因此，可能会占用大量内存。<br/>
手动加入自动释放池块（@autoreleasepool）：每次for循环都会直接释放内存，从而降低了内存的峰值。</p>

<h3 id="toc_7">多用派发队列，少用同步锁</h3>

<h3 id="toc_8">多用GCD，少用performSelector系列方法</h3>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15403726165605.html">
                
                  <h1>AudioUnit 使用问题记录</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">【问题 1】AudioUnit 55: EXCEPTION (-1): &quot;&quot; 控制刷屏问题</h3>

<p>仅仅需要录音采集的时候设置播放enableIO关闭，增加如下代码</p>

<pre><code class="language-text">UInt32 disable = 0;
AudioUnitSetProperty(_toneUnit,
                             kAudioOutputUnitProperty_EnableIO,
                             kAudioUnitScope_Output,
                             kOutputBus,
                             &amp;enable,
                             sizeof(enable));
                             
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/10/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%9F%B3%E8%A7%86%E9%A2%91.html'>音视频</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15397594715622.html">
                
                  <h1>浅谈iOS中的全局变量和static全局变量</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	定义了一个静态全局变量，如何释放的问题？
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/10/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15396681011495.html">
                
                  <h1>Shell学习笔记录</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	Shell 学习记录笔记
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/10/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Shell.html'>Shell</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15283573748540.html">
                
                  <h1>iOS逆向-砸壳（Clutch & dumpdecrypted）</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>MachO文件 -&gt; 苹果加密 -&gt; 加壳文件</p>

<p>加壳文件 -&gt; 苹果解密 -&gt; MachO文件（DYLD）</p>

<p>解密过程：</p>

<ol>
<li>DRM（数字版权管理）检查</li>
<li>找到合适结构进行解密</li>
<li>使用DYLD加载解密的MachO</li>
</ol>
</blockquote>

<h2 id="toc_0">砸壳工具：</h2>

<p>Clutch 静态砸壳<br/>
dumpdecrypted 动态加壳</p>

<p>静态砸壳：调用系统的解密程序<br/>
动态砸壳：得到系统解密后的MachO文件</p>

<h2 id="toc_1">Clutch 静态砸壳</h2>

<p>前提条件：手机已越狱</p>

<h3 id="toc_2">1. 下载安装Clutch到手机</h3>

<p>github下载 <a href="https://github.com/KJCracks/Clutch/releases">Clutch</a> 并命名为 <code>Clutch</code></p>

<h3 id="toc_3">2. 将该文件拷贝到设备（手机）中</h3>

<pre><code class="language-text">scp ./build/Clutch root@&lt;your.device.ip&gt;:/usr/bin/Clutch
    
若有端口映射
scp -P 2222 ./build/Clutch root@localhost:/usr/bin/Clutch
</code></pre>

<h3 id="toc_4">3. Clutch 增加可执行权限</h3>

<pre><code class="language-text"># chmod +x Clutch
</code></pre>

<h3 id="toc_5">4. 使用</h3>

<pre><code class="language-text">Clutch [OPTIONS]
-b --binary-dump     Only dump binary files from specified bundleID
-d --dump            Dump specified bundleID into .ipa file
-i --print-installed Print installed application
--clean              Clean /var/tmp/clutch directory
--version            Display version and exit
-? --help            Display this help and exit
</code></pre>

<ul>
<li><p><code>$ Clutch i</code>列出可砸壳应用</p>
<pre><code class="language-text">1: 微信 &lt;com.tencent.xin&gt;
2: ....
</code></pre></li>
<li><p>砸壳</p>
<pre><code class="language-text"># Clutch -d [标示或bundleID]
如：<br/>
Clutch -d 1
</code></pre>
<p>成功后可看见砸壳后的文件</p></li>
</ul>

<h2 id="toc_6">dumpdecrypted 动态加壳</h2>

<h3 id="toc_7">1. 下载并执行</h3>

<p>github <a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a> <code>clone and Download</code></p>

<p>当前文件夹下执行<code>make</code></p>

<pre><code class="language-text">$ make
</code></pre>

<p>生成 <code>dumpdecrypted.dylib</code> 和 <code>dumpdecrypted.o</code> 文件</p>

<h3 id="toc_8">2. 将动态库<code>.dylib</code>从本地拷贝到手机上</h3>

<pre><code class="language-text">scp dumpdecrypted.dylib root@&lt;your.device.ip&gt;:~/
    
若有端口映射
scp -P 2222 ./build/Clutch root@localhost:~/
</code></pre>

<h3 id="toc_9">3. 将动态库<code>.dylib</code>依附到要砸壳的app进程中</h3>

<p>利用 <code>DYLD</code> 环境变量 DYLD_INSERT_LIBRARIES=</p>

<pre><code class="language-text"># DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib [进程路径]

如：
DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/.../WeChat.app/WeChat
</code></pre>

<p>注：进程路径可通过 <code>ps -A</code> 查看</p>

<h3 id="toc_10">4. ipa包</h3>

<p>执行之后 当前目录下 <code>ls</code> 得到 <code>WeChat.decrypted</code>可执行文件<br/>
其他文件可在<code>/var/mobile/.../WeChat.app</code>拷贝组合成砸壳后的ipa包</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15271533818539.html">
                
                  <h1>Mac上搭建直播服务器 Nginx+HLS</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>HLS(<a href="https://zh.wikipedia.org/wiki/HTTP_Live_Streaming">HTTP Live Streaming</a>)是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>

<p>Mac 直播服务器 Nginx+rtmp 见上文<a href="https://www.jianshu.com/p/cf74a34af15d">Mac上搭建直播服务器 Nginx+rtmp</a></p>

<p>下面需要对Nginx服务器增加对HLS的支持。在Nginx增加对HLS支持,修改下配置文件nginx.conf</p>

<h2 id="toc_0">找到http--&gt;server,在花括号中增加</h2>

<pre><code class="language-text">server {
        listen       8080;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }


        #HLS配置开始,这个配置为了`客户端`能够以http协议获取HLS的拉流
        location /hls {
            # Serve HLS fragments
            types {
                application/vnd.apple.mpegurl m3u8;
                video/mp2t ts;
            }
            root html;
            add_header Cache-Control no-cache;
        }
        #HLS配置结束


        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }
</code></pre>

<h2 id="toc_1">找到rtmp下的server在花括号中增加</h2>

<pre><code class="language-text">#在http节点下面(也就是文件的尾部)加上rtmp配置：
rtmp {
    server {
        listen 1935;
        application zbcs {
                live on;
                record off;
            }
        #增加对HLS支持开始
        application hls {
            live on;
            hls on;
            hls_path /usr/local/var/www/hls;
            hls_fragment 5s; 
        }
        #增加对HLS支持结束
    }
}
</code></pre>

<ul>
<li>live on; 开启实时</li>
<li>hls on; 开启hls</li>
<li>hls_path; ts文件存放路径</li>
<li>hls_fragment 5s; 每个TS文件包含5秒的视频内容</li>
</ul>

<h2 id="toc_2">保存配置文件，重新加载nginx配置</h2>

<pre><code class="language-text">$ nginx -s reload
</code></pre>

<h2 id="toc_3">通过ffmepg命令进行推流</h2>

<p>ffmpeg推流还是和上一篇的一样，不过，我们需要推到新配置的hls中，room 关键字可以任何替换</p>

<pre><code class="language-text">$ ffmpeg -re -i /Users/caolongjian/Desktop/CCVideo.mp4  -vcodec copy -f flv rtmp://localhost:1935/hls/room
</code></pre>

<p>然后，我们在就可以在这个目录下（这个也是Nginx下html默认配置文件）<code>/usr/local/var/www/hls</code>看到生成一个个ts的文件，还会生成一个”你的m3u8的文件名称.m3u8“的文件</p>

<h2 id="toc_4">测试拉流</h2>

<p>通过上面的配置，我们可以同时通过rtmp和hls两种播放方式来看到推出来的流。注意，如果使用 http 方式，则是监听的 8080 端口，这个是在配置文件里写的</p>

<p>(1) 用rtmp （使用VLC验证播放）</p>

<pre><code class="language-text">rtmp://localhost/hls/movie
</code></pre>

<p>(2) 用hls（播放使用VLC验证播放）</p>

<pre><code class="language-text">http://localhost:8080/hls/room.m3u8
</code></pre>

<p>(3)我们还可以在Safari浏览器里输入上面的地址直接播放<code>http://localhost:8080/hls/room.m3u8</code></p>

<h2 id="toc_5">参考</h2>

<p><a href="http://www.cnblogs.com/jys509/p/5653720.html">Mac直播服务器Nginx配置对HLS的支持</a></p>

<hr/>

<ul>
<li>
<a href="#toc_0">找到http--&gt;server,在花括号中增加</a>
</li>
<li>
<a href="#toc_1">找到rtmp下的server在花括号中增加</a>
</li>
<li>
<a href="#toc_2">保存配置文件，重新加载nginx配置</a>
</li>
<li>
<a href="#toc_3">通过ffmepg命令进行推流</a>
</li>
<li>
<a href="#toc_4">测试拉流</a>
</li>
<li>
<a href="#toc_5">参考</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%9F%B3%E8%A7%86%E9%A2%91.html'>音视频</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15271456510220.html">
                
                  <h1>Mac上搭建直播服务器 Nginx+rtmp</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">简介</h2>

<p><a href="https://zh.wikipedia.org/wiki/Nginx">Nginx</a> 是非常优秀的开源服务器，用它来做hls或者rtmp流媒体服务器是非常不错的选择，</p>

<h2 id="toc_1">1、安装</h2>

<p>增加对 nginx 的扩展;也就是从github上下载,home-brew对ngixn的扩展</p>

<p>执行克隆命令,github的项目(<a href="https://github.com/denji/homebrew-nginx">https://github.com/denji/homebrew-nginx</a>)</p>

<pre><code class="language-text">$ brew tap denji/nginx 
</code></pre>

<p><strong>注意:</strong> <code>brew tap homebrew/nginx</code> 报下面的错误, 使用<code>brew tap denji/nginx</code>替代<br/>
homebrew/nginx was deprecated. This tap is now empty as all its formulae were migrated.</p>

<h2 id="toc_2">2、执行安装命令:</h2>

<pre><code class="language-text">$ brew install nginx-full --with-rtmp-module 
</code></pre>

<h3 id="toc_3">查看 nginx 安装在哪里</h3>

<pre><code class="language-text">$ brew info nginx-full
</code></pre>

<pre><code class="language-text">--HEAD
    Install HEAD version
==&gt; Caveats
Docroot is: /usr/local/var/www

The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that
nginx can run without sudo.

nginx will load all files in /usr/local/etc/nginx/servers/.

- Tips -
Run port 80:
 $ sudo chown root:wheel /usr/local/opt/nginx-full/bin/nginx
 $ sudo chmod u+s /usr/local/opt/nginx-full/bin/nginx
Reload config:
 $ nginx -s reload  ## 重新加载配置文件
Reopen Logfile:
 $ nginx -s reopen  ## 再次打开配置文件
Stop process:
 $ nginx -s stop    ## 停止服务器
Waiting on exit process
 $ nginx -s quit    ## 退出服务器

To have launchd start denji/nginx/nginx-full now and restart at login:
  brew services start denji/nginx/nginx-full
Or, if you don&#39;t want/need a background service you can just run:
  nginx
</code></pre>

<ul>
<li>nginx安装所在位置  <code>/usr/local/opt/nginx-full/bin/nginx</code></li>
<li>nginx配置文件所在位置  <code>/usr/local/etc/nginx/nginx.conf</code></li>
<li>nginx服务器根目录所在位置  <code>/usr/local/var/www</code></li>
</ul>

<h3 id="toc_4">启动nginx服务</h3>

<pre><code class="language-text">$ nginx
</code></pre>

<p>在浏览器地址栏输入：<a href="http://localhost:8080">http://localhost:8080</a><br/>
出现Welcome to nginx ,代表nginx安装成功了。</p>

<h2 id="toc_5">3、配置rtmp</h2>

<p>打开配置文件 <code>/usr/local/etc/nginx/nginx.conf</code></p>

<pre><code class="language-text">http {
    ……
}

#在http节点下面(也就是文件的尾部)加上rtmp配置：
rtmp {
    server {
        listen 1935;
        application abcs {
            live on;
            record off;
        }
    }
}
</code></pre>

<ul>
<li>rtmp 是协议名称</li>
<li>server 说明内部中是服务器相关配置</li>
<li>listen 监听的端口号, rtmp协议的默认端口号是1935</li>
<li>application 访问的应用路径是 abcs</li>
<li>live on; 开启实时</li>
<li>record off; 不记录数据</li>
</ul>

<h2 id="toc_6">4、 保存文件后，重新加载nginx的配置文件</h2>

<pre><code class="language-text">$ nginx -s reload
</code></pre>

<h2 id="toc_7">5、安装ffmepg工具</h2>

<pre><code class="language-text">$ brew install ffmpeg
</code></pre>

<p>安装这个需要等一段时间, 这时你可以准备一个视频文件作为来推流，然后安装一个支持rtmp协议的视频播放器.Mac下可以用 VLC</p>

<h2 id="toc_8">6、通过ffmepg命令进行推流</h2>

<pre><code class="language-text">ffmpeg -re -i [你的视频文件的绝对路径] -vcodec copy -f flv rtmp://localhost:1935/abcs/room

// 如：ffmpeg -re -i /Users/caolongjian/Desktop/CCVideo.mp4  -vcodec copy -f flv rtmp://localhost:1935/abcs/room
</code></pre>

<p>这里abcs是上面的配置文件中,配置的应用的路径名称;后面的room可以随便写。</p>

<h2 id="toc_9">7、 验证视频</h2>

<p>然后电脑上打开vlc这个播放器软件 点击File----&gt;Open Network 在弹出来的框中选择Network然后输入URL:</p>

<pre><code class="language-text">rtmp://localhost:1935/abcs/room
</code></pre>

<h2 id="toc_10">参考</h2>

<p><a href="http://www.cnblogs.com/jys509/p/5649066.html">Mac上搭建直播服务器Nginx+rtmp</a><br/>
<a href="https://blog.csdn.net/zcvbnh/article/details/79495285">mac搭建naginx+rtmp服务器-带你出坑</a></p>

<hr/>

<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">1、安装</a>
</li>
<li>
<a href="#toc_2">2、执行安装命令:</a>
<ul>
<li>
<a href="#toc_3">查看 nginx 安装在哪里</a>
</li>
<li>
<a href="#toc_4">启动nginx服务</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">3、配置rtmp</a>
</li>
<li>
<a href="#toc_6">4、 保存文件后，重新加载nginx的配置文件</a>
</li>
<li>
<a href="#toc_7">5、安装ffmepg工具</a>
</li>
<li>
<a href="#toc_8">6、通过ffmepg命令进行推流</a>
</li>
<li>
<a href="#toc_9">7、 验证视频</a>
</li>
<li>
<a href="#toc_10">参考</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%9F%B3%E8%A7%86%E9%A2%91.html'>音视频</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15264613640203.html">
                
                  <h1>Logos语法</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p><a href="http://iphonedevwiki.net/index.php/Logos">logos</a> 语法主要是对<a href="http://iphonedevwiki.net/index.php/Cydia_Substrate">Cydia Substrate</a>的MSHookMessageEx函数作了一层封装。</p>

<p><strong>1.%hook</strong> <br/>
指定需要hook的class,必须以％end结尾。</p>

<p><strong>2.％log</strong> <br/>
该指令在%hook内部使用，将函数的类名、参数等信息写入syslog,可以％log([(),…..])的格式追加其他打印信息。</p>

<p><strong>3.％orig</strong> <br/>
该指令在%hook内部使用，执行被hook的函数的原始代码；也可以用％orig更改原始函数的参数。</p>

<p><strong>4.%group</strong> <br/>
该指令用于将%hook分组，便于代码管理及按条件初始化分组，必须以%end结尾。 <br/>
一个％group可以包含多个%hook,所有不属于某个自定义group的％hook会被隐式归类到％group_ungrouped中。</p>

<p><strong>5.%init</strong> <br/>
该指令用于初始化某个％group，必须在%hook或％ctor内调用；如果带参数，则初始化指定的group，如果不带参数，则初始化_ungrouped. <br/>
注： <br/>
切记，只有调用了％ini,对应的%group才能起作用！</p>

<p><strong>6.%ctor</strong> <br/>
tweak的constructor,完成初始化工作；如果不显示定义，Theos会自动生成一个%ctor,并在其中调用%init(_ungrouped)。</p>

<p><strong>7.%new</strong> <br/>
在%hook内部使用，给一个现有class添加新函数，功能与class_addMethod相同。 <br/>
注： <br/>
Objective-C的category与class_addMethod的区别： <br/>
前者是静态的而后者是动态的。</p>

<p><strong>8.%c</strong> <br/>
该指令的作用等同于objc_getClass或NSClassFromString,即动态获取一个类的定义，在%hook或％ctor内使用。</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15264578086555.html">
                
                  <h1>RunLoop</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>Runloop 是和线程紧密相关的一个基础组件，是很多线程有关功能的幕后功臣。尽管在平常使用中几乎不太会直接用到，理解 Runloop 有利于我们更加深入地理解 iOS 的多线程模型。</p>

<p><strong>目的</strong>：保住当前线程的生命,监听事件：触摸、时钟、网络等</p>

<h2 id="toc_0">RunLoop基本概念</h2>

<p>RunLoop是什么？顾名思义，说白了就是一种循环，只不过它这种循环比较高级。一般的while循环会导致CPU进入忙等待状态，而Runloop则是一种“闲”等待，这部分可以类比Linux下的epoll。当没事件时，Runloop会进入休眠状态，有事件发生时，Runloop会去找对应的Handler处理事件。Runloop可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠。<br/>
<img src="media/15264578086555/15264592711244.png" alt=""/></p>

<p>图中展示了Runloop在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。</p>

<h2 id="toc_1">Runloop 与线程</h2>

<p>Runloop 和线程是绑定在一起的。每个线程（包括主线程）都有一个对应的Runloop对象。我们并不能自己创建Runloop对象，但是可以获取到系统提供的Runloop对象。<br/>
主线程的 Runloop 会在应用启动的时候完成启动，其他线程的 Runloop 默认并不会启动，需要我们手动启动。</p>

<h2 id="toc_2">Input Source 和 Timer Source</h2>

<p>这两个都是 Runloop 时间的来源，其中<strong>Input Source</strong> 又可以分为三类</p>

<ul>
<li>Port-Base Source，系统底层的Port时间，例如CFSocketRef，在应用层基本用不到</li>
<li>Custom Input Source，用户手动创建的Source</li>
<li>Cocoa Perform Selector Source，Cacoa提供的的performSelector系列方法，也是一种事件源</li>
</ul>

<p>按照函数调用栈,Source可分为 <code>Source0</code> 和 <code>Source1</code>。其中 <code>Source1</code> 为系统内核事件, <code>Source0</code>即非<code>Source1</code></p>

<p>例如：创建事件源</p>

<pre><code class="language-text">    //队列
    dispatch_queue_t queue = dispatch_get_global_queue(0,0);
    //创建一个定时器!!
    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    //设置定时器
    dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 1000000000, 0);
    dispatch_source_set_event_handler(self.timer, ^{
        NSLog(@&quot;-------%@&quot;,[NSThread currentThread]);
    });
    //启动定时器
    dispatch_resume(self.timer);
</code></pre>

<p><strong>Timer Source</strong> 顾名思义就是指定时器事件了。例如：<code>NStimer</code> 创建定时器</p>

<h2 id="toc_3">Runloop Observer</h2>

<p>Runloop 通过监控Source来决定有没有任务要做，除此之外，我们还可以用Runloop Observer 可以监控下面的 runloop 事件：</p>

<ul>
<li>The entrance to the run loop.</li>
<li>When the run loop is about to process a timer.</li>
<li>When the run loop is about to process an input source.</li>
<li>When the run loop is about to go to sleep.</li>
<li>When the run loop has woken up, but before it has processed the event that woke it up.</li>
<li>The exit from the run loop.</li>
</ul>

<p>通过Runloop Observer 可以实现卡顿优化，如：TableView滑动中加载多张大图<br/>
<strong>思路</strong>：每次Runloop循环,只渲染一张大图<br/>
<strong>步骤</strong>:<br/>
 1.监听Runloop的循环<br/>
 2.将加载大图的代码!放在一个数组里面<br/>
 3.每次Runloop循环,取出一个加载大图的任务执行</p>

<pre><code class="language-text"> #pragma mark - &lt;CFRunloop&gt;

- (void)addTasks:(runloopBlock)task{
    [self.tasks addObject:task];
    if (self.tasks.count &gt; 18) {
        [self.tasks removeObjectAtIndex:0];
    }
}

- (void)addRunloopObserver{
    //获取Runloop
     CFRunLoopRef runloop = CFRunLoopGetCurrent();
    //定义一个context
    CFRunLoopObserverContext context = {
        0,
        (__bridge void *)(self),
        &amp;CFRetain,
        &amp;CFRelease,
        NULL
    };
    
    //定义观察者
    static CFRunLoopObserverRef runloopObserver;
    runloopObserver = CFRunLoopObserverCreate(NULL, kCFRunLoopBeforeWaiting, YES, 0, &amp;callBack, &amp;context);
    
    //添加观察者
    CFRunLoopAddObserver(runloop, runloopObserver, kCFRunLoopCommonModes);
    
    //C里面 一旦creat new copy
    CFRelease(runloopObserver);
}

void callBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){
    ViewController * vc = (__bridge ViewController *)info;
    if(vc.tasks.count == 0){
        return;
    }
    runloopBlock block = vc.tasks.firstObject;
    block();
    [vc.tasks removeObjectAtIndex:0];
}
</code></pre>

<h2 id="toc_4">Runloop Mode</h2>

<p>在监视与被监视中， Runloop 要处理的事情还挺复杂的。为了让Runloop 能专心处理自己关心的那部分事情，引入了Runloop Mode 概念。<br/>
<img src="media/15264578086555/15264592902617.png" alt=""/></p>

<p>如图所示， Runloop Model 实际上是Source、Timer 和 Observer 的集合，不同的Model 把不同组的 Source、 Timer 和 Observer 隔绝开来。Runloop 在某个时刻只能跑在一个 Mode 下，处理这一个 Model 种种的 Source，Timer 和 Observer。<br/>
苹果文档中提到的 Mode 有五个，分别是：</p>

<ul>
<li>NSDefaultRunLoopMode</li>
<li>NSConnectionReplyModel</li>
<li>NSModalPanelRunLoopMode</li>
<li>NSEventTrackingRunLoopMode</li>
<li>NSRunLoopCommonModes</li>
</ul>

<p>iOS中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonMode.NSRunLoopCommonMode实际上是一个Mode的集合，默认包括 NSDefaultRunLoopMode  和 NSEventTrackingRunLoopMode</p>

<h2 id="toc_5">与 RunLoop 相关的坑</h2>

<p>日常开发中，与 runloop 接触最近的可能就是NSTimerle。一个 Timer一次只能加入到一个 RunLoop中。我们日常使用的时候，通常就是加入到当前的runLoop的default model中，而ScrollView 在用户滑动的时候，主线程RunLoop会转到NSTrackingRunLoopMode。er这个时候，Timer就不会运行。<br/>
有如下两种解决方案：</p>

<ul>
<li>第一种：设置RunLoop Mode，例如NSTimer，我们指定它<br/>
运行于NSRunLoopCommonModes，这是一个Mode的集<br/>
合。注册到这个Mode下后，无论当前runLoop运行哪个<br/>
mode，时间都能得到执行。</li>
<li>第二种：另一种解决Timer的方法是，我们在另一个线程执行和处理Timer事件，然后在主线程更新UI。</li>
</ul>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15264570316513.html">
                
                  <h1>Runtime</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">一、基本概念</h2>

<ol>
<li>RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。</li>
<li>OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。</li>
<li>只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</li>
</ol>

<h2 id="toc_1">二、Runtime - 消息机制</h2>

<pre><code class="language-text">#import &lt;objc/message.h&gt;
</code></pre>

<p>底层函数调用都是通过消息发送的 <code>objc_msgSend</code></p>

<p>例如：</p>

<pre><code class="language-text">Person * p = [[Person alloc] init];

Person * p = objc_msgSend([Person class], @selector(alloc));
Person * p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));

p = [p init];
p = objc_msgSend(p, sel_registerName(&quot;init&quot;));

[p eatWith:@&quot;food&quot;];
objc_msgSend(p, sel_registerName(&quot;eatWith:&quot;),@&quot;food&quot;);

</code></pre>

<p>验证：clang 编辑器,生成 main.cpp 文件</p>

<pre><code class="language-text">$ clang -rewrite-objc main.m
</code></pre>

<h2 id="toc_2">三、Runtime - 运行时机制</h2>

<pre><code class="language-text">&lt;Objc/runtime.h&gt;
</code></pre>

<p>苹果提供的一套C语言的API，可以再OC编译运行的阶段，动态的改变操作</p>

<p><strong>SEL</strong> 方法编号<br/>
<strong>IMP</strong> 方法实现（本质是函数指针）<br/>
在OC中我们调用方法都是通过消息机制，给某个对象发送编号消息，通过SEL 可以找到对应的IMP<br/>
SEL 和 IMP是一一对应的关系</p>

<p>编程思想：<strong>面向切面编程（AOP）</strong> 核心的技术就是用到了HOOK（钩子）思想<br/>
改变原来的方法调用顺序</p>

<h2 id="toc_3">三、常见的作用</h2>

<ol>
<li>动态的添加对象的成员变量和方法</li>
<li>动态交换两个方法的实现（Method Swizzling）</li>
<li>实现分类也可以添加属性</li>
<li>实现NSCoding的自动归档和解档</li>
<li>实现字典转模型的自动转换</li>
</ol>

<hr/>

<h2 id="toc_4">runtime 相关定义</h2>

<pre><code class="language-text">/// 描述类中的一个方法
typedef struct objc_method *Method;

/// 实例变量
typedef struct objc_ivar *Ivar;

/// 类别Category
typedef struct objc_category *Category;

/// 类中声明的属性
typedef struct objc_property *objc_property_t;


//类在runtime中的表示
struct objc_class {
    Class isa;//指针，顾名思义，表示是一个什么，
    //实例的isa指向类对象，类对象的isa指向元类

#if !__OBJC2__
    Class super_class;  //指向父类
    const char *name;  //类名
    long version;
    long info;
    long instance_size
    struct objc_ivar_list *ivars //成员变量列表
    struct objc_method_list **methodLists; //方法列表
    struct objc_cache *cache;//缓存
    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存
    struct objc_protocol_list *protocols //协议列表
    #endif
} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */

</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15263723434422.html">
                
                  <h1>OpenGL - 渲染过程</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">一、基本图形硬件流水线设计</h2>

<p><img src="media/15263723434422/15263724067540.jpg" alt=""/><br/>
<mark>应⽤用程序层 -&gt; 硬件抽象层 -&gt; 硬件层</mark></p>

<p><strong>应⽤层</strong>: 游戏和应⽤用层软件开发⼈人员为主体，通过调⽤用API进行上层开发，不需要考虑移植性问题。 <br/>
<strong>硬件抽象层</strong>: 抽象出硬件的加速功能，进行有利于应用层开发的封装，并向应⽤层开发API <br/>
<strong>硬件层</strong>: 将硬件驱动提供给抽象层，以实现抽象层加速功能的有效性。</p>

<h2 id="toc_1">二、渲染流水线的具体流程</h2>

<h3 id="toc_2">1、应⽤层</h3>

<p>应⽤程序层主要与内存，CPU打交道，诸如碰撞检测，场景图监理，视锥裁剪等经典算法在此阶段执行。在阶段的末端，几何体的数据(顶点坐标，法向量，纹理坐标，纹理)等通过数据总线传送到图形硬件</p>

<h3 id="toc_3">2、硬件抽象层</h3>

<p>在这⼀层，我们目前使用的是DirectX与OpenGL。对于这⼀部分，主要是⼀些API等的调⽤</p>

<h3 id="toc_4">3、硬件层</h3>

<p>硬件层在渲染流水线中最为复杂，也最为重要。可编程渲染流水线与固定渲染流水线的区别在于是否对着色器进⾏编程。<br/>
  ⾸先我们先了解固定渲染流水线它主要分为以下几个阶段:<br/>
  顶点变换 -&gt; 图元转配与光栅化 -&gt; ⽚段纹理映射和着色 -&gt; 光栅化操作</p>

<h2 id="toc_5">三、硬件层—固定渲染管线流程图</h2>

<p><img src="media/15263723434422/15263732132633.jpg" alt=""/></p>

<p><strong>光栅化(Rasterization)</strong>:将顶点数据转换为片元的过程! 将具体的图转化为一个个栅格组成的图像的作⽤<br/>
⽚元中每个一个元素对于帧缓存区的一个像素; 光栅化其实是一个将几何图元变成一个二维图像的过程!!<br/>
光栅化的过程就是为了产出⽚元</p>

<h2 id="toc_6">四、硬件层—可编程渲染流水线流程图</h2>

<p><img src="media/15263723434422/15263733597135.jpg" alt=""/></p>

<h2 id="toc_7">五、GPU 图形渲染管线</h2>

<p><img src="media/15263723434422/15263734882629.jpg" alt=""/></p>

<p><strong>应用程序阶段</strong><br/>
主要是⾼级编程语言开发,C,OC,C++ <br/>
输出:通过数据总线,把几何体的数据(顶点坐标\法线\纹理理坐标\纹理理)等传送到GPU上</p>

<p><strong>⼏何阶段</strong><br/>
输入:应⽤程序末端的内容 <br/>
负责任务:顶点坐标变换,光照,裁剪,投影,屏幕映射 <br/>
输出:经过变换和投影之后的屏幕坐标,颜⾊,纹理坐标</p>

<p><strong>光栅化阶段</strong><br/>
见上</p>

<h3 id="toc_8">光栅化操作</h3>

<p>这⼀步我们将会对其进行各种测试，⽽假如它通过了所有的测试，⽚段将会显示在屏幕上<br/>
<img src="media/15263723434422/15263750349578.jpg" alt=""/></p>

<p><strong>抖动显示</strong>:一种能够使用较少的颜色种类模拟较多颜色的显示模式</p>

<h3 id="toc_9">⼏何处理阶段</h3>

<p>几何阶段主要负责大部分多边形操作和顶点操作，包括顶点着色、坐标变换、生成图元、投影、<br/>
 裁剪、屏幕映射等过程，其中顶点着色、坐标变换由顶点着色器完成</p>

<ol>
<li><strong>顶点着⾊器</strong> </li>
<li><strong>⽣成图元</strong>： 顶点数组或索引数组经由顶点着色程序生成三角形的组合</li>
<li><strong>投影</strong>： 透视投影，平行投影</li>
<li><strong>裁切</strong>： 仅保留视景体内部的图元进行渲染</li>
<li><strong>屏幕映射</strong>： 这个阶段是不可配置也不可编程的。主要用来实现图元的坐标转换到屏幕坐标</li>
</ol>

<h2 id="toc_10">六、其他</h2>

<h3 id="toc_11">Shader</h3>

<p><strong>Shader</strong>，中⽂名，着色器。着⾊器其实就是一段在GPU运行的程序。我们平时的程序，是在CPU运行。由于GPU的硬件设计结构与CPU有着很大的不同，所以GPU需要一些新的编程语言</p>

<p>渲染流水线分为两种，其中一种为<strong>可编程渲染流水线</strong>。另外一种为<strong>固定渲染流水线</strong>。(也称可编程管线或固定管线，管线就是流⽔线的意思)。渲染流⽔线可否编程，取决于程序猿能否在顶点着色器以及⽚段着色器上进⾏行编码。⽽现在的渲染流水线，基本都是可编程的，当然，它们也支持固定渲染流水线的功能</p>

<h3 id="toc_12">CPU 与 GPU 之间的关系</h3>

<p>GPU具有⾼并行的结构，所以在处理图形数据和复杂算法比CPU更加有效率</p>

<p><img src="media/15263723434422/15263738384864.jpg" alt=""/></p>

<p>CPU在执行任务的时候，⼀个时刻只会处理⼀个数据，不存在真正意义上的并行，⽽GPU则有多个处理器核，在⼀个时刻可以并行处理多个数据</p>

<h3 id="toc_13">三维坐标转变为二维屏幕坐标的过程</h3>

<p><img src="media/15263723434422/15263754091644.jpg" alt=""/></p>

<p>MC是建模坐标系，WC是世界坐标系，VC是观察坐标系，PC是投影坐标系，NPC是规格化投影坐标系，DC是设备坐标系</p>

<h3 id="toc_14">坐标系详细概念</h3>

<ul>
<li><strong>世界坐标系</strong> 坐标系统主要⽤于计算机图形场景中的所有图形对象的空间定位和定义</li>
<li><strong>局部坐标系</strong> 独立于世界坐标系来定义物体几何特性</li>
<li><strong>观察坐标系</strong> 观察坐标系通常是以视点的位置为原点，通过⽤户指定的一个向上的观察向量来定义整个坐标系统，观察坐标系主要⽤于从观察者的角度对整个世界坐标系内的对象进行重新定位和描述，从而简化⼏何物体在投影面的成像的数学推导和计算</li>
<li><strong>投影坐标系</strong> 物体从世界坐标描述转换到观察坐标后，可将三维物体投影到二维表面上，即投影到虚拟摄像机的胶片上，这个过程就是投影变换。以胶片中心为参考原点的空间坐标系称为投影坐标系，物体在投影坐标系中的坐标称为投影坐标。</li>
<li><strong>设备坐标系</strong> 是图形设备上采用的与具体设备相关的坐标系。设备坐标系一般采⽤用整数坐标，其坐标范围由具体设备的分辨率决定。设备坐标系上的⼀个点一般对应图形设备上的一个像素。由于具体设备的限制，设备坐标系的坐标范围一般是有限的。</li>
<li><strong>规格化设备坐标系</strong> 是为了避免设备相关性而定义的一种虚拟的设备坐标系。规格化坐标系的坐标范围一般从0到1，也有的是从-1到+1。采用规格化设备坐标系的好处是屏蔽了具体设备的分辨率，使得图形处理理能够尽量避开对具体设备坐标的考虑。实际图形处理时，先将世界坐标转换成对应的规格化设备坐标，然后再将规格化设备坐标映射到具体的设备坐标上去。</li>
<li><strong>屏幕坐标系统</strong> 也称设备坐标系统，它主要⽤于某⼀特殊的计算机图形显示设备(如光栅显示器)的表⾯的点的定义，在多数情况下，对于每一个具体的显示设备，都有一个单独的坐标系统，在定义了成像窗口的情况下，可进一步在屏幕坐标系统中定义称为视图区(view port)的有界区域，视图区中的成像即为实际所观察到的。</li>
</ul>

<h2 id="toc_15">参照</h2>

<p>简书 MissCC： <a href="https://www.jianshu.com/u/1b4c832fb2ca">简书 MissCC</a></p>

<ul>
<li>
<a href="#toc_0">一、基本图形硬件流水线设计</a>
</li>
<li>
<a href="#toc_1">二、渲染流水线的具体流程</a>
<ul>
<li>
<a href="#toc_2">1、应⽤层</a>
</li>
<li>
<a href="#toc_3">2、硬件抽象层</a>
</li>
<li>
<a href="#toc_4">3、硬件层</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">三、硬件层—固定渲染管线流程图</a>
</li>
<li>
<a href="#toc_6">四、硬件层—可编程渲染流水线流程图</a>
</li>
<li>
<a href="#toc_7">五、GPU 图形渲染管线</a>
<ul>
<li>
<a href="#toc_8">光栅化操作</a>
</li>
<li>
<a href="#toc_9">⼏何处理阶段</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">六、其他</a>
<ul>
<li>
<a href="#toc_11">Shader</a>
</li>
<li>
<a href="#toc_12">CPU 与 GPU 之间的关系</a>
</li>
<li>
<a href="#toc_13">三维坐标转变为二维屏幕坐标的过程</a>
</li>
<li>
<a href="#toc_14">坐标系详细概念</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">参照</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15263715509093.html">
                
                  <h1>Open GL - GLSL着色器语言</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>GLSL(OpenGL Shading Language) 是一个以C语言为基础的高阶着色语言</p>

<h2 id="toc_0">作用</h2>

<p>可用于 OpenGL 可编程管线<br/>
能够让你对OpenGL渲染其中的一些着色环节来自定义（如顶点着色器，片元着色器）<br/>
类似UIVIewController的自定义控件</p>

<p>固定管线<br/>
相当于已经封装了的高级API，让你通过传递参数来实现效果</p>

<h2 id="toc_1">自定义环节</h2>

<ul>
<li>顶点着色器： 处理每个顶点，确定位置以及变换</li>
<li>片元着色器： 片元</li>
</ul>

<h2 id="toc_2">GLSL 数据类型</h2>

<ul>
<li>void – 用于没有返回值的函式</li>
<li>bool – 条件类型，其值可以是真或假</li>
<li>int – 带负号整数</li>
<li>float – 浮点数</li>
<li>vec2 – 2 个浮点数组成的向量</li>
<li>vec3 – 3 个浮点数组成的向量</li>
<li>vec4 – 4 个浮点数组成的向量</li>
<li>bvec2 – 2 个布尔组成的向量</li>
<li>bvec3 – 3 个布尔组成的向量</li>
<li>bvec4 – 4 个布尔组成的向量</li>
<li>ivec2 – 2 个整数组成的向量</li>
<li>ivec3 – 3 个整数组成的向量</li>
<li>ivec4 – 4 个整数组成的向量</li>
<li>mat2 – 浮点数的 2X2 矩阵</li>
<li>mat3 – 浮点数的 3X3 矩阵</li>
<li>mat4 – 浮点数的 4X4 矩阵</li>
<li>sampler1D – 用来存取一维纹理的句柄（handle）（或：操作，作名词解。）</li>
<li>sampler2D – 用来存取二维纹理的句柄</li>
<li>sampler3D – 用来存取三维纹理的句柄</li>
<li>samplerCube – 用来存取立方映射纹理的句柄</li>
<li>sampler1Dshadow – 用来存取一维深度纹理的句柄</li>
<li>sampler2Dshadow – 用来存取二维深度纹理的句柄</li>
</ul>

<h2 id="toc_3">存储修饰符</h2>

<p><strong>1. 常量修饰符 const</strong></p>

<pre><code class="language-text">1. 任何使用const声明的变量在其所属的着色器中均是只读的。
2. const 用来修饰任何基本数据类型
3. const 不能用来修饰包含数组的数组、结构体
</code></pre>

<p><strong>2. Attribute</strong></p>

<pre><code class="language-text">1. 用于修饰声明通过OpenGL ES 应用程序传递顶点着色器的变量值，在其他任何非顶点着⾊器的着色器程序中声明attribute变量是错误的
</code></pre>

<p><strong>3. Uniform</strong></p>

<pre><code class="language-text">1. ⽤来修饰那些被整个图元在被处理过程中保持不变的全局变量
2. 所有uniform变量都是只读的
3. uniform修饰符可以和任意基本数据类型一起使用，或者包含基本数据类型元素的数组和结构体
</code></pre>

<p><strong>4. Varying</strong></p>

<pre><code class="language-text">1. varying变量提供了顶点着⾊器，⽚元着色器和二者通讯控制模块之间的接口
2. 顶点着⾊器计算每个顶点的值(颜⾊，纹理坐标等)并将它们写到 varying 变量中。顶点着⾊器也会从 varying 变量中读值，获取和它写入相同的值
3. ⽚元着⾊器会读取varying变量的值，并且被读取的值将会作为插值器，作为图元中片元位置的一个功能信息。varying 变量对于⽚元着⾊器来说是只读的。
</code></pre>

<h2 id="toc_4">精度修饰符</h2>

<p><strong>highp</strong>：  浮点数的范围 (-2<sup>62</sup> - 2<sup>62)</sup> ，整型范围 (-2<sup>16</sup> - 2<sup>16)</sup><br/>
<strong>mediump</strong>：浮点数的范围 (-2<sup>14</sup> - 2<sup>14)，</sup> 整型范围 (-2<sup>10</sup> - 2<sup>10)</sup><br/>
<strong>lowp</strong>：   浮点数的范围 (-2,2)，         整型范围(-2<sup>8</sup> - 2<sup>8)</sup></p>

<h2 id="toc_5">官方的shader范例:</h2>

<h3 id="toc_6">Vertex Shader:</h3>

<pre><code class="language-text">uniform mat4 mvp_matrix; //透视矩阵 * 视图矩阵 * 模型变换矩阵
uniform mat3 normal_matrix; //法线变换矩阵(用于物体变换后法线跟着变换)
uniform vec3 ec_light_dir; //光照方向
attribute vec4 a_vertex; // 顶点坐标
attribute vec3 a_normal; //顶点法线
attribute vec2 a_texcoord; //纹理坐标
varying float v_diffuse; //法线与入射光的夹角
varying vec2 v_texcoord; //2d纹理坐标
void main(void)
{
 //归一化法线
 vec3 ec_normal = normalize(normal_matrix * a_normal);
 //v_diffuse 是法线与光照的夹角.根据向量点乘法则,当两向量长度为1是 乘积即cosθ值
 v_diffuse = max(dot(ec_light_dir, ec_normal), 0.0);
 v_texcoord = a_texcoord;
 gl_Position = mvp_matrix * a_vertex;
}
</code></pre>

<h3 id="toc_7">Fragment Shader:</h3>

<pre><code class="language-text">precision mediump float;
uniform sampler2D t_reflectance;
uniform vec4 i_ambient;
varying float v_diffuse;
varying vec2 v_texcoord;
void main (void)
{
 vec4 color = texture2D(t_reflectance, v_texcoord);
 //这里分解开来是 color*vec3(1,1,1)*v_diffuse + color*i_ambient
 //色*光*夹角cos + 色*环境光
 gl_FragColor = color*(vec4(v_diffuse) + i_ambient);
}
</code></pre>

<h2 id="toc_8">目录</h2>

<ul>
<li>
<a href="#toc_0">作用</a>
</li>
<li>
<a href="#toc_1">自定义环节</a>
</li>
<li>
<a href="#toc_2">GLSL 数据类型</a>
</li>
<li>
<a href="#toc_3">存储修饰符</a>
</li>
<li>
<a href="#toc_4">精度修饰符</a>
</li>
<li>
<a href="#toc_5">官方的shader范例:</a>
<ul>
<li>
<a href="#toc_6">Vertex Shader:</a>
</li>
<li>
<a href="#toc_7">Fragment Shader:</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">目录</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15263712692654.html">
                
                  <h1>OpenGL 常见概念性理解整理</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">什么叫光栅化（Rasterize/rasteriztion）？</h3>

<p>栅格化或者像素化，就是把矢量图形转化成像素点儿的过程</p>

<p>我们屏幕上显示的画面都是由像素组成，而三维物体都是点线面构成的。要让点线面，变成能在屏幕上显示的像素，就需要Rasterize这个过程。就是从矢量的点线面的描述，变成像素的描述</p>

<h3 id="toc_1">图元是什么？</h3>

<p>图元可以理解为组成图形的基本单元<br/>
 比如点、线、三角形。 我们可以通过一系列函数或顶点数据帮助我们实现多种多样的图形。</p>

<h3 id="toc_2">什么叫管线？</h3>

<p>管线(pipeline),可以理解为渲染流水线。<strong>管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程</strong>。<br/>
图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>

<h3 id="toc_3">什么叫固定管线？</h3>

<p>可以简单理解为渲染图像的这个过程，我们只能通过调用GLShaderManager类的固定管线效果实现我们一系列的着色器处理。</p>

<h3 id="toc_4">什么可编程管线？</h3>

<p>可以简单理解， 在我们处理图形的过程，我们必须使用顶点着色器和片元着色过程。我们可以才有GLSL自行编写着色器程序，来执行这个过程的事情。</p>

<h3 id="toc_5">顶点着色器调⽤次数与⽚元着⾊器调⽤次数与什么有关?谁⽐较多?</h3>

<p>片元着⾊色器次数比较多!<br/>
顶点着色器调⽤次数与顶点数量相关，<br/>
⽚元着色器调用与像素多少相关</p>

<h3 id="toc_6">为什么需要对三维空间的顶点进行坐标空间转换?</h3>

<p>输⼊到计算机当中一系列三维坐标的点,但是我们看到的屏<br/>
幕是二维坐标点.所以需要转换<br/>
ObjectSpace(物体空间/模型空间)-&gt; WorldSpace(世界空<br/>
间)-&gt;EyeSpace(观察空间)-&gt;ClicpAndProjectSpace(屏幕<br/>
空间)</p>

<h3 id="toc_7">在OpenGL 中有5种坐标系。</h3>

<p>1.局部坐标系(物体空间)<br/>
2.世界空间<br/>
3.观察空间(视觉空间)<br/>
4.裁剪空间<br/>
5.屏幕空间</p>

<p>这是一个顶点最终转化到片段之前需要经历的所有不同的状态变化。</p>

<p>那这些变换通过什么？<br/>
比如模型、观察、投影三个矩阵的。<br/>
<img src="media/15263712692654/15264383184522.jpg" alt=""/></p>

<h3 id="toc_8">背面剔除和深度测试使用场景</h3>

<p>背面剔除是为了解决自身图片背部可见问题<br/>
深度测试是为了解决图形重叠的问题</p>

<h3 id="toc_9">Shader</h3>

<p><strong>Shader</strong>，中⽂名，着色器。着⾊器其实就是一段在GPU运行的程序（图形硬件设计所执行的一类特殊的函数，可以理解为图像处理单元（GPU）编译的一种小型程序）。<br/>
我们平时的程序，是在CPU运行。由于GPU的硬件设计结构与CPU有着很大的不同，所以GPU需要一些新的编程语言</p>

<h3 id="toc_10">术语理解</h3>

<p><strong>渲染</strong>:表示计算机从模型创建最终图像的过程。OpenGL 只是一种基于光栅化的系统。<br/>
<strong>模型（场景对象）</strong>：通过几何图元（点、线、三角形）来构建的。<br/>
<strong>着色器</strong>，它是图形硬件设计所执行的一类特殊的函数。可以理解为图像处理单元（GPU）编译的一种小型程序。<br/>
<strong>四种不同的着色阶段（shander stage）</strong>，其中最常用的包括顶点着色器（vertex shader）以及片元着色器，前者用于处理顶点数据，后者用于处理光栅化后的片元数据。所有OpenGL程序都需要用到这两类着色器<br/>
<strong>帧缓存（framebuffer）</strong>，像素（pixel），是显示器上最小的可见单元。计算机系统将所有的像素保存到帧缓存当中，后者是有图形硬件设备管理的一块独立内存区域，可以直接映射到最终的显示设备上</p>

<h3 id="toc_11">OpenGL 渲染图像的OpenGL 程序需要执行的操作：</h3>

<ul>
<li>从OpenGL的几何图元中设置数据，用于构建形状。</li>
<li>使用不同的着色器（shader）对输入的图元数据执行计算操作，判断它们的位置、颜色，以及其他渲染属性。</li>
<li>将输入图元的数学描述转化为与屏幕位置对应的像素片元（fragment）。这一步也称为光栅化（rasterization）。</li>
<li>最后，针对光栅化过程产生的每个片元，执行片元着色器（fragment shader），从而决定这个片元的最终颜色和位置。</li>
<li>如果有必要，还需要对每个片元执行一些额外的操作，例如判断片元对应的对象是否可见，或者将片元的颜色与当前屏幕位置的颜色进行融合。</li>
</ul>

<h3 id="toc_12">OpenGL 常见流程</h3>

<p><img src="media/15262868956417/15262888985785.jpg" alt=""/></p>

<ul>
<li>顶点着色器 和 片元着色器是必需的。细分和几何着色器是可选的捕捉。</li>
<li>OpenGL 需要将所有的数据都保存到缓存对象中（buffer object）</li>
</ul>

<h3 id="toc_13">屏幕渲染⽅式</h3>

<h4 id="toc_14">On-Screen Rendering(当前屏幕渲染)</h4>

<p>指的是GPU的渲染操作是在当前用于显示的屏幕缓存区中进行的。</p>

<h4 id="toc_15">Off-Screen Rendering(离幕渲染)</h4>

<p>指的是GPU在当前屏幕缓存区以外新开辟一个缓存区进行渲染操作</p>

<p>一般情况下，OpenGL ES 会将应用提供到渲染服务的动画直接渲染显示(使用基本的渲染的流程) 但对于一些复杂的图像动画的渲染，并不能够直接渲染叠加显示出来。而是需要根据 <code>Command Buffer</code> 分通道进⾏行渲染再组合。这个组合过程中，就有些渲染通道是不会直接显示出来的。标记此次渲染需要更多的渲染通道和合并步骤，⽽这些没有直接渲染显示在屏幕上的通道就是离屏渲染通道。</p>

<h4 id="toc_16">离屏渲染为什么会卡顿?</h4>

<p>离屏渲染需要更多的渲染通道，而不同的渲染通道间切换需要消耗⼀定的时间，这个时间内GPU会闲置。当通道数量足够时，对性能也会较大的影响。</p>

<h3 id="toc_17">离屏渲染的体现</h3>

<h4 id="toc_18">1、相⽐于当前屏幕渲染，离屏渲染的代价相对⽽言较高。主要有以下2个原因:</h4>

<p>1.创建新的缓存区<br/>
2.上下文切换</p>

<h4 id="toc_19">2、那些情况会使⽤离屏渲染(off-Screen Render)?</h4>

<ol>
<li>drawRect</li>
<li>layer.shouldRasterize = true; </li>
<li>有mask或者阴影(layer.makesToBounds) shouldRasterize(光栅化)、masks(遮罩)、shadows(阴影) edge antialiasing(抗锯⻮齿)、group opacity(不不透明)</li>
<li>Text(UILabel,CATextLayer,CoreText)</li>
</ol>

<h2 id="toc_20">参照</h2>

<p><a href="https://www.jianshu.com/p/fac6c39deec7">OpenGL 绘制基础图形</a></p>

<p>简书 MissCC： <a href="https://www.jianshu.com/u/1b4c832fb2ca">简书 MissCC</a></p>

<h2 id="toc_21">目录</h2>

<ul>
<li>
<a href="#toc_0">什么叫光栅化（Rasterize/rasteriztion）？</a>
</li>
<li>
<a href="#toc_1">图元是什么？</a>
</li>
<li>
<a href="#toc_2">什么叫管线？</a>
</li>
<li>
<a href="#toc_3">什么叫固定管线？</a>
</li>
<li>
<a href="#toc_4">什么可编程管线？</a>
</li>
<li>
<a href="#toc_5">顶点着色器调⽤次数与⽚元着⾊器调⽤次数与什么有关?谁⽐较多?</a>
</li>
<li>
<a href="#toc_6">为什么需要对三维空间的顶点进行坐标空间转换?</a>
</li>
<li>
<a href="#toc_7">在OpenGL 中有5种坐标系。</a>
</li>
<li>
<a href="#toc_8">背面剔除和深度测试使用场景</a>
</li>
<li>
<a href="#toc_9">Shader</a>
</li>
<li>
<a href="#toc_10">术语理解</a>
</li>
<li>
<a href="#toc_11">OpenGL 渲染图像的OpenGL 程序需要执行的操作：</a>
</li>
<li>
<a href="#toc_12">OpenGL 常见流程</a>
</li>
<li>
<a href="#toc_13">屏幕渲染⽅式</a>
<ul>
<li>
<a href="#toc_14">On-Screen Rendering(当前屏幕渲染)</a>
</li>
<li>
<a href="#toc_15">Off-Screen Rendering(离幕渲染)</a>
</li>
<li>
<a href="#toc_16">离屏渲染为什么会卡顿?</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">离屏渲染的体现</a>
<ul>
<li>
<a href="#toc_18">1、相⽐于当前屏幕渲染，离屏渲染的代价相对⽽言较高。主要有以下2个原因:</a>
</li>
<li>
<a href="#toc_19">2、那些情况会使⽤离屏渲染(off-Screen Render)?</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_20">参照</a>
<ul>
<li>
<a href="#toc_21">目录</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15263696340511.html">
                
                  <h1>OpenGL FrameBuffer Objects,RenderBuffer Objects and Textures</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">RenderBuffer</h3>

<blockquote>
<p>A renderbuffer object is a 2D image buffer allocated by the application. The renderbuffer can be used to allocate and store color, depth, or stencil values and can be used as a color, depth, or stencil attachment in a framebuffer object. A renderbuffer is similar to an off-screen window system provided drawable surface, such as a pbuffer. A renderbuffer, however, cannot be directly used as a GL texture.</p>

<p>渲染缓冲区对象是由应用程序分配的2D图像缓冲区。渲染缓冲区可用于分配和存储颜色，深度或模板值，并可用作帧缓冲区对象中的颜色，深度或模板附件。渲染缓冲器类似于提供可绘制表面的离屏窗口系统，例如pbuffer。但是，渲染缓冲区不能直接用作GL纹理。</p>
</blockquote>

<h3 id="toc_1">FrameBuffer</h3>

<blockquote>
<p>A framebuffer object (often referred to as an FBO) is a collection of color, depth, and stencil buffer attachment points; state that describes properties such as the size and format of the color, depth, and stencil buffers attached to the FBO; and the names of the texture and renderbuffer objects attached to the FBO. Various 2D images can be attached to the color attachment point in the framebuffer object. These include a renderbuffer object that stores color values, a mip-level of a 2D texture or a cubemap face, or even a mip-level of a 2D slice in a 3D texture. Similarly, various 2D images contain- ing depth values can be attached to the depth attachment point of an FBO. These can include a renderbuffer, a mip-level of a 2D texture or a cubemap face that stores depth values. The only 2D image that can be attached to the stencil attachment point of an FBO is a renderbuffer object that stores stencil values.</p>

<p>⼀个 frameBuffer 对象(通常被称为⼀个FBO)。是一个收集颜色、深度和模板缓存区的附着点。描述属性的状态，例如颜⾊、深度和模板缓存区的大小和格式，都关联到FBO(Frame Buffer Object)。并且纹理的名字和 renderBuffer 对象也都是关联于FBO。各种各样的2D图形能够被附着framebuffer对象的颜色附着点。它们包含了renderbuffer对象存储的颜⾊色值、⼀个2D纹理或⽴方体贴图。或者⼀一个mip-level的二维切面在 3D纹理。同样，各种各样的2D图形包含了当时的深度值可以附加到⼀个FBO的深度附着点中去。唯⼀的⼆维图像，能够附着在FBO的模板附着点，是一个renderbuffer对象存储模板值。</p>
</blockquote>

<p><img src="media/15263696340511/15263708418675.jpg" alt="FrameBuffer Objects,RenderBuffer Objects and Textures"/></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15263628382501.html">
                
                  <h1>OpenGL 与 OpenGL ES</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">一、什么是图形编程接⼝</h2>

<p><strong>2D图形编程接⼝</strong>: GDI, Skiz, OpenVG <br/>
<strong>3D图形编程接口</strong>: DirectX, OpenGL/OpenGL ES, Embedded Systems</p>

<h2 id="toc_1">二、图形编程接口与图形硬件的关系</h2>

<p>OpenGL，图形编程的接口<br/>
GPU 图形硬件，图形处理器</p>

<p>简单理解为：</p>

<blockquote>
<p>当应用需要图形的绘制以及渲染时，它会通过OpenGL ES框架，向GPU传输相应绘制指令，GPU收到指令后会进行相应操作），最终将渲染结果在屏幕上绘制出来。</p>
</blockquote>

<h2 id="toc_2">三、OpenGL 的特点</h2>

<p>1.跨操作系统平台运⾏<br/>
2.隐藏底层硬件信息 <br/>
3.专⽤渲染接⼝</p>

<h2 id="toc_3">四、OpenGL ES</h2>

<p>OpenGL for Embedded Systems（OpenGL ES）是OpenGL的简化版本（专门为嵌入式系统设计，在移动端操作系统中应用广泛），该版本消除了冗余功能，提供了更易学习且易于在移动图形硬件中实现的库。</p>

<h2 id="toc_4">五、OpenGL ES 的版本</h2>

<ul>
<li>OpenGL ES 1.X :针对固定功能流⽔水管线硬件 </li>
<li>OpenGL ES 2.X :针对可编程流⽔水管线硬件 </li>
<li>OpenGL ES 3.X :OpenGL ES 2.0的扩展</li>
</ul>

<h2 id="toc_5">六、着色器渲染过程</h2>

<p>在渲染过程中，必须存储2种着色器，分别是顶点着色器、片元着色器。顶点着色器是第一个着⾊器、片元着色器是最后一个。顶点着⾊器中处理顶点、片元着⾊器处理理像素点颜⾊。<br/>
<img src="media/15263628382501/15263637921501.jpg" alt=""/></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15262813725894.html">
                
                  <h1>HOOK</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">一、HOOK概述</h2>

<blockquote>
<p>HOOK(钩子) 其实就是改变程序执行流程的一种技术的统称!</p>
</blockquote>

<h2 id="toc_1">二、iOS中HOOK技术的几种方式</h2>

<h3 id="toc_2">1、Method Swizzle</h3>

<p>利用OC的<strong>Runtime</strong>特性，动态改变SEL（方法编号）和IMP（方法实现）的对应关系，达到OC方法调用流程改变的目的。主要用于<strong>OC</strong>方法。</p>

<h3 id="toc_3">2、fishhook</h3>

<p><a href="https://github.com/facebook/fishhook">fishhook</a> 是Facebook提供的一个动态修改链接mach-O文件的工具。利用MachO文件加载原理，通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的。</p>

<h4 id="toc_4">* How it works</h4>

<p>通过更新Mach-O二进制文件的<code>__DATA</code>段的特定部分中的指针，<code>dyld</code>绑定了惰性和非惰性符号。<strong>fishhook</strong>通过确定传递给<code>rebind_symbols</code>的每个符号名称的更新位置，然后写出相应的替换项来重新绑定这些符号。 <br/>
对于给定的<code>image</code>，<code>__DATA</code>段可能包含两个与动态符号绑定相关的部分：<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code>。 <code>__nl_symbol_ptr</code>是指向非延迟绑定数据的指针数组（这些指针在加载库时被绑定），而<code>__la_symbol_ptr</code>是指向导入函数的指针数组，通常在第一次调用该符号期间由一个名为<code>dyld_stub_binder</code>的例程填充（也可以告诉<code>dyld</code>在启动时绑定这些）。为了找到与这些部分中的某个部分中的特定位置相对应的符号的名称，我们必须跳过几个间接层。对于两个相关的部分，the section headers（来自<code>&lt;mach-o / loader.h&gt;</code>的结构）提供了一个<code>offset</code>（在<code>reserved1</code>字段中），称为间接符号表。位于二进制文件的<code>__LINKEDIT</code>段中的间接符号表仅仅是符号表（也在<code>__LINKEDIT</code>中）的索引数组，其顺序与非惰性和惰性符号部分中的指针顺序相同。因此，给定结构节<code>nl_symbol_ptr</code>，该节中第一个地址的符号表中相应的索引是<code>indirect_symbol_table [nl_symbol_ptr-&gt; reserved1]</code>。符号表本身是一个<code>struct nlists</code>数组（参见<code>&lt;mach-o / nlist.h&gt;</code>），并且每个<code>nlist</code>在<code>__LINKEDIT</code>中包含一个到字符串表中的索引，其中存储了实际的符号名称。因此，对于每个指针<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code>，我们可以找到相应的符号，然后找到相应的字符串与请求的符号名称进行比较，如果匹配，我们用该替换替换该部分中的指针。</p>

<p>在惰性或非惰性指针表中查找给定条目的名称的过程如下所示：<br/>
<img src="media/15262813725894/15262819366331.jpg" alt="通过符号表查找字符串"/></p>

<p>原理</p>

<ol>
<li><p>MachO 是被谁加载的  DYLD动态加载</p></li>
<li><p>ASLR（地址空间配置随机加载）  MachO文件加载的时候是随机地址</p></li>
<li><p>PIC 位置代码独立</p>
<ul>
<li>如果MachO内部需要调用系统的库函数时</li>
<li>现在——DATA段中简历一个指针，指向外部函数</li>
<li>DYLD会动态的进行绑定！将MachO中的DATA段中的指针，指向外部函数</li>
</ul></li>
</ol>

<h3 id="toc_5">3、Cydia Substrate</h3>

<p><strong>Cydia Substrate</strong> 原名为 <strong>Mobile Substrate</strong> ，它的主要作用是针对OC方法、C函数以及函数地址进行HOOK操作。当然它并不是仅仅针对iOS而设计的，安卓一样可以用。官方地址：<a href="http://www.cydiasubstrate.com/">http://www.cydiasubstrate.com/</a></p>

<p><strong>Cydia Substrate</strong>主要由3部分组成：</p>

<p><strong>MobileHooker</strong></p>

<p>   MobileHooker顾名思义用于HOOK。它定义一系列的宏和函数，底层调用<code>objc</code>的<code>runtime</code>和<code>fishhook</code>来替换系统或者目标应用的函数.<br/>
其中有两个函数:</p>

<ul>
<li><p>MSHookMessageEx 主要作用于Objective-C方法</p>
<pre><code class="language-text">void MSHookMessageEx(Class class, SEL selector, IMP replacement, IMP result)
</code></pre></li>
<li><p>MSHookFunction 主要作用于C和C++函数</p>
<pre><code class="language-text">void MSHookFunction(voidfunction,void* replacement,void** p_original)
</code></pre></li>
</ul>

<blockquote>
<p>Logos语法的%hook 就是对此函数做了一层封装</p>
</blockquote>

<p><strong>MobileLoader</strong><br/>
   MobileLoader用于加载第三方dylib在运行的应用程序中。启动时MobileLoader会根据规则把指定目录的第三方的动态库加载进去，第三方的动态库也就是我们写的破解程序.</p>

<p><strong>safe mode</strong><br/>
   因为APP程序质量参差不齐崩溃再所难免，破解程序本质是dylib，寄生在别人进程里。 系统进程一旦出错，可能导致整个进程崩溃,崩溃后就会造成iOS瘫痪。所以CydiaSubstrate引入了安全模式,在安全模 式下所有基于CydiaSubstratede 的三方dylib都会被禁用，便于查错与修复。</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15262794243261.html">
                
                  <h1>Core ML-Vision</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">Vison 与 Core ML 的关系</h2>

<p>Vision 是 Apple 在 WWDC 2017 推出的图像识别框架。</p>

<p>Core ML 是 Apple 在 WWDC 2017 推出的机器学习框架。</p>

<p><img src="media/15262794243261/15262794673272.jpg" alt=""/></p>

<p>Core ML的作用就是将一个Core ML模型，转换成我们的App工程可以直接使用的对象,就是可以看做是一个模型的转换器。</p>

<p>Vision在这里的角色，就是相当于一个用于识别Core ML模型的一个角色.</p>

<ul>
<li><p>Core ML可以看做一个模型的转换器，可以将一个 ML Model 格式的模型文件自动生成一些类和方法，可以直接使用这些类去做分析，让我们更简单的在app中使用训练好的模型。</p></li>
<li><p>Vision本身就是能对图片做分析，他自带了针对很多检测的功能，相当于内置了一些Model，另外Vision也能使用一个你设置好的其它的Core ML Model来对图进行分析。</p></li>
<li><p>Vision就是建立在Core ML层之上的，使用Vision其实还是用到了Core ML，只是没有显式地直接写Core ML的代码而已。</p></li>
</ul>

<h3 id="toc_1">应用场景</h3>

<ul>
<li><p>Face Detection and Recognition（人脸检测和识别）</p></li>
<li><p>Machine Learning Image Analysis（机器学习图像分析）</p></li>
<li><p>Barcode Detection（条码检测）</p></li>
<li><p>Image Alignment Analysis（图像对齐分析）</p></li>
<li><p>Text Detection（文本检测）</p></li>
<li><p>Horizon Detection（地平线检测）</p></li>
<li><p>Object Detection and Tracking（对象检测和跟踪）</p></li>
</ul>

<h2 id="toc_2">Vison 的使用 与结构图</h2>

<p>Vision使用中的角色有： Request，RequestHandler，results和results中的Observation数组。</p>

<p>Request类型： 有很多种，比如图中列出的 人脸识别、特征识别、文本识别、二维码识别等。</p>

<p><img src="media/15262794243261/15262795595758.jpg" alt=""/></p>

<pre><code class="language-text">// 转换CIImage
        let cgImage = image.cgImage!
        
        // 创建处理requestHandler
        let detectRequestHandler = VNImageRequestHandler(cgImage: cgImage)
        
        // 设置回调
        let completionHandler: VNRequestCompletionHandler = { (request: VNRequest, error: Error?) in
            self.handleImageWithType(type: type, image: image, observations: request.results!, complete: complete)
        }

        // 创建Request
　　　　　var detectRequest = VNDetectFaceRectanglesRequest.init(completionHandler: completionHandler)//面部轮廓

　　　　　//var detectRequest = VNDetectFaceRectanglesRequest.init(completionHandler: completionHandler)//面部特征
　　　　// 发送请求 
　　　　try? detectRequestHandler.perform([detectRequest])
</code></pre>

<pre><code class="language-text">// 转换CIImage
        let cgImage = image.cgImage!
        
        // 创建处理requestHandler
        let detectRequestHandler = VNImageRequestHandler(cgImage: cgImage)
        
        // 设置回调
        let completionHandler: VNRequestCompletionHandler = { (request: VNRequest, error: Error?) in
            self.handleImageWithType(type: type, image: image, observations: request.results!, complete: complete)
        }

        // 创建Request
　　　　　var detectRequest = VNDetectFaceRectanglesRequest.init(completionHandler: completionHandler)//面部轮廓

　　　　　//var detectRequest = VNDetectFaceRectanglesRequest.init(completionHandler: completionHandler)//面部特征
　　　　// 发送请求 
　　　　try? detectRequestHandler.perform([detectRequest])
</code></pre>

<pre><code class="language-text">// 处理人脸特征回调
    class func faceLandmarks(observations: [VNFaceObservation], image: UIImage, complete: detectImageHandler) -&gt; Void {
        
        for faceObversion in observations {
            // 获取细节特征
            let landmarks: VNFaceLandmarks2D = faceObversion.landmarks!
            
            //...
                
        }
    }
</code></pre>

<pre><code class="language-text">// 处理人脸特征回调
    class func faceLandmarks(observations: [VNFaceObservation], image: UIImage, complete: detectImageHandler) -&gt; Void {
        
        for faceObversion in observations {
            // 获取细节特征
            let landmarks: VNFaceLandmarks2D = faceObversion.landmarks!
            
            //...
                
        }
    }
</code></pre>

<p>项目代码：<a href="https://github.com/Caolongs/CoreML-Vision">CoreML-Vision </a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='AI.html'>AI</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15262781134516.html">
                
                  <h1>Core ML</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>Core ML 大大降低了开发者在苹果设备上使用机器学习技术预测模型的门槛和成本。苹果制定了自己的模型文件格式，统一的格式和全新的 API 设计使得 Core ML 支持苹果生态下多个平台。</p>

<p><img src="media/15262781134516/15262781536717.jpg" alt=""/></p>

<p><strong>performance primitives</strong> : Acccelerate and BNNS、Metal Performance Shaders。前者用于图形学以及数学上的大规模计算，后者用于优化加速图形渲染。</p>

<p><strong>ML Framework</strong>: Core ML主要有两个职责：导入机器学习模型；生成对应的OC或Swift代码。</p>

<p><strong>Domain Specific</strong>: Vision主要用于图片分析。NLP主要用于自然语义分析。</p>

<p>最上层是应用层，有了下面三层的基础，应用层就可以做很多事情，如人脸识别、手写文字理解、文字情感分析、自动翻译等。</p>

<h2 id="toc_0">Core ML应用创建过程</h2>

<h3 id="toc_1">1、拿到模型模型导入到项目</h3>

<p>　　最简单的获取方式是在<a href="https://developer.apple.com/machine-learning/">苹果官网下载</a>，具体是在Model模块中，该模块下有Places205-GoogLeNet、ResNet50、Inception V3、 VGG6等模型。当然也可以自己训练模型。另外苹果也提供了转换器（Core ML Tools），该转换器是基于Python实现的，可用它把训练出来的模型转为适配Core ML的模型。在文章的最后我会介绍如何使用Core ML Tools进行模型转换。<br/>
　　</p>

<h3 id="toc_2">2、模型导入到项目</h3>

<p>将模型导入到项目中。然后点击会出现下图所示状态。大小（Size）是 App 性能的一个重要指标，输入（Input）输出（Output）决定了如何使用这个模型。下图的输入是一张图片，输出有两个值，一个是最有可能的图片物体结果，为 String 类型；另一个是所有可能的物体类型以及对应的可能性，为 String 对应 Dobule 的 Dictionary 类型。</p>

<p><img src="media/15262781134516/15262782982692.jpg" alt=""/></p>

<h3 id="toc_3">3、生成代码并编程</h3>

<p>这个示例中我选择苹果官网提供的图像识别MobileNet作为模型。照片的选择主要是通过UIImagePickerController这个类实现。<br/>
demo地址：<a href="https://github.com/Caolongs/CoreMLClassifier">CoreMLClassifier</a></p>

<p>关键代码：</p>

<pre><code class="language-text">private func modelOutput() -&gt; MobileNetOutput {
        guard let image = imageView.image else {
            fatalError(&quot;No image specified.&quot;)
        }
        let scaledImage = image.scaleImage(newSize: CGSize.init(width: 224.0, height: 224.0))
        let buffer = scaledImage!.buffer()!
        guard let output = try? model.prediction(image: buffer) else {
            fatalError(&quot;Prediction process failed.&quot;)
        }
        return output
    }


private func diplayDesc() {
        let output = modelOutput()
        let probability = Int(output.classLabelProbs[output.classLabel]! * 100)
        descLabel.text = &quot;I&#39;m \(probability)% sure it&#39;s a \(output.classLabel)! &quot;
    }
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='AI.html'>AI</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15261041285565.html">
                
                  <h1>iOS App MachO注入 - Dylib注入</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">dylib 注入</h2>

<h3 id="toc_1">1. 新建<code>TARGETS</code></h3>

<p><img src="media/15259432014565/15260315279124.jpg" alt=""/></p>

<h3 id="toc_2">2. 添加依赖关系</h3>

<ul>
<li>在<code>Buildd Phases</code>选择<code>New Copy Files Phase</code>新建依赖库文件，选择<code>Destination</code>为<code>Framework</code>。添加刚刚新建的frammework库</li>
</ul>

<p><img src="media/15259432014565/15260317398242.jpg" alt=""/></p>

<h3 id="toc_3">3. 修改平台</h3>

<ul>
<li><p>修改<code>Architectures</code>为<code>iOS</code><br/>
<img src="media/15259432014565/15260325712384.jpg" alt=""/></p></li>
<li><p>修改<code>Signing</code>为<code>iOS</code><br/>
<img src="media/15259432014565/15260326574559.jpg" alt=""/></p></li>
</ul>

<h3 id="toc_4">4. 修改MachO文件的Load Commands（将<code>Dylib</code>库注入到可执行文件中）</h3>

<ul>
<li>使用<code>yololib</code>工具注入（手动）</li>
</ul>

<pre><code class="language-text">$ yololib WeChact Frameworks/libHookDylib.dylib
</code></pre>

<ul>
<li>使用<code>yololib</code>工具注入（脚本）</li>
</ul>

<pre><code class="language-text"># 需要注入的动态库的路径(写死了)
INJECT_FRAMEWORK_RELATIVE_PATH=&quot;Frameworks/libHookDylib.dylib&quot;

## 通过工具实现注入
&quot;/${SRCROOT}&quot;/yololib &quot;$TARGET_APP_PATH/$APP_BINARY&quot; &quot;$INJECT_FRAMEWORK_RELATIVE_PATH&quot;
</code></pre>

<h3 id="toc_5">5. 注入代码</h3>

<p>实现<code>load</code>方法，利用<code>Method Swizzle</code>实现修改</p>

<p><img src="media/15259432014565/15260335898629.jpg" alt=""/></p>

<h3 id="toc_6">GitHub</h3>

<p><a href="https://github.com/Caolongs/iOSInjectFramework">GitHub Demo</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15259432014565.html">
                
                  <h1>iOS App MachO注入 - Framework注入</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">Framework注入</h2>

<h3 id="toc_1">1. 新建<code>TARGETS</code></h3>

<p><img src="media/15259432014565/15259460082674.jpg" alt=""/></p>

<h3 id="toc_2">2. 添加依赖关系</h3>

<ul>
<li>在<code>Buildd Phases</code>选择<code>New Copy Files Phase</code>新建依赖库文件，选择<code>Destination</code>为<code>Framework</code>。添加刚刚新建的frammework库</li>
</ul>

<p><img src="media/15259432014565/15260229574177.jpg" alt=""/></p>

<p><img src="media/15259432014565/15260231241298.jpg" alt=""/></p>

<ul>
<li>验证<code>frammewor</code>注入库添加依赖是否成功<br/>
编译程序，打开<code>Products</code>下app文件，包内容下<code>Frameworks</code>文件下已生成对应注入库
<img src="media/15259432014565/15260234170472.jpg" alt=""/></li>
</ul>

<h3 id="toc_3">3. 修改MachO文件的Load Commands（将<code>frammewor</code>库注入到可执行文件中）</h3>

<ul>
<li>使用<code>yololib</code>工具注入（手动）</li>
</ul>

<pre><code class="language-text">$ yololib WeChact Frameworks/HookFramework.framework/HookFramework
</code></pre>

<ul>
<li>使用<code>yololib</code>工具注入（脚本）</li>
</ul>

<pre><code class="language-text"># 需要注入的动态库的路径(写死了)
INJECT_FRAMEWORK_RELATIVE_PATH=&quot;Frameworks/HookFramework.framework/HookFramework&quot;

## 通过工具实现注入
&quot;/${SRCROOT}&quot;/yololib &quot;$TARGET_APP_PATH/$APP_BINARY&quot; &quot;$INJECT_FRAMEWORK_RELATIVE_PATH&quot;
</code></pre>

<ul>
<li>使用<code>MachOView</code>工具查看是否注入成功</li>
</ul>

<p><img src="media/15259432014565/15260305277989.jpg" alt=""/></p>

<h3 id="toc_4">4. 注入代码</h3>

<p>在<code>HookFramework</code>库下创文件，实现<code>load</code>方法，利用<code>Method Swizzle</code>实现修改<br/>
<img src="media/15259432014565/15260310477278.jpg" alt=""/></p>

<h3 id="toc_5">GitHub</h3>

<p><a href="https://github.com/Caolongs/iOSInjectFramework">GitHub Demo</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15258540971098.html">
                
                  <h1>iOS App 签名过程及重签</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">目的：</h2>

<p>保证 iOS 平台对第三方 APP 有绝对的控制权，每一个安装到 iOS 上的 APP 都是经过苹果官方允许的。</p>

<h2 id="toc_1">签名过程</h2>

<p><img src="media/15258540971098/15258559672530.png" alt=""/></p>

<ol>
<li>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local</li>
<li>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple</li>
<li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li>
<li>在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。</li>
<li>在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。</li>
<li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。</li>
<li>确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。</li>
</ol>

<h2 id="toc_2">概念和操作</h2>

<p>上面的步骤对应到我们平常具体的操作和概念是这样的：</p>

<ol>
<li>第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。</li>
<li>第 2 步苹果处理，不用管。</li>
<li>第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。</li>
<li>第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。</li>
<li>第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。</li>
<li>第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。</li>
</ol>

<p>这里再总结一下这些概念：</p>

<ol>
<li><strong>证书</strong>：内容是公钥或私钥，由其他机构对其签名组成的数据包。</li>
<li><strong>Entitlements</strong>：包含了 App 权限开关列表。</li>
<li><strong>CertificateSigningRequest</strong>：本地公钥。</li>
<li><strong>p12</strong>：本地私钥，可以导入到其他电脑。</li>
<li><strong>Provisioning Profile</strong>：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</li>
</ol>

<h2 id="toc_3">iOS APP 重签名具体操作(手动)</h2>

<ol>
<li>干掉插件Plugins文件夹里面的内容!</li>
<li>Watch 文件删除</li>
<li><p>对 Frameworks 进行签名!</p>
<pre><code class="language-text">`$ codesign -fs &quot;证书&quot; xxx.framework`
</code></pre></li>
<li><p>给可执行文件执行权限! <code>chmod +x WeChat</code></p></li>
<li><p>拷贝描述文件(可新建工程，获取app包中<code>embedded.mobileprovision</code>)</p></li>
<li><p>修改info.plist 的Bundle ID(与描述文件工程一致)</p></li>
<li><p>生成plist的权限文件<code>en.plist</code>(复制<code>embedded.mobileprovision</code>权限内容)，放到<code>Payload</code>目录下</p>
<pre><code class="language-text">&lt;key&gt;keychain-access-groups&lt;/key&gt;
        &lt;array&gt;<br/>
            &lt;string&gt;X7Y****CQ.*&lt;/string&gt;<br/>
        &lt;/array&gt;<br/>
        &lt;key&gt;get-task-allow&lt;/key&gt;<br/>
        &lt;true/&gt;<br/>
        &lt;key&gt;application-identifier&lt;/key&gt;<br/>
        &lt;string&gt;X7Y****JCQ.*&lt;/string&gt;<br/>
        &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;<br/>
        &lt;string&gt;X7Y****CQ&lt;/string&gt;
</code></pre></li>
<li><p>签名整个APP!</p>
<pre><code class="language-text">$ codesign -fs &quot;iPhone Developer: xxxxxx (6ZBE4C573L)&quot;  --no-strict --entitlements=en.plist WeChat.app
</code></pre></li>
<li><p>打包其实就是一个zip</p>
<pre><code class="language-text">$ zip -ry WeChat.ipa Payload
</code></pre>
<p>iPhone Developer: shan jingjing (3QDN5929LL)</p></li>
<li><p>安装到手机</p></li>
</ol>

<p><code>Xcode</code>-&gt;<code>Window</code>-&gt;<code>Devices and Simulators</code>-&gt;<code>Devices INSTALL APP</code> 点击<code>+</code>选中<code>WeChat.ipa</code></p>

<h2 id="toc_4">iOS APP 利用Xcode重签名</h2>

<ol>
<li>创建工程，替换Product下的app</li>
<li>修改<code>Bundle identifier</code>与新建工程一致</li>
<li>Plugins、Watch 文件删除</li>
<li><p>Framework重签名</p>
<pre><code class="language-text">`$ codesign -fs &quot;证书&quot; xxx.framework`
</code></pre></li>
<li><p>给可执行文件执行权限! <code>chmod +x WeChat</code></p></li>
<li><p>Xcode 运行安装至手机</p></li>
</ol>

<h2 id="toc_5">iOS APP 脚本自动化重签名</h2>

<ol>
<li><p>新建工程，添加<code>Run Script</code>脚本</p>
<p><img src="media/15258540971098/15259319285089.jpg" alt=""/></p></li>
</ol>

<pre><code class="language-text"># ${SRCROOT} 它是工程文件所在的目录
TEMP_PATH=&quot;${SRCROOT}/Temp&quot;
#资源文件夹
ASSETS_PATH=&quot;${SRCROOT}/TargetAPP&quot;
#ipa包路径
TARGET_IPA_PATH=&quot;${ASSETS_PATH}/*.ipa&quot;

#新建Temp文件夹
rm -rf &quot;${SRCROOT}/Temp&quot;
mkdir -p &quot;${SRCROOT}/Temp&quot;

#----------------------------------------
# 1. 解压IPA到Temp下
unzip -oqq &quot;$TARGET_IPA_PATH&quot; -d &quot;$TEMP_PATH&quot;
# 拿到解压的临时的APP的路径
TEMP_APP_PATH=$(set -- &quot;$TEMP_PATH/Payload/&quot;*.app;echo &quot;$1&quot;)
# echo &quot;路径是:$TEMP_APP_PATH&quot;


#----------------------------------------
# 2. 将解压出来的.app拷贝进入工程下
# BUILT_PRODUCTS_DIR 工程生成的APP包的路径
# TARGET_NAME target名称
TARGET_APP_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app&quot;
echo &quot;app路径:$TARGET_APP_PATH&quot;

rm -rf &quot;$TARGET_APP_PATH&quot;
mkdir -p &quot;$TARGET_APP_PATH&quot;
cp -rf &quot;$TEMP_APP_PATH/&quot; &quot;$TARGET_APP_PATH&quot;


#----------------------------------------
# 3. 删除extension和WatchAPP.个人证书没法签名Extention
rm -rf &quot;$TARGET_APP_PATH/PlugIns&quot;
rm -rf &quot;$TARGET_APP_PATH/Watch&quot;


#----------------------------------------
# 4. 更新info.plist文件 CFBundleIdentifier
#  设置:&quot;Set : KEY Value&quot; &quot;目标文件路径&quot;
/usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;


#----------------------------------------
# 5. 给MachO文件上执行权限
# 拿到MachO文件的路径
APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\&gt;|cut -f1 -d\&lt;`
#上可执行权限
chmod +x &quot;$TARGET_APP_PATH/$APP_BINARY&quot;


#----------------------------------------
# 6. 重签名第三方 FrameWorks
TARGET_APP_FRAMEWORKS_PATH=&quot;$TARGET_APP_PATH/Frameworks&quot;

if [ -d &quot;$TARGET_APP_FRAMEWORKS_PATH&quot; ];
then
for FRAMEWORK in &quot;$TARGET_APP_FRAMEWORKS_PATH/&quot;*
do

    if test -f  $FRAMEWORK
    then
    #签名
    /usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$FRAMEWORK&quot;
    fi
done
fi

</code></pre>

<hr/>

<hr/>

<h2 id="toc_6">命令</h2>

<pre><code class="language-text">查看描述文件信息: $ security cms -D -i 描述文件路径

查看APP的签名信息
$ codesign -vv -d APP路径(.app)

查看本机所有证书
$ security find-identity -v -p codesigning

查看可执行文件的加密信息!
$ otool -l WeChat | grep crypt

签名
$ codesign -fs &quot;证书&quot; 需要签名的文件
</code></pre>

<h2 id="toc_7">参考</h2>

<p><a href="http://blog.cnbang.net/tech/3386/">iOS App 签名的原理</a></p>

<ul>
<li>
<a href="#toc_0">目的：</a>
</li>
<li>
<a href="#toc_1">签名过程</a>
</li>
<li>
<a href="#toc_2">概念和操作</a>
</li>
<li>
<a href="#toc_3">iOS APP 重签名具体操作(手动)</a>
</li>
<li>
<a href="#toc_4">iOS APP 利用Xcode重签名</a>
</li>
<li>
<a href="#toc_5">iOS APP 脚本自动化重签名</a>
</li>
<li>
<a href="#toc_6">命令</a>
</li>
<li>
<a href="#toc_7">参考</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15254163602054.html">
                
                  <h1>ShadowSocks 配置及BBR加速</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>ShadowSocks势必先要后买VPS，本人目前使用的是 <a href="https://www.vultr.com/?ref=7305309">Vultr</a>, 购买流程此文不再赘述。</p>

<h2 id="toc_0">SSH 登录 VPS</h2>

<p>登录远程vps可使用Vultr提供网页的<code>View Console</code>(体验太差)，或使用ssh客户端工具进行登录。<br/>
此处以Mac终端登录为例：</p>

<p>打开终端,登录远程服务器，回车，输入yes确认是否连接，然后输入密码</p>

<pre><code class="language-text">$ ssh root@108.61.219.99
</code></pre>

<p><code>Username</code>、<code>IP Address</code>可见创建的服务器详情</p>

<h2 id="toc_1">VPS安装ShadowSocks</h2>

<h4 id="toc_2">1. 输入以下命令</h4>

<pre><code class="language-text">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh
chmod +x shadowsocks-all.sh
./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log
</code></pre>

<h4 id="toc_3">2. 选择Shadowsocks server，此处本人使用的是ShadowsocksR</h4>

<pre><code class="language-text">Which Shadowsocks server you&#39;d select:
1) Shadowsocks-Python
2) ShadowsocksR
3) Shadowsocks-Go
4) Shadowsocks-libev
Please enter a number (Default Shadowsocks-Python):2

You choose = ShadowsocksR

Please enter password for ShadowsocksR
(Default password: teddysun.com):

</code></pre>

<h4 id="toc_4">3. 配置信息</h4>

<p>根据提示配置<code>Password</code>、<code>Port</code>、<code>Protocol</code>、<code>obfs</code>、<code>Encryption Method</code></p>

<pre><code class="language-text">Congratulations, ShadowsocksR server install completed!
Your Server IP        :  108.61.0.0
Your Server Port      :  9999
Your Password         :  .......
Your Protocol         :  origin
Your obfs             :  plain
Your Encryption Method:  aes-256-cfb

Your QR Code: (For ShadowsocksR Windows, Android clients only)
 ssr://MTA4LjYxLjIxOS45OTo5OTk5O.......
Your QR Code has been saved as a PNG file path:
 /root/shadowsocks_r_qr.png

Welcome to visit: https://teddysun.com/486.html
Enjoy it!
</code></pre>

<h4 id="toc_5">4. shadowsocks 常用命令</h4>

<h5 id="toc_6">卸载方法</h5>

<pre><code class="language-text">$ ./shadowsocks-all.sh uninstall
</code></pre>

<h5 id="toc_7">启动脚本(ShadowsocksR 版)：</h5>

<pre><code class="language-text">/etc/init.d/shadowsocks-r start | stop | restart | status
</code></pre>

<h5 id="toc_8">多开端口</h5>

<ul>
<li>找到配置文件<code>/etc/shadowsocks-r/config.json</code>或（<code>/etc/shadowsocks.json</code>）,修改如下：</li>
</ul>

<pre><code class="language-text">{
    &quot;server_port&quot;:9998,
    &quot;password&quot;:&quot;123456&quot;,
}

改为
{
    &quot;port_password&quot;:{
        &quot;9998&quot;:&quot;password1&quot;,
        &quot;9999&quot;:&quot;password2&quot;
     },
}
</code></pre>

<ul>
<li>检测某个端口是否开启,返回<code>yes</code>说明已开启</li>
</ul>

<pre><code class="language-text">$ firewall-cmd --query-port=9998/tcp --zone=public #查询9998端口是否开启
</code></pre>

<ul>
<li>开启某端口代码</li>
</ul>

<pre><code class="language-text">firewall-cmd --zone=public --add-port=9998/tcp --permanent #添加9998端口
</code></pre>

<ul>
<li>最后，重启VPS服务器<code>reboot</code></li>
</ul>

<h4 id="toc_9">5. BBR 脚本</h4>

<p>使用root用户登录，运行以下命令：</p>

<pre><code class="language-text">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh
</code></pre>

<p>验证方法</p>

<pre><code class="language-text">$ uname -r
# 查看内核版本，显示为最新版就表示 OK 了
# ————————————
$ sysctl net.ipv4.tcp_available_congestion_control
# 返回值一般为：
# net.ipv4.tcp_available_congestion_control = bbr cubic reno
# ————————————
$ sysctl net.ipv4.tcp_congestion_control
# 返回值一般为：
# net.ipv4.tcp_congestion_control = bbr
# ————————————
$ sysctl net.core.default_qdisc
# 返回值一般为：
# net.core.default_qdisc = fq
# ————————————
$ lsmod | grep bbr
# 返回值有 tcp_bbr 模块即说明bbr已启动。
</code></pre>

<h2 id="toc_10">安装 ShadowsocksR 客户端</h2>

<p><a href="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases">MAC版ShadowsocksX-NG-R</a></p>

<p>下载ShadowsocksR配置服务器设置，填写相关信息</p>

<h2 id="toc_11">Chrome插件—SwitchyOmega</h2>

<p><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-ntp-icon">SwitchyOmega</a></p>

<p>.......</p>

<h2 id="toc_12">参考</h2>

<p><a href="https://www.diycode.cc/topics/738">轻松在 VPS 搭建 Shadowsocks 翻墙 </a><br/>
<a href="https://teddysun.com/486.html">Shadowsocks 一键安装脚本（四合一）</a><br/>
<a href="https://teddysun.com/489.html">一键安装最新内核并开启 BBR 脚本</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15253297909641.html">
                
                  <h1>加密（哈希、AES、RSA）</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">一、哈希（散列）函数</h3>

<ul>
<li>MD5 </li>
<li>SHA1 </li>
<li>SHA256/512</li>
<li>HMAC</li>
</ul>

<h4 id="toc_1">特点：</h4>

<ul>
<li>算法公开</li>
<li>对不同数据加密结果是定长的!32位字符!!</li>
<li>信息摘要(加密之后的数据是不可逆!!)</li>
</ul>

<h4 id="toc_2">应用：</h4>

<ul>
<li>一般用来做密码加密!</li>
<li>版权问题，MD5值!</li>
<li>搜索引擎</li>
<li>云盘秒传（服务器上只要有这个文件,那么用户可以实现秒传）</li>
<li>签名验证 (信息+信息MD5发送给服务器)</li>
<li>HMAC （可用于设备锁）</li>
</ul>

<blockquote>
<p>较为安全的hash登录加密方案：<br/>
（HMAC+<code>网络时间戳</code>).MD5</p>
</blockquote>

<h4 id="toc_3">终端</h4>

<p>Mac系统有一个开源的密码库openssl，几乎集成所有的加密算法<br/>
opsenssl是一个最具说服力的标准</p>

<ul>
<li>计算MD5加密</li>
</ul>

<pre><code class="language-text">$ md5 -s &quot;string&quot;
</code></pre>

<ul>
<li>计算SHA1散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha1
</code></pre>

<ul>
<li>计算SHA256散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha256
</code></pre>

<ul>
<li>计算SHA 512散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha512
</code></pre>

<hr/>

<ul>
<li>计算HMAC MD5散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl dgst -md5 -hmac &quot;key&quot;
</code></pre>

<ul>
<li>计算HMAC SHA1散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha1 -hmac &quot;key&quot;
</code></pre>

<ul>
<li>计算HMAC SHA256散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha256 -hmac &quot;key&quot;
</code></pre>

<ul>
<li>计算HMAC SHA512散列结果</li>
</ul>

<pre><code class="language-text">$ echo -n &quot;string&quot; | openssl sha -sha512 -hmac &quot;key&quot;
</code></pre>

<hr/>

<ul>
<li>计算文件的MD5散列结果</li>
</ul>

<pre><code class="language-text">$ md5 file.dat
</code></pre>

<ul>
<li>计算文件的SHA1散列结果</li>
</ul>

<pre><code class="language-text">$ openssl sha -sha1 file.dat
</code></pre>

<ul>
<li>计算文件的SHA256散列结果</li>
</ul>

<pre><code class="language-text">$ openssl sha -sha256 file.dat
</code></pre>

<ul>
<li>计算文件的SHA512散列结果</li>
</ul>

<pre><code class="language-text">$ openssl sha -sha512 file.dat
</code></pre>

<h3 id="toc_4">二、对称加密算法（传统加密算法）</h3>

<p>加密和解密都是同一个密钥</p>

<ul>
<li>DES   目前几乎不用，强度不够</li>
<li>3DES  使用3个密钥,对相同的数据执行三次加密,强度增强</li>
<li>AES   高级密码标准,苹果钥匙串访问</li>
</ul>

<h4 id="toc_5">每个对称加密算法有两种加密方式</h4>

<ul>
<li>1. ECB加密： 电子代码本，就是简单的将数据拆包，每一块独立加密</li>
<li>2. CBC（密码块链）加密： 也是独立加密一块数据，但是第二块数据和第一块数据有密切的联系</li>
</ul>

<h4 id="toc_6">终端</h4>

<pre><code class="language-text">/**
 *  终端测试指令
 *
 *  DES(ECB)加密
 *  $ echo -n hello | openssl enc -des-ecb -K 616263 -nosalt | base64
 *
 *  DES(CBC)加密
 *  $ echo -n hello | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt | base64
 *
 *  AES(ECB)加密
 *  $ echo -n hello | openssl enc -aes-128-ecb -K 616263 -nosalt | base64
 *
 *  AES(CBC)加密
 *  $ echo -n hello | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt | base64
 *
 *  DES(ECB)解密
 *  $ echo -n HQr0Oij2kbo= | base64 -D | openssl enc -des-ecb -K 616263 -nosalt -d
 *
 *  DES(CBC)解密
 *  $ echo -n alvrvb3Gz88= | base64 -D | openssl enc -des-cbc -iv 0102030405060708 -K 616263 -nosalt -d
 *
 *  AES(ECB)解密
 *  $ echo -n d1QG4T2tivoi0Kiu3NEmZQ== | base64 -D | openssl enc -aes-128-ecb -K 616263 -nosalt -d
 *
 *  AES(CBC)解密
 *  $ echo -n u3W/N816uzFpcg6pZ+kbdg== | base64 -D | openssl enc -aes-128-cbc -iv 0102030405060708 -K 616263 -nosalt -d
 *
 *  提示：
 *      1&gt; 加密过程是先加密，再base64编码
 *      2&gt; 解密过程是先base64解码，再解密
 */
</code></pre>

<h4 id="toc_7">iOS 加密核心函数</h4>

<pre><code class="language-text">CCCryptorStatus CCCrypt(
    CCOperation op,         /* 加密/解密 */
    CCAlgorithm alg,        /* 加密算法 */
    CCOptions options,      /* CBC/ECB */
    const void *key,        /* 加密密钥 */
    size_t keyLength,       /* 密钥长度 */
    const void *iv,         /* iv初始化向量 */
    const void *dataIn,     /* 加密的数据 */
    size_t dataInLength,    /* 加密的数据长度  */
    void *dataOut,          /* 密文的缓冲区 */
    size_t dataOutAvailable,/* 缓冲区的大小 */
    size_t *dataOutMoved)   /* 加密结果的大小 */                                     
</code></pre>

<h3 id="toc_8">三、非对称加密算法（现在加密算法）</h3>

<p>私钥加密 公钥解密<br/>
公钥加密 私钥解密</p>

<ul>
<li>终端生成密钥</li>
</ul>

<p>生成私钥：</p>

<pre><code class="language-text">$ openssl genrsa -out private.pem 512
</code></pre>

<p>生成公钥：</p>

<pre><code class="language-text">$ openssl rsa -in private.pem -out public.pem -pubout
</code></pre>

<ul>
<li>算法</li>
</ul>

<blockquote>
<ol>
<li>选两个质数 p 和 q，相乘得出一个大整数n，例如 p = 61，q = 53，n = pq = 3233</li>
<li>选 1-n 间的随便一个质数e，例如 e = 17</li>
<li>经过一系列数学公式，算出一个数字 d，满足:
<ul>
<li>通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。</li>
<li>如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。</li>
</ul></li>
</ol>

<p>上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用私钥加密，公钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥 (只知道 n 和 e)的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而 n 数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。</p>
</blockquote>

<h2 id="toc_9">目录</h2>

<ul>
<li>
<a href="#toc_0">一、哈希（散列）函数</a>
<ul>
<li>
<a href="#toc_1">特点：</a>
</li>
<li>
<a href="#toc_2">应用：</a>
</li>
<li>
<a href="#toc_3">终端</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">二、对称加密算法（传统加密算法）</a>
<ul>
<li>
<a href="#toc_5">每个对称加密算法有两种加密方式</a>
</li>
<li>
<a href="#toc_6">终端</a>
</li>
<li>
<a href="#toc_7">iOS 加密核心函数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">三、非对称加密算法（现在加密算法）</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">目录</a>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15253114095127.html">
                
                  <h1>LLDB 使用</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>LLDB(Low Lever Debug)命令结构</p>

<pre><code class="language-text">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]
</code></pre>

<blockquote>
<p>其中：</p>

<ol>
<li><command>(命令)和<subcommand>(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</li>
<li><action>：我们想在前面的命令序列的上下文中执行的一些操作。</li>
<li><options>：行为修改器(action modifiers)。通常带有一些值。</li>
<li><argument>：根据使用的命令的上下文来表示各种不同的东西。</li>
</ol>
</blockquote>

<h2 id="toc_0">设置断点</h2>

<ul>
<li>breakpoint</li>
</ul>

<pre><code class="language-text">$ breakpoint set -n [方法字符串]

例如：
$ breakpoint set -n &quot;viewDidLoad&quot;

`其中 -n 是 --name缩写`
</code></pre>

<ul>
<li>显示当前断点</li>
</ul>

<pre><code class="language-text">$ breakpoint list
</code></pre>

<ul>
<li>禁用</li>
</ul>

<pre><code class="language-text">$ breakpoint disable [编号]
</code></pre>

<ul>
<li>启用</li>
</ul>

<pre><code class="language-text">$ breakpoint enable [编号]
</code></pre>

<ul>
<li>删除（只能按组删除，不能删除组中的某个）</li>
</ul>

<pre><code class="language-text">$ breakpoint delete 【编号】
</code></pre>

<ul>
<li>根据selector方法设置断点</li>
</ul>

<pre><code class="language-text">$ breakpoint set —-selector [方法]

例如：
$ breakpoint set --selector dealloc
</code></pre>

<ul>
<li>根据某个文件中的selector方法设置断点</li>
</ul>

<pre><code class="language-text">$ breakpoint set —file [文件] —-selector [方法]
</code></pre>

<ul>
<li>遍历项目中所有包含 testFunc 字符串的方法并设置断点</li>
</ul>

<pre><code class="language-text">$ breakpoint set -r [方法字符串]

例如：
$ breakpoint set -r &quot;testFunc&quot;
</code></pre>

<h2 id="toc_1">流程控制</h2>

<ul>
<li>继续执行</li>
</ul>

<pre><code class="language-text">$ c continue
</code></pre>

<ul>
<li>单步运行,将子函数当做整体一步执行</li>
</ul>

<pre><code class="language-text">$ n next
</code></pre>

<ul>
<li>单步运行,遇到子函数会进去</li>
</ul>

<pre><code class="language-text">$ s 
</code></pre>

<ul>
<li>按住 <code>ctrl</code> 汇编级别 </li>
</ul>

<pre><code class="language-text">$ ni
$ si
</code></pre>

<h2 id="toc_2">expresion</h2>

<p>执行代码，例如当你需要改变一些东西,但是因为某种原因不能编译</p>

<pre><code class="language-text">$ expresion [代码]
</code></pre>

<p>例：</p>

<pre><code class="language-text">$ expression self.view.backgroundColor = [UIColor redColor];
</code></pre>

<p>换行<code>ctrl</code>+<code>enter</code></p>

<h2 id="toc_3">调用栈 bt</h2>

<p>Show the current thread&#39;s call stack. </p>

<ul>
<li>显示调用栈</li>
</ul>

<pre><code class="language-text">$ bt
</code></pre>

<ul>
<li>上一个方法的调用者</li>
</ul>

<pre><code class="language-text">$ up
</code></pre>

<ul>
<li>下一个方法的调用者</li>
</ul>

<pre><code class="language-text">$ down
</code></pre>

<ul>
<li>调到指定调用者</li>
</ul>

<pre><code class="language-text">$ frame select [bt 显示的frame 编号]
</code></pre>

<h2 id="toc_4">watchpoint</h2>

<p>内存断点，断点对象属性，类似kvo</p>

<p>根据变量名称</p>

<pre><code class="language-text">$ watchpoint set variable  [self-&gt;name]
</code></pre>

<p>根据内存地址</p>

<pre><code class="language-text">$ watchpoint set expresion  [内存地址]
</code></pre>

<h2 id="toc_5">breakpoint command</h2>

<ul>
<li>断点触发 指令（触发时执行指令添加）</li>
</ul>

<pre><code class="language-text">$ break command add [编号]
</code></pre>

<p>例如：</p>

<pre><code class="language-text">(lldb) breakpoint command add 5.1
Enter your debugger command(s).  Type &#39;DONE&#39; to end.
&gt; 
</code></pre>

<ul>
<li>查看</li>
</ul>

<pre><code class="language-text">$ break command list [编号]
</code></pre>

<ul>
<li>删除</li>
</ul>

<pre><code class="language-text">$ break command delete [编号]
</code></pre>

<h2 id="toc_6">target stop-hook</h2>

<p>每次stop的时候去执行一些命令，只对breakpoint，watchpoint有效</p>

<pre><code class="language-text">//每次stop执行frame variable
$ target stop-hook add -o &quot;frame variable&quot; 

$ target stop-hook list

$ target stop-hook delete
</code></pre>

<h2 id="toc_7">frame</h2>

<ul>
<li>Print out a list of all variables in the current frame</li>
</ul>

<pre><code class="language-text">$ frame variable
</code></pre>

<ul>
<li>Need to know where you are?</li>
</ul>

<pre><code class="language-text">$ frame info
</code></pre>

<h2 id="toc_8">thread</h2>

<ul>
<li>代码回滚，之后代码将不会执行</li>
</ul>

<pre><code class="language-text">$ thread return
</code></pre>

<h2 id="toc_9">.lldbinit 文件配置</h2>

<p>目录 <code>/Users/caolongjian/.lldbinit</code><br/>
lldb每次启动都会调用，用于导入配置文件</p>

<h2 id="toc_10">其他常用</h2>

<ul>
<li>数组越界崩溃信息查看</li>
</ul>

<pre><code class="language-text">$ image lookup -a [地址0x]
</code></pre>

<ul>
<li>快速查看类</li>
</ul>

<pre><code class="language-text">$ image lookup -t [类 Person]
</code></pre>

<ul>
<li>List current executable and dependent shared library images.</li>
</ul>

<pre><code class="language-text">$ image list
</code></pre>

<h2 id="toc_11">help</h2>

<p>获取帮助信息<br/>
<code>help &lt;command-name&gt;</code> 、<code>help &lt;command-name&gt; &lt;option&gt;</code></p>

<pre><code class="language-text">$ help
$ help breakpoint
</code></pre>

<ul>
<li>
<a href="#toc_0">设置断点</a>
</li>
<li>
<a href="#toc_1">流程控制</a>
</li>
<li>
<a href="#toc_2">expresion</a>
</li>
<li>
<a href="#toc_3">调用栈 bt</a>
</li>
<li>
<a href="#toc_4">watchpoint</a>
</li>
<li>
<a href="#toc_5">breakpoint command</a>
</li>
<li>
<a href="#toc_6">target stop-hook</a>
</li>
<li>
<a href="#toc_7">frame</a>
</li>
<li>
<a href="#toc_8">thread</a>
</li>
<li>
<a href="#toc_9">.lldbinit 文件配置</a>
</li>
<li>
<a href="#toc_10">其他常用</a>
</li>
<li>
<a href="#toc_11">help</a>
</li>
</ul>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15246450401949.html">
                
                  <h1>初识汇编</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>我们在学习逆向开发之前,我们要了解一个基本的逆向原理.首先我们是逆向iOS系统上面的APP.那么我们知道,一个APP安装在手机上面的可执行文件本质上是二进制文件.因为iPhone手机本质上执行的指令是二进制.是由手机上的CPU执行的.所以逆向开发是建立在分析二进制上面.所以今天我们接下来的课程从非常基础的东西开始讲解.</p>

<h2 id="toc_0">汇编语言的发展</h2>

<h3 id="toc_1">机器语言</h3>

<blockquote>
<p>由0和1组成的机器指令.</p>
</blockquote>

<ul>
<li>加：0100 0000</li>
<li>减：0100 1000</li>
<li>乘：1111 0111 1110 0000 </li>
<li>除：1111 0111 1111 0000 </li>
</ul>

<h3 id="toc_2">汇编语言(assembly language)</h3>

<blockquote>
<p>使用助记符代替机器语言<br/>
如:</p>
</blockquote>

<ul>
<li>加：INC EAX     通过编译器 0100 0000</li>
<li>减：DEC EAX     通过编译器 0100 1000</li>
<li>乘：MUL EAX         通过编译器 1111 0111 1110 0000</li>
<li>除：DIV EAX     通过编译器 1111 0111 1111 0000</li>
</ul>

<h3 id="toc_3">高级语言（High-level programming language)</h3>

<blockquote>
<p>C\C++\Java\OC\Swift,更加接近人类的自然语言<br/>
比如C语言:</p>
</blockquote>

<ul>
<li>加：A+B     通过编译器           0100 0000</li>
<li>减：A-B     通过编译器           0100 1000</li>
<li>乘：A*B     通过编译器           1111 0111 1110 0000</li>
<li>除：A/B     通过编译器           1111 0111 1111 0000</li>
</ul>

<p>我们的代码在终端设备上是这样的过程:<br/>
<img src="media/15246450401949/15193669666308.jpg" alt="15193669666308"/></p>

<ul>
<li> <strong>汇编语言</strong>与<strong>机器语言</strong>一一对应，每一条机器指令都有与之对应的汇编指令</li>
<li> <strong>汇编语言</strong>可以通过编译得到<strong>机器语言</strong>，<strong>机器语言</strong>可以通过反汇编得到<strong>汇编语言</strong></li>
<li> <strong>高级语言</strong>可以通过编译得到<strong>汇编语言</strong> \ <strong>机器语言</strong>，但汇编语言\机器语言几乎不可能还原成<strong>高级语言</strong></li>
</ul>

<h3 id="toc_4">汇编语言的特点</h3>

<ul>
<li><p>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</p></li>
<li><p>能够不受编译器的限制，对生成的二进制代码进行完全的控制</p></li>
<li><p>目标代码简短，占用内存少，执行速度快</p></li>
<li><p>汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</p></li>
<li><p>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</p></li>
<li><p>不区分大小写，比如mov和MOV是一样的</p></li>
</ul>

<h3 id="toc_5">汇编的用途(哥么我学了能干啥?)</h3>

<ul>
<li>编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li>
<li>对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li>
<li>软件安全
<ul>
<li>病毒分析与防治</li>
<li>逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li>
</ul></li>
<li>理解整个计算机系统的最佳起点和最有效途径</li>
<li>为编写高效代码打下基础</li>
<li>弄清代码的本质
<ul>
<li>函数的本质究竟是什么?</li>
<li>++a + ++a + ++a 底层如何执行的?</li>
<li>编译器到底帮我们干了什么?</li>
<li>DEBUG模式和RELEASE模式有什么关键的地方被我们忽略</li>
<li>......</li>
</ul></li>
</ul>

<p>最后来句装13的话</p>

<blockquote>
<p>越底层越单纯!真正的程序员都需要了解的一门非常重要的语言,汇编!</p>
</blockquote>

<h3 id="toc_6">汇编语言的种类</h3>

<ul>
<li><p>目前讨论比较多的汇编语言有</p>
<ul>
<li>8086汇编（8086处理器是16bit的CPU）</li>
<li>Win32汇编</li>
<li>Win64汇编</li>
<li>ARM汇编（嵌入式、Mac、iOS）</li>
<li>......</li>
</ul></li>
<li><p>我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同.</p></li>
</ul>

<table>
<thead>
<tr>
<th>架构</th>
<th>设备</th>
</tr>
</thead>

<tbody>
<tr>
<td>armv6</td>
<td>iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td>arm64</td>
<td>iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后</td>
</tr>
</tbody>
</table>

<h3 id="toc_7">几个必要的常识</h3>

<ul>
<li>要想学好汇编,首先需要了解CPU等硬件结构</li>
<li>APP/程序的执行过程</li>
</ul>

<p><img src="media/15246450401949/15193672391363.jpg" alt="15193672391363"/></p>

<ul>
<li>硬件相关最为重要是CPU/内存</li>
<li>在汇编中,大部分指令都是和CPU与内存相关的</li>
</ul>

<h3 id="toc_8">总线</h3>

<p><img src="media/15246450401949/15193692496345.jpg" alt="15193692496345"/><br/>
<img src="media/15246450401949/15193692648349.jpg" alt="15193692648349"/></p>

<ul>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互</li>
<li>总线：一根根导线的集合</li>
<li>总线的分类
<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul></li>
</ul>

<p><img src="media/15246450401949/15193693448725.jpg" alt="15193693448725"/></p>

<p><strong>举个例子</strong></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-bfac743167c4e554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来至书上的截图"/></p>

<ul>
<li><strong>地址总线</strong>
<ul>
<li>它的宽度决定了CPU的_寻址能力_</li>
<li>8086的地址总线宽度是_20_，所以寻址能力是_1M_（ 2<sup>20</sup>  ）</li>
</ul></li>
</ul>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-b22c5ebccc4e6a9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<ul>
<li><strong>数据总线</strong>
<ul>
<li>它的宽度决定了CPU的单次数据传送量，也就是数据_传送速度_</li>
<li>8086的数据总线宽度是_16_，所以单次最大传递_2个字节_的数据</li>
</ul></li>
<li><strong>控制总线</strong>
<ul>
<li>它的宽度决定了CPU对其他器件的_控制能力_、能有多少种控制</li>
</ul></li>
</ul>

<p><strong>做个小练习</strong></p>

<ul>
<li>一个CPU 的寻址能力为8KB,那么它的地址总线的宽度为____</li>
<li>8080,8088,80286,80386 的<strong>地址总线</strong>宽度分别为16根,20根,24根,32根.那么他们的寻址能力分别为多少____KB, ____MB,____MB,____GB?</li>
<li>8080,8088,8086,80286,80386 的<strong>数据总线</strong>宽度分别为8根,8根,16根,16根,32根.那么它们一次可以传输的数据为:____B,____B,____B,____B,____B,</li>
<li>从内存中读取1024字节的数据,8086至少要读____次,80386至少要读取____次.</li>
</ul>

<p><strong>答案</strong></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-c9eddd9d28a8cb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="练习"/></p>

<h3 id="toc_9">内存</h3>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-cb3c46652c7bad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储区的逻辑连接"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-49e73b88a2e7af92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储器的逻辑连接-物理地址对应图"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/2990730-d723c11cce5cdaaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储器的物理地址情况"/></p>

<ul>
<li><p>内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2<sup>20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB</sup></p></li>
<li><p>0x00000~0x9FFFF：主存储器。可读可写</p></li>
<li><p>0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写</p></li>
<li><p>0xC0000~0xFFFFF：存储各种硬件\系统信息。只读</p></li>
</ul>

<h2 id="toc_10">进制</h2>

<p><strong>学习进制的障碍</strong></p>

<blockquote>
<p>很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的.<br/>
我们为什么一定要转换十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换.<br/>
每一种进制都是完美的,想学好进制首先要忘掉十进制，也要忘掉进制间的转换！</p>
</blockquote>

<h3 id="toc_11">进制的定义</h3>

<ul>
<li>八进制由8个符号组成:0 1 2 3 4 5 6 7 逢八进一</li>
<li>十进制由10个符号组成:0 1 2 3 4 5 6 7 8 9逢十进一</li>
<li>N进制就是由N个符号组成:逢N进一</li>
</ul>

<h5 id="toc_12">做个练习</h5>

<ul>
<li>1 + 1 在____情况下等于 3 ?</li>
</ul>

<pre><code class="language-思考">.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>

<blockquote>
<p>十进制由10个符号组成: 0 1 3 2 8 A B E S 7 逢十进一</p>
</blockquote>

<p>如果这样定义十进制: 1 + 1 = 3!就对了!</p>

<p><strong>这样的目的何在?</strong><br/>
传统我们定义的十进制和自定义的十进制不一样.那么这10个符号如果我们不告诉别人这个符号表,别人是没办法拿到我们的具体数据的!用于加密!</p>

<blockquote>
<p><strong>十进制</strong>由十个<strong>符号</strong>组成,逢十进一,<strong>符号</strong>是可以<strong>自定义</strong>的!!</p>
</blockquote>

<h3 id="toc_13">进制的运算</h3>

<h5 id="toc_14">做个练习</h5>

<ul>
<li>八进制运算
<ul>
<li>2 + 3 = __ , 2 * 3 = __ ,4 + 5 = __ ,4 * 5 = __.</li>
<li>277 + 333 = __ , 276 * 54 = __ , 237 - 54 = __ , 234 / 4 = __ .</li>
</ul></li>
</ul>

<h5 id="toc_15">八进制加法表</h5>

<pre><code class="language-text"> 0  1  2  3  4  5  6  7 
10 11 12 13 14 15 16 17
20 21 22 23 24 25 26 27
...

1+1 = 2                     
1+2 = 3   2+2 = 4               
1+3 = 4   2+3 = 5   3+3 = 6
1+4 = 5   2+4 = 6   3+4 = 7   4+4 = 10  
1+5 = 6   2+5 = 7   3+5 = 10  4+5 = 11  5+5 = 12
1+6 = 7   2+6 = 10  3+6 = 11  4+6 = 12  5+6 = 13  6+6 = 14
1+7 = 10  2+7 = 11  3+7 = 12  4+7 = 13  5+7 = 14  6+7 = 15  7+7 = 16
</code></pre>

<h5 id="toc_16">八进制乘法表</h5>

<pre><code class="language-text">0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27...
1*1 = 1                     
1*2 = 2   2*2 = 4               
1*3 = 3   2*3 = 6   3*3 = 11    
1*4 = 4   2*4 = 10  3*4 = 14  4*4 = 20
1*5 = 5   2*5 = 12  3*5 = 17  4*5 = 24  5*5 = 31
1*6 = 6   2*6 = 14  3*6 = 22  4*6 = 30  5*6 = 36  6*6 = 44
1*7 = 7   2*7 = 16  3*7 = 25  4*7 = 34  5*7 = 43  6*7 = 52  7*7 = 61
</code></pre>

<h5 id="toc_17">实战四则运算</h5>

<pre><code class="language-text">   277         236         276         234
+  333       -  54       *  54       /   4
--------    --------    --------    --------    
</code></pre>

<h3 id="toc_18">二进制的简写形式</h3>

<pre><code class="language-text">       二进制: 1 0 1 1 1 0 1 1 1 1 0 0
三个二进制一组: 101 110 111 100
       八进制:   5   6   7   4
四个二进制一组: 1011 1011 1100
     十六进制:    b    b    c
</code></pre>

<blockquote>
<p>二进制：从0 写到 1111<br/>
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 <br/>
这种二进制使用起来太麻烦，改成更简单一点的符号：<br/>
0 1 2 3 4 5 6 7 8 9 A B C D E F 这就是十六进制了</p>
</blockquote>

<h3 id="toc_19">数据的宽度</h3>

<p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p>

<pre><code class="language-objectivec">#import &lt;UIKit/UIKit.h&gt;
#import &quot;AppDelegate.h&quot;

int test(){
    int cTemp = 0x1FFFFFFFF;
    return cTemp;
}

int main(int argc, char * argv[]) {
    printf(&quot;%x\n&quot;,test());
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>

<h3 id="toc_20">计算机中常见的数据宽度</h3>

<ul>
<li>位(Bit): 1个位就是1个二进制位.0或者1</li>
<li>字节(Byte): 1个字节由8个Bit组成(8位).内存中的最小单元Byte.</li>
<li>字(Word): 1个字由2个字节组成(16位),这2个字节分别称为高字节和低字节.</li>
<li>双字(Doubleword): 1个双字由两个字组成(32位)</li>
</ul>

<p>那么计算机存储数据它会分为有符号数和无符号数.那么关于这个看图就理解了!<br/>
<img src="media/15246450401949/15178439312380.jpg" alt="15178439312380"/></p>

<pre><code class="language-text">无符号数,直接换算!
有符号数:
正数:  0    1    2    3    4    5    6    7 
负数:  F    E    D    B    C    A    9    8
      -1   -2   -3   -4   -5   -6   -7   -8
</code></pre>

<h3 id="toc_21">自定义进制符号</h3>

<h5 id="toc_22">练习</h5>

<ul>
<li>现在有10进制数 10个符号分别是：2，9，1，7，6，5，4， 8，3 , A 逢10进1 那么： 123 + 234 = ____</li>
</ul>

<pre><code class="language-text">
十进制:    0  1  2  3  4  5  6  7  8  9
自定义:    2  9  1  7  6  5  4  8  3  A
         92 99 91 97 96 95 94 98 93 9A
         12 19 11 17 16 15 14 18 13 1A
         72 79 71 77 76 75 74 78 73 7A
         62 69 61 67 66 65 64 68 63 6A
         52 59 51 57 56 55 54 58 53 5A
         42 49 41 47 46 45 44 48 43 4A
         82 89 81 87 86 85 84 88 83 8A
         32 39 31 37 36 35 34 38 33 3A
         922
</code></pre>

<p>那么刚才通过10进制运算可以转化10进制然后查表!但是如果是其他进制.我们就不能转换,要直接学会查表</p>

<ul>
<li>现在有9进制数 9个符号分别是：2，9，1，7，6，5，4， 8，3 逢9进1 那么： 123 + 234 = ____</li>
</ul>

<pre><code class="language-text">
十进制:    0  1  2  3  4  5  6  7  8  
自定义:    2  9  1  7  6  5  4  8  3  
         92 99 91 97 96 95 94 98 93 
         12 19 11 17 16 15 14 18 13 
         72 79 71 77 76 75 74 78 73 
         62 69 61 67 66 65 64 68 63 
         52 59 51 57 56 55 54 58 53 
         42 49 41 47 46 45 44 48 43 
         82 89 81 87 86 85 84 88 83 
         32 39 31 37 36 35 34 38 33 
         922
</code></pre>

<h3 id="toc_23">寄存器</h3>

<p><strong>内部部件之间由总线连接</strong><br/>
<img src="media/15246450401949/15193738988252.jpg" alt="15193738988252"/></p>

<ul>
<li>对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制</li>
<li>不同的CPU，寄存器的个数、结构是不相同的</li>
</ul>

<h3 id="toc_24">通用寄存器</h3>

<ul>
<li><p>ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）</p>
<ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!</li>
</ul>
<p><img src="media/15246450401949/15193699098685.jpg" alt="15193699098685"/></p></li>
<li><p>通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算</p></li>
<li><p>假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间<br/>
<img src="media/15246450401949/15193738988252.jpg" alt="15193738988252"/></p>
<ul>
<li>CPU首先会将红色内存空间的值放到X0寄存器中：mov X0,红色内存空间</li>
<li>然后让X0寄存器与1相加：add X0,1</li>
<li>最后将值赋值给内存空间：mov 蓝色内存空间,X0</li>
</ul></li>
</ul>

<h3 id="toc_25">pc寄存器(program counter)</h3>

<ul>
<li>为指令指针寄存器，它指示了CPU当前要读取指令的地址</li>
<li>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</li>
<li>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
<ul>
<li>比如 1110 0000 0000 0011 0000 1000 1010 1010 </li>
<li>可以当做数据   0xE003008AA </li>
<li>也可以当做指令  mov    x0, x8</li>
</ul></li>
<li>CPU根据什么将内存中的信息看做指令？
<ul>
<li>CPU将pc指向的内存单元的内容看做指令</li>
<li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li>
</ul></li>
</ul>

<h3 id="toc_26">bl指令</h3>

<ul>
<li>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令</li>
<li>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如
<ul>
<li>mov x0,#10、mov x1,#20</li>
</ul></li>
<li><p>但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p></li>
<li><p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p></li>
</ul>

<h3 id="toc_27">bl指令 -- 练习</h3>

<p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p>

<pre><code class="language-text">_A:
    mov x0,#0xa0
    mov x1,#0x00
    add x1, x0, #0x14
    mov x0,x1
    bl _B
    mov x0,#0x0
    ret

_B:
    add x0, x0, #0x10
    ret
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html'>逆向与安全</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15245531347178.html">
                
                  <h1>MonkeyDev</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>安装 MonkeyDev <br/>
<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85">https://github.com/AloneMonkey/MonkeyDev/wiki/安装</a></p>
</blockquote>

<ol>
<li>安装最新的theos</li>
</ol>

<pre><code class="language-text">$ sudo git clone --recursive https://github.com/theos/theos.git /opt/theos
</code></pre>

<ol>
<li>安装ldid(如安装theos过程安装了ldid，跳过)</li>
</ol>

<pre><code class="language-text">$ brew install ldid
</code></pre>

<ol>
<li>执行安装MonkeyDev命令</li>
</ol>

<pre><code class="language-text">$ sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot;
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15242338446694.html">
                
                  <h1>Cycript 安装及使用</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>Cycript允许开发人员通过交互式控制台，使用Objective-C ++和JavaScript语法的混合，在iOS或Mac OS X上检测和修改正在运行的应用程序。</p>
</blockquote>

<h3 id="toc_0">1. 安装 cycript</h3>

<p>下载 SDK ，将下载好的文件解压到 <code>磁盘/opt</code>目录下<br/>
<a href="http://www.cycript.org/">http://www.cycript.org/</a></p>

<p><img src="media/15242338446694/15242351239079.jpg" alt=""/></p>

<h3 id="toc_1">2. 配置环境变量</h3>

<h5 id="toc_2">1、 创建或打开 <code>.bash_profile</code> 文件</h5>

<p><code>cd</code> 到当前用户目录下 <code>cd ~</code> ，执行：</p>

<pre><code class="language-text">$ vim .bash_profile
</code></pre>

<h5 id="toc_3">2、 增加cycript的绝对路径</h5>

<pre><code class="language-text">export cycript_path=&quot;/opt/cycript_0.9.594&quot;
PATH=$PATH:$cycript_path
</code></pre>

<h5 id="toc_4">3、 更新刚配置的环境变量</h5>

<pre><code class="language-text">$ source .bash_profile 
</code></pre>

<p>此外，打开<code>vim .zshrc</code> 将 <code>.bash_profile</code> 加入 （适用iterm2 zsh组合）<code>source .bash_profile</code></p>

<h5 id="toc_5">4、 验证配置是否成功，若终端输出 <code>cy#</code> 表示成功</h5>

<pre><code class="language-text">$ cycript
# cy
</code></pre>

<h3 id="toc_6">3. 使用</h3>

<h5 id="toc_7">1、安装 <a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85">MonkeyDev</a> 运行app</h5>

<h5 id="toc_8">2、使用<code>Cycript</code>连接到已运行手机上的app</h5>

<pre><code class="language-text">cycript [-c] [-p &lt;pid|name&gt;] [-r &lt;host:port&gt;] [&lt;script&gt; [&lt;arg&gt;...]]

例如：
cycript -r 10.10.3.145
</code></pre>

<h5 id="toc_9">3、 命令语法使用</h5>

<p><a href="http://www.cycript.org/manual/#4dd1ca6b-2bd5-48e4-a0ee-06b0947880f5">manual</a></p>

<h3 id="toc_10">4. 问题</h3>

<h5 id="toc_11">1、执行<code>$ cycript</code>出现以下情况：</h5>

<pre><code class="language-text">dyld: Library not loaded: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib
  Referenced from: /opt/cycript_0.9.594/Cycript.lib/cycript-apl
  Reason: image not found
</code></pre>

<p>此情况为电脑的 ruby 版本太高 大于 <code>2.0</code><br/>
查看ruby版本 <code>$ ruby -v</code></p>

<p>解决： 创建Ruby2.0版本文件，并将2.3版本文件拷贝到2.0中</p>

<pre><code class="language-text">$ sudo mkdir -p /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/
$ sudo ln -s /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/libruby.2.3.0.dylib /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib
</code></pre>

<h5 id="toc_12">2、<code>sudo mkdir</code> 出现权限问题，关闭SIP,关闭详情请参考 <a href="https://caolongs.github.io/2018/04/XtraFinder-%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4(SIP)/">系统完整性保护(SIP)</a></h5>

<pre><code class="language-text">mkdir: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib: Operation not permitted
</code></pre>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15241488811717.html">
                
                  <h1>XtraFinder</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p><a href="https://www.trankynam.com/xtrafinder/">https://www.trankynam.com/xtrafinder/</a></p>

<p>在早期的OS X上，只需打开XtraFinderInstaller即可安装XtraFinder。</p>

<p>从OS X 10.11开始，系统完整性保护会阻止代码注入（以及其他许多事情）。<br/>
XtraFinder的工作原理是将其代码注入Finder应用程序进程。<br/>
为了安装XtraFinder，您需要禁用系统完整性保护。<br/>
XtraFinder安装完成后，您可以重新启用系统完整性保护。</p>

<p>有关系统完整性保护的更多信息，请访问此页<a href="http://www.trankynam.com/xtrafinder/sip.html">http://www.trankynam.com/xtrafinder/sip.html</a></p>

<h3 id="toc_0">1、第一次安装XtraFinder的步骤</h3>

<p>1.禁用系统完整性保护。<br/>
2.打开XtraFinderInstaller安装XtraFinder。<br/>
3.重新启用系统完整性保护。</p>

<h3 id="toc_1">2、更新XtraFinder</h3>

<p>您不需要重复安装过程。<br/>
只需将XtraFinder复制到/ Applications目录即可。</p>

<h3 id="toc_2">3、无需打开XtraFinderInstaller即可手动安装</h3>

<p>1.将<code>Extra</code>目录中的<code>XtraFinderInjector.osax</code>复制到<code>/System/Library/ScriptingAdditions</code><br/>
2.将<code>XtraFinder</code>复制到<code>/Applications</code></p>

<h3 id="toc_3">4、禁用系统完整性保护的步骤</h3>

<p>1.通过重新启动计算机并在启动时按住<code>Command和R</code>键启动到恢复操作系统。<br/>
2.从 Utilities 菜单启动 Terminal。<br/>
3.输入以下命令：<code>csrutil disable</code><br/>
4.重新启动电脑。</p>

<h3 id="toc_4">5、将系统完整性保护恢复到原始状态：</h3>

<p>启动到恢复操作系统并输入以下命令：<code>csrutil clear</code></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15241480672826.html">
                
                  <h1>XtraFinder 系统完整性保护(SIP)</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p><a href="http://www.trankynam.com/xtrafinder/sip.html">XtraFinder 系统完整性保护原文</a>（译）</p>

<h3 id="toc_0">1、关于OS X 10.11中的系统完整性保护</h3>

<p><a href="https://support.apple.com/en-us/HT204899">苹果的文章</a>。<br/>
系统完整性保护阻止代码注入（以及其他许多事情）。</p>

<p>XtraFinder的工作原理是将其代码注入Finder应用程序进程。</p>

<h3 id="toc_1">2、如何让XtraFinder在OS X 10.11中工作</h3>

<p>您需要部分禁用系统完整性保护。</p>

<p>我不鼓励您禁用系统完整性保护。它会让你的电脑不安全。</p>

<h3 id="toc_2">3、如何部分禁用系统完整性保护</h3>

<p>参考这篇<a href="https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html">苹果的文章</a>。</p>

<p>按着这些次序：</p>

<h5 id="toc_3">1. 通过重新启动计算机并在启动时按住<code>Command+R</code>键启动到恢复操作系统。</h5>

<h5 id="toc_4">2. 从 Utilities 菜单启动 Terminal。</h5>

<h5 id="toc_5">3. 输入以下命令：<code>csrutil enable --without debug</code></h5>

<h5 id="toc_6">4. 重新启动您的计算机。</h5>

<h3 id="toc_7">4、“csrutil enable --without debug” 命令的作用是什么？</h3>

<p>它允许代码注入。这意味着XtraFinder可以将其代码注入Finder应用程序进程。</p>

<h3 id="toc_8">5、如何将系统完整性保护恢复到原始状态</h3>

<p>启动到恢复操作系统并输入以下命令：<code>csrutil clear</code></p>

<p>完全禁用SIP <code>csrutil disable</code><br/>
启用SIP <code>csrutil enable</code></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15241412696951.html">
                
                  <h1>Go2Shell and AppleScript</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>给Finder加上一个打开当前路径的终端的功能</p>

<p>有两种实现：<br/>
Go2Shell App 和 AppleScript</p>

<p><strong>扩展：</strong></p>

<p>AppleScript 实现 Go2Shell 一样的可视化打开方式</p>
</blockquote>

<h2 id="toc_0">一、 Go2Shell</h2>

<h3 id="toc_1">1. 安装</h3>

<p>1、Go2Shell官方安装 （推荐，因为AppStore下载的版本太低，无法打开iTerm2 -坑-）<br/>
<a href="http://zipzapmac.com/Go2Shell">http://zipzapmac.com/Go2Shell</a> </p>

<p>2、<a href="https://itunes.apple.com/cn/app/go2shell/id445770608?mt=12">AppStore下载</a></p>

<p><img src="media/15241412696951/15241416276817.jpg" alt=""/></p>

<p>至此就可以打开shell，不过仅仅是打开系统默认的终端shell</p>

<h3 id="toc_2">2. 进入 Preferences 的方式</h3>

<pre><code class="language-text">open -a Go2Shell --args config
</code></pre>

<p><img src="media/15241412696951/15241419447692.jpg" alt=""/></p>

<p>iTerm2 不能打开当前文件所在目录（）</p>

<h3 id="toc_3">3. 官网下载效果图(多了个 <code>&gt;_&lt;</code> 能直接打开配置)</h3>

<p><img src="media/15241412696951/15241460616684.jpg" alt=""/></p>

<h2 id="toc_4">二、配置 Automator 方法</h2>

<h3 id="toc_5">1. 新建 Automator 服务</h3>

<p>打开<code>Automator</code>，选择<code>新建</code>，选择<code>服务</code></p>

<h3 id="toc_6">2. 设置 Automator 服务</h3>

<h5 id="toc_7">1、 服务接受设为没有输入，位置设为<code>Finder(访达)</code></h5>

<p><img src="media/15241412696951/15241426742785.jpg" alt=""/></p>

<h5 id="toc_8">2、 从左侧的资源库中找出 运行 <code>AppleScript</code>，拖到右侧，然后保存为<code>Open iTerm Here</code></h5>

<p><img src="media/15241412696951/15241444900342.jpg" alt=""/></p>

<blockquote>
<p>复制以下代码</p>

<p>代码意思是将当前最前面的Finder地址如果获取不到，则返回桌面地址然后通知iTerm的第一个窗口新建标签并跳到这个目录去</p>
</blockquote>

<pre><code class="language-text">on run {input, parameters}

    tell application &quot;Finder&quot;

        set pathList to (quoted form of POSIX path of (folder of the front window as alias))

        set command to &quot;clear; cd &quot; &amp; pathList

    end tell


    tell application &quot;System Events&quot;

        -- some versions might identify as &quot;iTerm2&quot; instead of &quot;iTerm&quot;

        set isRunning to (exists (processes where name is &quot;iTerm&quot;)) or (exists (processes where name is &quot;iTerm2&quot;))

    end tell


    tell application &quot;iTerm&quot;

        activate

        set hasNoWindows to ((count of windows) is 0)

        if isRunning and hasNoWindows then

            create window with default profile

        end if

        select first window


        tell the first window

            if isRunning and hasNoWindows is false then

                create tab with default profile

            end if

            tell current session to write text command

        end tell

    end tell


end run


</code></pre>

<h5 id="toc_9">3、点击运行就能在 iTerm2 中打开当前目录</h5>

<p><img src="media/15241412696951/15241432094154.jpg" alt=""/></p>

<h5 id="toc_10">4、 设置快捷键</h5>

<p>打开系统设置，再去键盘设置里改一下快捷键，然后就可以快速在Finder中通过iTerm打开当前目录了<br/>
<img src="media/15241412696951/15241437705558.jpg" alt=""/></p>

<h2 id="toc_11">三、扩展</h2>

<h3 id="toc_12">Automator 创建应用</h3>

<p>使用的 Automator AppleScript 时候就在想为什么使用创建的服务，好吧，换个思路创建个应用，尝试着以Go2Shell的方式按住<code>command</code>键拖到文件夹上，结果和Go2Shell实现的效果一样OK，对 Automator 的使用充满期望~~<br/>
<img src="media/15241412696951/15241470137311.jpg" alt=""/></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15240395407492.html">
                
                  <h1>iTerm2</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>强大的 Mac OS 终端利器，跟着教程走了一遍。</p>

<h3 id="toc_0">1. 安装 iTerm2</h3>

<p>下载地址：<a href="https://www.iterm2.com/downloads.html">https://www.iterm2.com/downloads.html</a><br/>
下载的是压缩文件，解压后是执行程序文件，你可以直接双击，或者直接将它拖到 Applications 目录下。</p>

<p>或者你可以直接使用 Homebrew 进行安装：</p>

<pre><code class="language-text">$ brew cask install iterm2
</code></pre>

<h3 id="toc_1">2. 配置 iTerm2 主题</h3>

<p>iTerm2 最常用的主题是 Solarized Dark theme，下载地址：<a href="http://ethanschoonover.com/solarized">http://ethanschoonover.com/solarized</a></p>

<p>下载的是压缩文件，你先解压一下，然后打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后 <code>Profiles -&gt; Colors -&gt; Color Presets -&gt; Import</code>，选择刚才解压的<code>solarized-&gt;iterm2-colors-solarized-&gt;Solarized Dark.itermcolors</code>文件，导入成功，最后选择 Solarized Dark 主题，就可以了。<br/>
<img src="media/15240236247092/15240328372916.jpg" alt=""/></p>

<h3 id="toc_2">3. 配置 Oh My Zsh</h3>

<p>Oh My Zsh 是对主题的进一步扩展，地址：<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p>

<p>一键安装：</p>

<pre><code class="language-text">$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>

<p>安装好之后，需要把 Zsh 设置为当前用户的默认 Shell（这样新建标签的时候才会使用 Zsh）：</p>

<pre><code class="language-text">$ chsh -s /bin/zsh
</code></pre>

<p>然后，我们编辑<code>vim ~/.zshrc</code>文件，将主题配置修改为<code>ZSH_THEME=&quot;agnoster&quot;</code>。</p>

<p><img src="media/15240236247092/15240328878602.jpg" alt=""/><br/>
<code>agnoster</code>是比较常用的 zsh 主题之一，你可以挑选你喜欢的主题，zsh 主题列表：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a></p>

<h3 id="toc_3">4. 配置 Meslo 字体</h3>

<p>使用上面的主题，需要 Meslo 字体支持，要不然会出现乱码的情况，字体下载地址：<a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo LG M Regular for Powerline.ttf</a></p>

<p>下载好之后，直接在 Mac OS 中安装即可。</p>

<p>然后打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles -&gt; Text -&gt; Font -&gt; Chanage Font，选择 Meslo LG M Regular for Powerline</code> 字体。<br/>
<img src="media/15240236247092/15240335911662.jpg" alt=""/></p>

<p>效果：<br/>
<img src="media/15240236247092/15240336572945.jpg" alt=""/></p>

<h3 id="toc_4">5. 声明高亮</h3>

<p>特殊命令和错误命令，会有高亮显示。</p>

<p>使用 Homebrew 安装：</p>

<pre><code class="language-text">$ brew install zsh-syntax-highlighting
</code></pre>

<p>安装成功之后，编辑<code>vim ~/.zshrc</code>文件，在最后一行增加下面配置：</p>

<pre><code class="language-text">source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
</code></pre>

<p><img src="media/15240236247092/15240338613185.jpg" alt=""/></p>

<p>特殊命令和错误命令，会有高亮显示效果：<br/>
<img src="media/15240236247092/15240346220825.jpg" alt=""/></p>

<h3 id="toc_5">6. 自动建议填充</h3>

<p>这个功能是非常实用的，可以方便我们快速的敲命令。</p>

<p>配置步骤，先克隆<code>zsh-autosuggestions</code>项目，到指定目录：</p>

<pre><code class="language-text">$ git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions
</code></pre>

<p>然后编辑<code>vim ~/.zshrc</code>文件，找到plugins配置，增加<code>zsh-autosuggestions</code>插件。<br/>
<img src="media/15240236247092/15240340214194.jpg" alt=""/><br/>
<mark>注：</mark>上面声明高亮，如果配置不生效的话，在plugins配置，再增加zsh-syntax-highlighting插件试试。<br/>
有时候因为自动填充的颜色和背景颜色很相似，以至于自动填充没有效果，我们可以手动更改下自动填充的颜色配置</p>

<h3 id="toc_6">7. 左右键跳转</h3>

<p>主要是按住<code>option + → or ←</code>键，在命令的开始和结尾跳转切换，原本是不生效的，需要手动开启下。</p>

<p>打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles → Keys → Load Preset... → Natural Text Editing</code>，就可以了。</p>

<h3 id="toc_7">8. iTerm2 快速隐藏和显示</h3>

<p>这个功能也非常使用，就是通过快捷键，可以快速的隐藏和打开 iTerm2，示例配置（<code>Commond + .</code>）：<br/>
<img src="media/15240236247092/15240344213280.jpg" alt=""/></p>

<h3 id="toc_8">9. iTerm2 隐藏用户名和主机名</h3>

<p>有时候我们的用户名和主机名太长，比如我的<code>caolongjian@caolongjiandeMacBook-Pro</code>，终端显示的时候会很不好看（上面图片中可以看到），我们可以手动去除。</p>

<p>编辑<code>vim ~/.zshrc</code>文件，增加<code>DEFAULT_USER=&#39;caolongjian&#39;</code>配置，示例：</p>

<p><img src="media/15240236247092/15240353400543.jpg" alt=""/><br/>
注意： 使用单引号 或者 DEFAULT_USER 放在 ZSH_THEME上面 否则 DEFAULT_USER 不生效<br/>
<img src="media/15240236247092/15240357531048.jpg" alt=""/></p>

<p>效果：<br/>
<img src="media/15240236247092/15240358493334.jpg" alt=""/></p>

<h3 id="toc_9">10. iTerm2 配置代理</h3>

<p>编辑~ vim ~/.zshrc，增加下面配置（使用的 shadowsocks）：</p>

<pre><code class="language-text"># proxy list
alias proxy=&#39;export all_proxy=socks5://127.0.0.1:1086&#39;
alias unproxy=&#39;unset all_proxy&#39;
</code></pre>

<p>iTerm2 需要新建标签页，才有效果：</p>

<pre><code class="language-text">$ proxy
$ curl ip.cn
当前 IP：185.225.14.5 来自：美国

$ unproxy
$ curl ip.cn
当前 IP：115.236.186.130 来自：浙江省杭州市 电信
</code></pre>

<h3 id="toc_10">11. iTerm2 快捷命令</h3>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">command + t</td>
<td style="text-align: left">新建标签</td>
</tr>
<tr>
<td style="text-align: left">command + w</td>
<td style="text-align: left">关闭标签</td>
</tr>
<tr>
<td style="text-align: left">command + 数字 command + 左右方向键</td>
<td style="text-align: left">切换标签</td>
</tr>
<tr>
<td style="text-align: left">command +</td>
<td style="text-align: left">enter 切换全屏</td>
</tr>
<tr>
<td style="text-align: left">command + f</td>
<td style="text-align: left">查找</td>
</tr>
<tr>
<td style="text-align: left">command + d</td>
<td style="text-align: left">垂直分屏</td>
</tr>
<tr>
<td style="text-align: left">command + shift + d</td>
<td style="text-align: left">水平分屏</td>
</tr>
<tr>
<td style="text-align: left">command + option +</td>
<td style="text-align: left">方向键</td>
</tr>
<tr>
<td style="text-align: left">command + [ 或 command + ]</td>
<td style="text-align: left">切换屏幕</td>
</tr>
<tr>
<td style="text-align: left">command + ;</td>
<td style="text-align: left">查看历史命令</td>
</tr>
<tr>
<td style="text-align: left">command + shift + h</td>
<td style="text-align: left">查看剪贴板历史</td>
</tr>
<tr>
<td style="text-align: left">ctrl + u</td>
<td style="text-align: left">清除当前行</td>
</tr>
<tr>
<td style="text-align: left">ctrl + l</td>
<td style="text-align: left">清屏</td>
</tr>
<tr>
<td style="text-align: left">ctrl + a</td>
<td style="text-align: left">到行首</td>
</tr>
<tr>
<td style="text-align: left">ctrl + e</td>
<td style="text-align: left">到行尾</td>
</tr>
<tr>
<td style="text-align: left">ctrl + f/b</td>
<td style="text-align: left">前进后退</td>
</tr>
<tr>
<td style="text-align: left">ctrl + p</td>
<td style="text-align: left">上一条命令</td>
</tr>
<tr>
<td style="text-align: left">ctrl + r</td>
<td style="text-align: left">搜索命令历史</td>
</tr>
<tr>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
</tr>
</tbody>
</table>

<h3 id="toc_11">参考</h3>

<p><a href="http://www.cnblogs.com/xishuai/p/mac-iterm2.html">Mac OS 终端利器 iTerm2</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15240236247092.html">
                
                  <h1>Alfred</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>强大的只能搜索软件，w安全可以替代OS X自带的Spotlight</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7.html'>工具</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15240154214361.html">
                
                  <h1>Block用法和实现原理</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">Block 概念</h3>

<blockquote>
<p>闭包 = 一个函数「或指向函数的指针」+ 该函数执行的外部的上下文变量「也就是自由变量」；<br/>
Block 是 Objective-C 对于闭包的实现。</p>

<p>其中，Block：</p>

<ul>
<li>可以嵌套定义，定义 Block 方法和定义函数方法相似</li>
<li>Block 可以定义在方法内部或外部</li>
<li>只有调用 Block 时候，才会执行其{}体内的代码</li>
<li>本质是对象，使代码高聚合</li>
</ul>
</blockquote>

<h3 id="toc_1">Block 格式</h3>

<h5 id="toc_2">1. Block的定义格式</h5>

<pre><code class="language-text">返回值类型 (^block变量名)(形参列表) = ^(形参列表) {

};
</code></pre>

<p><img src="media/15240154214361/15240178321653.jpg" alt=""/></p>

<h5 id="toc_3">2. Block表达式语法(等号后是表达式语法)</h5>

<blockquote>
<p>^ 返回值类型 (参数列表) {表达式}</p>
</blockquote>

<pre><code class="language-text">^ int (int count) {
        return count + 1;
    };
</code></pre>

<p>其中，可省略部分有：返回类型(上图为省略返回类型)</p>

<pre><code class="language-text">^ (int count) {
        return count + 1;
    };
</code></pre>

<p>参数列表为空，则可省略，例：</p>

<pre><code class="language-text">^ {
        NSLog(@&quot;No Parameter&quot;);
    };
</code></pre>

<p>即表达式最简模式语法为：</p>

<pre><code class="language-text"> ^ {表达式}
</code></pre>

<h5 id="toc_4">3. Block使用</h5>

<blockquote>
<p>1、 无参数，无返回值，声明和定义</p>
</blockquote>

<pre><code class="language-text">void(^MyBlockOne)(void) = ^(void){

NSLog(@&quot;无参数，无返回值&quot;);  

};  
MyBlockOne();//block的调用
</code></pre>

<blockquote>
<p>2、有参数无返回值</p>
</blockquote>

<pre><code class="language-text">void(^MyblockTwo)(int a) = ^(int a){

NSLog(@&quot;@ = %d我就是block，有参数，无返回值&quot;,a);

  };  
MyblockTwo(100);
</code></pre>

<blockquote>
<p>3、有参数有返回值</p>
</blockquote>

<pre><code class="language-text">int(^MyBlockThree)(int, int) = ^(int a, int b){    

  NSLog(@&quot;%d我就是block，有参数，有返回值&quot;,a + b);
  returna + b; 

 };  
MyBlockThree(12,56);
</code></pre>

<blockquote>
<p>4、有参数有返回值</p>
</blockquote>

<pre><code class="language-text">int(^MyblockFour)(void) = ^{
    NSLog(@&quot;无参数，有返回值&quot;);
    return45;
  };
MyblockFour();
</code></pre>

<blockquote>
<p>5、实际开发中常用typedef 定义Block</p>
</blockquote>

<pre><code class="language-text">//用typedef定义一个block：
typedef int (^MyBlock)(int, int);

//定义类的属性
@property (nonatomic, copy) MyBlock myBlockOne;

//使用
self.myBlockOne = ^int (int ,int){
    //...
}

</code></pre>

<h5 id="toc_5">4. Block与外界变量</h5>

<blockquote>
<p>全局块(_NSConcreteGlobalBlock)<br/>
栈块(_NSConcreteStackBlock)<br/>
堆块(_NSConcreteMallocBlock) （ARC下引入外界变量）</p>
</blockquote>

<h6 id="toc_6">不使用 __block</h6>

<p>1、 创建 .c 文件</p>

<pre><code class="language-text">int main(){
    
    int a = 10;
    void (^block)(void) = ^{

        printf(&quot;%d&quot;,a);
        printf(&quot;test block\n&quot;);

    };
    block();
    return 0;
}
</code></pre>

<p>2、编译</p>

<pre><code class="language-text">$ gcc testBlock.c
</code></pre>

<p>生成可执行文件 a.out<br/>
3、执行</p>

<pre><code class="language-text">$./a.out testBlock.c 
</code></pre>

<ol>
<li>使用clang 生成 c++ 文件<br/></li>
</ol>

<pre><code class="language-text">$ clang -rewrite-objc testBlock.c
</code></pre>

<p>c++ 文件  内容</p>

<pre><code class="language-text">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int a = __cself-&gt;a; // bound by copy
// 生成一个新的值

        printf(&quot;%d&quot;,a);
  printf(&quot;test block\n&quot;);

 }

//......

int main(){

    int a = 10;
 void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));
 ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
 return 0;
}
</code></pre>

<h6 id="toc_7">使用 __block</h6>

<pre><code class="language-text">int main(){
    
    __block int a = 10;
    void (^block)(void) = ^{

        printf(&quot;%d&quot;,a);
        printf(&quot;test block\n&quot;);

    };
    block();
    return 0;
}
</code></pre>

<p>步骤同上，生成 c++ 文件</p>

<pre><code class="language-text">
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref
// 指针

        printf(&quot;%d&quot;,(a-&gt;__forwarding-&gt;a));
  printf(&quot;test block\n&quot;);

 }
 
 //......

int main(){
//声明的变量由栈 copy 到堆，并将指针传递给block
    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 10};
 void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));
 ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
 return 0;
}
</code></pre>

<h1 id="toc_8">文章目录</h1>

<ul>
<li>
<a href="#toc_0">Block 概念</a>
</li>
<li>
<a href="#toc_1">Block 格式</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_2">1. Block的定义格式</a>
</li>
<li>
<a href="#toc_3">2. Block表达式语法(等号后是表达式语法)</a>
</li>
<li>
<a href="#toc_4">3. Block使用</a>
</li>
<li>
<a href="#toc_5">4. Block与外界变量</a>
<ul>
<li>
<a href="#toc_6">不使用 __block</a>
</li>
<li>
<a href="#toc_7">使用 __block</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_8">文章目录</a>


<p>参考：<br/>
<a href="https://zhongjcbill.gitbooks.io/ios/oc/Block%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html">Block基本概念</a><br/>
<a href="https://juejin.im/entry/588075132f301e00697f18e0">iOS Block 详解</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15215981447516.html">
                
                  <h1>架构模式 MVC MVP MVVM</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>架构模式，也叫架构风格，一个架构模式描述软件系统里的基本的结构组织或纲要。架构模式提供一些呈先定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。一个架构模式常常可以分解成很多个设计模式的联合使用。MVC模式就属于架构模式。</p>
</blockquote>

<p>本文就 iOS 中使用 MVC、MVP、MVVM 架构模式表述个人见解。详细使用方法请参见 <a href="https://github.com/Caolongs/MVVM-Part">GitHub Demo</a></p>

<h3 id="toc_0">MVC</h3>

<p>MVC 作为iOS开发中较为原始基本的架构模式，它把软件系统分为三个基本的部分：模型Model、视图View以及控制器Controller。这种模式的目的是为了实现一种动态的程序设计，简化后续对软件系统的修改和扩展，并使得程序的某一部分的复用成为可能。在此不做过多的解释，附图一张：</p>

<p><img src="media/15215981447516/15216155291063.jpg" alt=""/></p>

<h3 id="toc_1">MVP</h3>

<p>MVP 架构模式是 MVC 的一个变种，本人认为 MVC 与 MVP 两者之间最大的区别就是 MVP 中使用Presenter 对 View 和 Model 进行了解耦，View 中不会直接持有 Model 数据，之间的值传递都通过 Presenter 进行传递，换言之，Presenter 持有 View 和 Model，在其内部进行逻辑处理，并将处理后的结果直接传递给 View 显示。</p>

<p><img src="media/15215981447516/15216176099173.jpg" alt=""/></p>

<ul>
<li>当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理</li>
<li>视图向外界暴露接口，当需要更新视图时， Presenter 通过视图暴露的接口更新视图的内容</li>
<li>Presenter 持有模型并负责对模型进行操作和更新，在需要时取出其中存储的信息</li>
<li>当模型层改变时，可以将改变的信息发送给 Presenter</li>
</ul>

<h3 id="toc_2">MVVM</h3>

<p>MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来。<br/>
使用 MVVM 架构模式开发的关键点在于 ViewModel 和 View 的双向绑定机制，View 的变动，自动反映在 ViewModel，反之，ViewModel 的改变能够通知到 View。</p>

<p><img src="media/15215981447516/15216186538894.jpg" alt=""/></p>

<p>Demo 中采用绑定关系为，view 的改变通过调用 ViewModel 暴露的方法进行修改；ViewModel 的改变通过 KVO 监听来将变化的值传递给 View 进行展示。</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%B6%E6%9E%84.html'>架构</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15212766930412.html">
                
                  <h1>OpenGL ES - - GLKit（GLKBaseEffect）</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>Speed up OpenGL ES or OpenGL app development. Use math libraries, background texture loading, pre-created shader effects, and a standard view and view controller to implement your rendering loop.<br/>
加快OpenGL ES或OpenGL应用程序开发。 使用数学库，背景纹理加载，预先创建的着色器效果以及标准视图和视图控制器来实现渲染循环。</p>
</blockquote>

<p><img src="media/15212766930412/GLKit.png" alt="GLKit"/></p>

<h3 id="toc_0">以一个简单的案例来使用 GLKBaseEffect</h3>

<blockquote>
<p>GLKBaseEffect is designed to simplify visual effects common to many OpenGL applications today. <br/>
 GLKBaseEffect旨在简化当今许多OpenGL应用程序常见的视觉效果。</p>

<p>GLKBaseEffect is program based and, with the binding of its underlying GLSL program<br/>
GLKBaseEffect是基于程序的，并且通过其基础GLSL程序的绑定</p>

<p>GLKBaseEffect requires at least an OpenGL Core Profile.  An appropriate context must be created and made current prior to instantiating and initializing GLKBaseEffect objects.</p>
</blockquote>

<h4 id="toc_1">使用GLKBaseEffect的规范步骤是</h4>

<ul>
<li><p>(1) 分配并初始化GLKBaseEffect的一个实例</p>
<pre><code class="language-text">directionalLightEffect = [[GLKBaseEffect alloc] init];
</code></pre></li>
<li><p>(2) 在效果上设置所需的属性</p>
<pre><code class="language-text"> // Configure light0
  directionalLightEffect.light0.position = lightPosition;<br/>
  directionalLightEffect.light0.diffuseColor = diffuseColor;<br/>
  directionalLightEffect.light0.ambientColor = ambientColor;<br/>
  // Configure material<br/>
  directionalLightEffect.material.diffuseColor = materialDiffuseColor;<br/>
  directionalLightEffect.material.ambientColor = materialAmbientColor;<br/>
  directionalLightEffect.material.specularColor = materialSpecularColor;<br/>
  directionalLightEffect.material.shininess = 10.0;
</code></pre></li>
<li><p>(3) 优选用顶点数组对象初始化顶点属性/顶点数组状态为要绘制的模型或场景</p>
<pre><code class="language-text">    glGenVertexArraysOES(1, &amp;vaoName);
    glBindVertexArrayOES(vaoName);<br/>
  // 为每个顶点属性创建并初始化VBO<br/>
  // 下面的例子展示了一个设置位置顶点属性的例子.<br/>
  // 为每个额外的所需属性重复以下步骤：normal，color，texCoord0，texCoord1.<br/>
  glGenBuffers(1, &amp;positionVBO);<br/>
  glBindBuffer(GL_ARRAY_BUFFER, positionVBO);<br/>
  glBufferData(GL_ARRAY_BUFFER, vboSize, dataBufPtr, GL_STATIC_DRAW);<br/>
  glVertexAttribPointer(GLKVertexAttribPosition, size, type, normalize, stride, NULL);<br/>
  glEnableVertexAttribArray(GLKVertexAttribPosition);<br/>
  ...针对其他所需的顶点属性重复上述步骤<br/>
  glBindVertexArrayOES(0);   // unbind the VAO we created above
</code></pre></li>
<li><p>(4) 对于每个绘制的帧：更新每帧更改的属性。 通过调用 - [GLKBaseEffect prepareToDraw] 同步更改的效果状态。用效果画出模型.  用效果画出模型</p>
<pre><code class="language-text">    directionalLightEffect.transform.modelviewMatrix = modelviewMatrix;
    [directionalLightEffect prepareToDraw];<br/>
    glBindVertexArrayOES(vaoName);<br/>
    glDrawArrays(GL_TRIANGLE_STRIP, 0, vertCt);
</code></pre></li>
</ul>

<p>详细代码：<a href="https://github.com/Caolongs/OpenGL-ES---GLKit">DEMO</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15211019198288.html">
                
                  <h1>OpenGL ES - GLSL</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>不采用GLKBaseEffect，使用编译链接自定义的着色器（shader）。用简单的glsl语言来实现顶点、片元着色器，并图形进行简单的变换。</p>

<p><img src="media/15211019198288/OpenGL%20ES%20-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8-.png" alt="OpenGL ES -自定义的着色器-"/></p>

<h3 id="toc_0">一、创建图层</h3>

<p><code>CAEAGLLayer</code></p>

<blockquote>
<p>/* CAEAGLLayer is a layer that implements the EAGLDrawable protocol,<br/>
 * allowing it to be used as an OpenGLES render target. Use the<br/>
 * `drawableProperties&#39; property defined by the protocol to configure<br/>
 * the created surface. */</p>

<p>CAEAGLLayer是一个实现EAGLDrawable协议的层，<br/>
  *允许它用作OpenGLES渲染目标。 使用<br/>
  *协议定义的`drawableProperties&#39;属性进行配置<br/>
  *创建的表面。</p>
</blockquote>

<ol>
<li>创建图层</li>
<li><p>设置放大倍数</p>
<pre><code class="language-text">[self setContentScaleFactor:[[UIScreen mainScreen]scale]];
</code></pre></li>
<li><p>将图层设为不透明（默认是透明的）</p>
<pre><code class="language-text">self.myEagLayer.opaque = YES;
</code></pre></li>
<li><p>设置 <code>drawableProperties</code> 属性,这里设置不维持渲染内容以及颜色格式为RGBA8</p>
<pre><code class="language-text">self.myEagLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:false],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat,nil];
</code></pre></li>
</ol>

<pre><code class="language-text">/************************************************************************/
/* Keys for EAGLDrawable drawableProperties dictionary                  */
/*                                                                      */
/* kEAGLDrawablePropertyRetainedBacking:                                */
/*  Type: NSNumber (boolean)                                            */
/*  Legal Values: True/False                                            */
/*  Default Value: False                                                */
/*  Description: True if EAGLDrawable contents are retained after a     */
/*               call to presentRenderbuffer.  False, if they are not   */
/*                                                                      */
/* kEAGLDrawablePropertyColorFormat:                                    */
/*  Type: NSString                                                      */
/*  Legal Values: kEAGLColorFormat*                                     */
/*  Default Value: kEAGLColorFormatRGBA8                                */
/*  Description: Format of pixels in renderbuffer                       */
/************************************************************************/
</code></pre>

<ul>
<li>kEAGLDrawablePropertyRetainedBacking: 表示绘图表面显示后，是否保留其内容。这个key的值，是一个通过NSNumber包装的bool值。如果是false，则显示内容后不能依赖于相同的内容，ture表示显示后内容不变。一般只有在需要内容保存不变的情况下，才建议设置使用,因为会导致性能降低、内存使用量增减。一般设置为flase.</li>
<li>kEAGLDrawablePropertyColorFormat: 可绘制表面的内部颜色缓存区格式，这个key对应的值是一个NSString指定特定颜色缓存区对象。默认是kEAGLColorFormatRGBA8
<ul>
<li>kEAGLColorFormatRGBA8：32位RGBA的颜色，4*8=32位</li>
<li>kEAGLColorFormatRGB565：16位RGB的颜色，</li>
<li>kEAGLColorFormatSRGBA8：sRGB代表了标准的红、绿、蓝，即CRT显示器、LCD显示器、投影机、打印机以及其他设备中色彩再现所使用的三个基本色素。sRGB的色彩空间基于独立的色彩坐标，可以使色彩在不同的设备使用传输中对应于同一个色彩坐标体系，而不受这些设备各自具有的不同色彩坐标的影响。</li>
</ul></li>
</ul>

<h3 id="toc_1">二、创建上下文</h3>

<ol>
<li><p>指定OpenGL ES 渲染API版本，我们使用2.0</p>
<pre><code class="language-text">EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2;
</code></pre></li>
<li><p>创建图形上下文</p>
<pre><code class="language-text">EAGLContext *context = [[EAGLContext alloc] initWithAPI:api];
</code></pre></li>
<li><p>判断是否创建成功</p>
<pre><code class="language-text">if (!context) {
    NSLog(@&quot;Create context failed!&quot;);<br/>
    return;<br/>
}
</code></pre></li>
<li><p>设置图形上下文</p>
<pre><code class="language-text">if (![EAGLContext setCurrentContext:context]) {
    NSLog(@&quot;setCurrentContext failed!&quot;);<br/>
    return;<br/>
}
</code></pre></li>
<li><p>将局部context，变成全局的</p>
<pre><code class="language-text">self.myContext = context;
</code></pre></li>
</ol>

<h3 id="toc_2">三、清空缓存区</h3>

<ol>
<li><p>导入框架#import <OpenGLES/ES2/gl.h></p></li>
<li><p>创建2个帧缓存区，渲染缓存区，帧缓存区</p>
<pre><code class="language-text"> @property (nonatomic , assign) GLuint myColorRenderBuffer;
 @property (nonatomic , assign) GLuint myColorFrameBuffer;
</code></pre></li>
<li><p>清空缓存区 </p>
<pre><code class="language-text">glDeleteBuffers(1, &amp;_myColorRenderBuffer);
self.myColorRenderBuffer = 0;<br/>
glDeleteBuffers(1, &amp;_myColorFrameBuffer);<br/>
self.myColorFrameBuffer = 0;
</code></pre></li>
</ol>

<h3 id="toc_3">四、设置RenderBuffer</h3>

<ol>
<li><p>定义一个缓存区</p>
<pre><code class="language-text">GLuint buffer;
</code></pre></li>
<li><p>申请一个缓存区标志</p>
<pre><code class="language-text">glGenRenderbuffers(1, &amp;buffer);
//同 glGenRenderbuffers(1, &amp;buffer);<br/>
//赋值<br/>
self.myColorRenderBuffer = buffer;
</code></pre></li>
<li><p>将标识符绑定到GL_RENDERBUFFER</p>
<pre><code class="language-text">glBindRenderbuffer(GL_RENDERBUFFER, self.myColorRenderBuffer);
</code></pre></li>
<li><p>myColorRenderBuffer渲染缓存区分配存储空间</p>
<pre><code class="language-text">[self.myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.myEagLayer];
</code></pre>
<pre><code class="language-text">注意：frame buffer仅仅是管理者，不需要分配空间；
render buffer的存储空间的分配，对于不同的render buffer，使用不同的API进行分配，<br/>
而只有分配空间的时候，render buffer句柄才确定其类型
</code></pre></li>
</ol>

<h3 id="toc_4">五、设置FrameBuffer</h3>

<ol>
<li><p>定义一个缓存区</p>
<pre><code class="language-text">GLuint buffer;
</code></pre></li>
<li><p>申请一个缓存区标志</p>
<pre><code class="language-text">glGenRenderbuffers(1, &amp;buffer);
//赋值<br/>
self.myColorFrameBuffer = buffer;
</code></pre></li>
<li><p>将标识符绑定到GL_FRAMEBUFFER</p>
<pre><code class="language-text">glBindFramebuffer(GL_FRAMEBUFFER, self.myColorFrameBuffer);
</code></pre></li>
<li><p>renderbuffer跟framebuffer进行绑定,将_myColorRenderBuffer 通过glFramebufferRenderbuffer函数绑定到GL_COLOR_ATTACHMENT0上。</p>
<pre><code class="language-text">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.myColorRenderBuffer);
</code></pre>
<p>//接下来，可以调用OpenGL ES进行绘制处理，最后则需要在EGALContext的OC方法进行最终的渲染绘制。这里渲染的color buffer,这个方法会将buffer渲染到CALayer上。- (BOOL)presentRenderbuffer:(NSUInteger)target;</p></li>
</ol>

<h3 id="toc_5">六、开始绘制</h3>

<ol>
<li><p>设置颜色、设置视口大小</p>
<pre><code class="language-text">//设置清屏颜色
glClearColor(0.0f, 1.0f, 0.0f, 1.0f);<br/>
//清除屏幕<br/>
glClear(GL_COLOR_BUFFER_BIT);<br/>
CGFloat scale = [[UIScreen mainScreen]scale];<br/>
//设置视口大小<br/>
glViewport(self.frame.origin.x * scale, self.frame.origin.y * scale, self.frame.size.width * scale, self.frame.size.height * scale);
</code></pre></li>
<li><p>读取顶点着色程序、片元着色程序</p>
<pre><code class="language-text">NSString *vertFile = [[NSBundle mainBundle]pathForResource:@&quot;shaderv&quot; ofType:@&quot;vsh&quot;];
NSString *fragFile = [[NSBundle mainBundle]pathForResource:@&quot;shaderf&quot; ofType:@&quot;fsh&quot;];
</code></pre></li>
<li><p>加载shader</p>
<pre><code class="language-text">self.myPrograme = [self loadShaders:vertFile Withfrag:fragFile];//见附
</code></pre></li>
<li><p>链接</p>
<pre><code class="language-text">glLinkProgram(self.myPrograme);
GLint linkStatus;<br/>
//获取链接状态<br/>
glGetProgramiv(self.myPrograme, GL_LINK_STATUS, &amp;linkStatus);<br/>
if (linkStatus == GL_FALSE) {<br/>
    GLchar message[512];<br/>
    glGetProgramInfoLog(self.myPrograme, sizeof(message), 0, &amp;message[0]);<br/>
    NSString *messageString = [NSString stringWithUTF8String:message];<br/>
    NSLog(@&quot;Program Link Error:%@&quot;,messageString);<br/>
    return;<br/>
}
</code></pre></li>
<li><p>使用program</p>
<pre><code class="language-text">glUseProgram(self.myPrograme);
</code></pre></li>
<li><p>设置顶点、纹理坐标</p>
<pre><code class="language-text">...
</code></pre></li>
<li><p>处理顶点数据</p>
<pre><code class="language-text">glVertexAttribPointer(position, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, NULL);
</code></pre></li>
<li><p>处理纹理数据</p>
<pre><code class="language-text">glVertexAttribPointer(textCoor, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, (float *)NULL + 3);
</code></pre></li>
<li><p>加载纹理</p>
<ul>
<li><p>获取图片的CGImageRef</p></li>
<li><p>读取图片的大小，宽和高</p></li>
<li><p>获取图片字节数 宽<em>高</em>4（RGBA）</p></li>
<li><p>创建上下文</p></li>
<li><p>在CGContextRef上绘图 ,解决图片倒置的方法</p></li>
<li><p>画图完毕就释放上下文</p></li>
<li><p>绑定纹理到默认的纹理ID（这里只有一张图片，故而相当于默认于片元着色器里面的 </p></li>
<li><p>设置纹理属性</p></li>
<li><p>载入纹理2D数据</p></li>
<li><p>绑定纹理</p></li>
<li><p>释放spriteData</p></li>
</ul></li>
<li><p>获取shader里面的变量, 模型视图变换传值</p></li>
<li><p>绘制并显示缓存数据 presentRenderbuffer </p>
<pre><code class="language-text">glDrawArrays(GL_TRIANGLES, 0, 6);
[self.myContext presentRenderbuffer:GL_RENDERBUFFER];
</code></pre></li>
</ol>

<h3 id="toc_6">附</h3>

<ol>
<li>frame buffer 和 render buffer 关系</li>
</ol>

<pre><code class="language-text">buffer分为frame buffer 和 render buffer2个大类。其中frame buffer 相当于render buffer的管理者。frame buffer object即称FBO，常用于离屏渲染缓存等。render buffer则又可分为3类。colorBuffer、depthBuffer、stencilBuffer。
</code></pre>

<ol>
<li><p>加载shader</p>
<ul>
<li>定义2个零时着色器对象</li>
<li>创建program</li>
<li>编译顶点着色程序、片元着色器程序
<ul>
<li>读取文件路径字符串</li>
<li>创建一个shader（根据type类型）</li>
<li>将顶点着色器源码附加到着色器对象上</li>
<li>把着色器源代码编译成目标代码</li>
</ul></li>
<li>创建最终的程序</li>
<li>释放不需要的shader</li>
</ul></li>
</ol>

<pre><code class="language-text">-(GLuint)loadShaders:(NSString *)vert Withfrag:(NSString *)frag {
    //定义2个零时着色器对象
    GLuint verShader, fragShader;
    //创建program
    GLint program = glCreateProgram();
    
    //编译顶点着色程序、片元着色器程序
    //参数1：编译完存储的底层地址
    //参数2：编译的类型，GL_VERTEX_SHADER（顶点）、GL_FRAGMENT_SHADER(片元)
    //参数3：文件路径
    [self compileShader:&amp;verShader type:GL_VERTEX_SHADER file:vert];
    [self compileShader:&amp;fragShader type:GL_FRAGMENT_SHADER file:frag];
    
    //创建最终的程序
    glAttachShader(program, verShader);
    glAttachShader(program, fragShader);
    
    //释放不需要的shader
    glDeleteShader(verShader);
    glDeleteShader(fragShader);
    
    return program;
}
</code></pre>

<pre><code class="language-text">//链接shader
- (void)compileShader:(GLuint *)shader type:(GLenum)type file:(NSString *)file{
    
    //读取文件路径字符串
    NSString* content = [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil];
    const GLchar* source = (GLchar *)[content UTF8String];
    
    //创建一个shader（根据type类型）
    *shader = glCreateShader(type);
    
    //将顶点着色器源码附加到着色器对象上。
    //参数1：shader,要编译的着色器对象 *shader
    //参数2：numOfStrings,传递的源码字符串数量 1个
    //参数3：strings,着色器程序的源码（真正的着色器程序源码）
    //参数4：lenOfStrings,长度，具有每个字符串长度的数组，或NULL，这意味着字符串是NULL终止的
    glShaderSource(*shader, 1, &amp;source,NULL);
    
    //把着色器源代码编译成目标代码
    glCompileShader(*shader);
    
}
</code></pre>

<ol>
<li>设置纹理</li>
</ol>

<pre><code class="language-text">//设置纹理
- (GLuint)setupTexture:(NSString *)fileName {
    //1、获取图片的CGImageRef
    CGImageRef spriteImage = [UIImage imageNamed:fileName].CGImage;
    
    //判断图片是否获取成功
    if (!spriteImage) {
        NSLog(@&quot;Failed to load image %@&quot;, fileName);
        exit(1);
    }
    
    //2、读取图片的大小，宽和高
    size_t width = CGImageGetWidth(spriteImage);
    size_t height = CGImageGetHeight(spriteImage);
    
    //3.获取图片字节数 宽*高*4（RGBA）
    GLubyte * spriteData = (GLubyte *) calloc(width * height * 4, sizeof(GLubyte));
    
    //4.创建上下文
    /*
     参数1：data,指向要渲染的绘制图像的内存地址
     参数2：width,bitmap的宽度，单位为像素
     参数3：height,bitmap的高度，单位为像素
     参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8
     参数5：bytesPerRow,bitmap的没一行的内存所占的比特数
     参数6：colorSpace,bitmap上使用的颜色空间  kCGImageAlphaPremultipliedLast：RGBA
     */
    CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4,CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast);
    
    
    
    //5、在CGContextRef上绘图
    /*
     CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。
     CGContextDrawImage 
     参数1：绘图上下文
     参数2：rect坐标
     参数3：绘制的图片
     */
    CGRect rect = CGRectMake(0, 0, width, height);
    //使用默认方式绘制，发现图片是倒的。
    CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage);
    /*
     解决图片倒置的方法(2):
     CGContextTranslateCTM(spriteContext, rect.origin.x, rect.origin.y);
     CGContextTranslateCTM(spriteContext, 0, rect.size.height);
     CGContextScaleCTM(spriteContext, 1.0, -1.0);
     CGContextTranslateCTM(spriteContext, -rect.origin.x, -rect.origin.y);
     CGContextDrawImage(spriteContext, rect, spriteImage);
     */
   
    //6、画图完毕就释放上下文
    CGContextRelease(spriteContext);
    
    //5、绑定纹理到默认的纹理ID（这里只有一张图片，故而相当于默认于片元着色器里面的colorMap，如果有多张图不可以这么做）
    glBindTexture(GL_TEXTURE_2D, 0);
    
    //设置纹理属性
    /*
     参数1：纹理维度
     参数2：线性过滤、为s,t坐标设置模式
     参数3：wrapMode,环绕模式
     */
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    float fw = width, fh = height;
    //载入纹理2D数据
    /*
     参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D
     参数2：加载的层次，一般设置为0
     参数3：纹理的颜色值GL_RGBA
     参数4：宽
     参数5：高
     参数6：border，边界宽度
     参数7：format
     参数8：type
     参数9：纹理数据
     */
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, fw, fh, 0, GL_RGBA, GL_UNSIGNED_BYTE, spriteData);
    
    //绑定纹理
    /*
     参数1：纹理维度
     参数2：纹理ID,因为只有一个纹理，给0就可以了。
     */
    glBindTexture(GL_TEXTURE_2D, 0);
    
    //释放spriteData
    free(spriteData);
    
    return 0;
}
</code></pre>

<p>详细代码：<a href="https://github.com/Caolongs/OpenGL-ES---GLSL">DEMO</a></p>

<h1 id="toc_7">文章目录</h1>

<ul>
<li>
<a href="#toc_0">一、创建图层</a>
</li>
<li>
<a href="#toc_1">二、创建上下文</a>
</li>
<li>
<a href="#toc_2">三、清空缓存区</a>
</li>
<li>
<a href="#toc_3">四、设置RenderBuffer</a>
</li>
<li>
<a href="#toc_4">五、设置FrameBuffer</a>
</li>
<li>
<a href="#toc_5">六、开始绘制</a>
</li>
<li>
<a href="#toc_6">附</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_7">文章目录</a>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15209234462100.html">
                
                  <h1>组件化 - 远程私有库</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>远程私有库相对于本地私有库多了许多配置，对 <code>.spec</code> 文件的配置就显得尤为重要了许多</p>

<p>首先，一般采用pod库的形式来集成的远程私有库就需要我们对 cocoapods 的工作有一定的认识。</p>

<p><img src="media/15209234462100/15210147171661.jpg" alt=""/></p>

<h3 id="toc_0">一、 创建远程私有索引库</h3>

<ol>
<li><p>在git托管平台创建 ChuangSpecs 工程 作为远程索引库 git 地址为 <code>http://10.10.1.18/caolongjian/ChuangSpecs.git</code></p></li>
<li><p>本地创建私有库索引仓库</p></li>
</ol>

<pre><code class="language-text">pod repo add ChuangSpecs http://10.10.1.18/caolongjian/ChuangSpecs.git
</code></pre>

<p><strong>注意：</strong> 若使用 <code>git@10.10.1.18:caolongjian/ChuangSpecs.git</code> 需配置SSH</p>

<p><img src="media/15209234462100/15209242919898.jpg" alt=""/></p>

<h3 id="toc_1">二、 将本地项目推送到远程</h3>

<ol>
<li>在git托管平台创建 JJTableView 工程</li>
</ol>

<p>并将本地的仓库和远程的仓库进行关联</p>

<pre><code class="language-text">git remote add origin http://10.10.1.18/caolongjian/JJTableView.git
</code></pre>

<pre><code class="language-text">git push -u origin master
</code></pre>

<p><strong>注意：</strong> 第一次push的时候,加上-u参数,Git就会把本地的master分支和远程的master分支进行关联起来,以后的push操作就不再需要加上-u参数了</p>

<h3 id="toc_2">三、 配置 JJTableView.podspec 文件</h3>

<p><img src="media/15209234462100/15209252706686.jpg" alt=""/></p>

<h4 id="toc_3">1. 校验一下我们.spec文件是否合法</h4>

<pre><code class="language-text">pod lib lint
</code></pre>

<p>若发现如下 n 多错误，请根据WARN 修改（泪奔，一开始忽略了警告，直接修改ERROR）默认Swift3.2 验证，代码是在Swift4.0下编写运行 </p>

<blockquote>
<p>-WARN  | [iOS] swift: The validator used Swift 3.2 by default because no Swift version was specified. To specify a Swift version during validation, add the <code>swift_version</code> attribute in your podspec. Note that usage of the <code>--swift-version</code> parameter or a <code>.swift-version</code> file is now deprecated.</p>
</blockquote>

<p>错误：❌<br/>
<img src="media/15209234462100/15209968805813.jpg" alt=""/></p>

<p>解决方案,修改验证编译环境为 Swift 4.0<br/>
<img src="media/15209234462100/15209971483117.jpg" alt=""/></p>

<h4 id="toc_4">2. tag 标签</h4>

<pre><code class="language-text">git tag 0.1.0
git push --tags
</code></pre>

<h4 id="toc_5">3. 校验远程 .spec文件是否合法</h4>

<pre><code class="language-text">pod spec lint
</code></pre>

<p><img src="media/15209234462100/15209979433502.jpg" alt=""/></p>

<h4 id="toc_6">4. .repo 提交到远程私有索引库</h4>

<p>我们要将 JJTableView.podspec 提交到我们的远程私有索引库(ChuangSpecs)当中去，使用pod repo push [远程私有索引库名称] [框架名称的描述文件]</p>

<pre><code class="language-text">$ pod repo push ChuangSpecs JJTableView.podspec
</code></pre>

<p><img src="media/15209234462100/15209981574964.jpg" alt=""/></p>

<ul>
<li><p>对应远程索引库：<br/>
<img src="media/15209234462100/15209983974164.jpg" alt=""/></p></li>
<li><p>对应本地索引库：<br/>
<img src="media/15209234462100/15209982406452.jpg" alt=""/></p></li>
<li><p>使用 pod search JJTableView 搜索<br/>
<img src="media/15209234462100/15209984753755.jpg" alt=""/></p></li>
</ul>

<h3 id="toc_7">四、 主工程使用组件</h3>

<ol>
<li><p>配置 podfile 文件<br/>
默认指定源是Cocoapods的官方索引库，需要添加自己的远程私有库</p>
<ul>
<li><p>添加source，记得默认源也要添加上</p>
<pre><code class="language-text">source &#39;https://github.com/CocoaPods/Specs.git&#39;
source &#39;http://10.10.1.18/caolongjian/ChuangSpecs.git&#39;
</code></pre></li>
<li><p>pod &#39;JJTableView&#39;</p>
<pre><code class="language-text">#pod &#39;JJTableView&#39;, :path =&gt; &#39;../Lib/JJTableView&#39;
pod &#39;JJTableView&#39;, &#39;0.1.4&#39;
</code></pre></li>
</ul></li>
<li><p>执行 pod install</p></li>
</ol>

<h3 id="toc_8">附问题：</h3>

<h4 id="toc_9">问题一：pod lib lint 验证不通过 出错</h4>

<p>Swift 验证版本问题，根据提示添加 <code>swift_version</code> 属性</p>

<h4 id="toc_10">问题二：二级目录没有显示出来</h4>

<p><img src="media/15209234462100/15209991564647.jpg" alt=""/></p>

<ul>
<li><p>修改 s.source_files 加上 .swift<br/>
<img src="media/15209234462100/15210088484156.jpg" alt=""/></p></li>
<li><p>多级目录提交, 多文件之间尽量不要相互依赖</p></li>
</ul>

<pre><code class="language-text">s.subspec &#39;CellKit&#39; do |cellKit|
    cellKit.source_files = &#39;JJTableView/Classes/JJTableView/CellKit/**/*&#39;
    cellKit.public_header_files = &#39;Pod/Classes/**/*.h&#39;
    cellKit.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39;
end
</code></pre>

<h1 id="toc_11">文章目录</h1>

<ul>
<li>
<a href="#toc_0">一、 创建远程私有索引库</a>
</li>
<li>
<a href="#toc_1">二、 将本地项目推送到远程</a>
</li>
<li>
<a href="#toc_2">三、 配置 JJTableView.podspec 文件</a>
<ul>
<li>
<a href="#toc_3">1. 校验一下我们.spec文件是否合法</a>
</li>
<li>
<a href="#toc_4">2. tag 标签</a>
</li>
<li>
<a href="#toc_5">3. 校验远程 .spec文件是否合法</a>
</li>
<li>
<a href="#toc_6">4. .repo 提交到远程私有索引库</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">四、 主工程使用组件</a>
</li>
<li>
<a href="#toc_8">附问题：</a>
<ul>
<li>
<a href="#toc_9">问题一：pod lib lint 验证不通过 出错</a>
</li>
<li>
<a href="#toc_10">问题二：二级目录没有显示出来</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_11">文章目录</a>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%B6%E6%9E%84.html'>架构</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15208414821831.html">
                
                  <h1>组件化 - 本地私有库创建</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h3 id="toc_0">创建子工程（测试工程）</h3>

<ul>
<li><p><strong>方法一：</strong> 确定需要抽取的组件，那么势必需要一个将其放到一个工程中能够正常运行，常规可以直接创建一个冲程，然后将需要的组件拖入工程中，创建 <code>.spec</code> 文件：</p>
<pre><code class="language-text">pod spec create [名称]
</code></pre></li>
<li><p><strong>方法二：</strong> 幸运的是 cocoapods 提供了我们快捷创建测试模板工程</p></li>
<li><p>1.首先在当前工程目录文件中创建Lib文件，与工程目录同级，执行：</p>
<pre><code class="language-text">pod lib create [名称]
</code></pre>
<p>根据命令行提示操作，如下图</p></li>
</ul>

<p><img src="media/15208414821831/15208417126201.jpg" alt=""/></p>

<ul>
<li>2. 创建成功将直接打开测试工程，找到 ReplaceMe.swift 文件，将已封装的组件替换该文件</li>
</ul>

<p><img src="media/15208414821831/15208418690324.jpg" alt="" style="width:270px;"/></p>

<ul>
<li>3. 执行  pod install</li>
</ul>

<pre><code class="language-text">pod install

</code></pre>

<p>拖入项目中的组件会自动出现在工程目录中，可进行对代码进行修改</p>

<h3 id="toc_1">主工程使用本地组件</h3>

<ul>
<li>podfile 文件配置</li>
</ul>

<p>打开主项目工程，Podfile中添加 JJTableView 本地组件（Lib文件与主工程目录同级）</p>

<pre><code class="language-text">pod &#39;JJTableView&#39;, :path =&gt; &#39;../Lib/JJTableView&#39;
</code></pre>

<ul>
<li>执行  pod install</li>
</ul>

<pre><code class="language-text">pod install

</code></pre>

<p>主工程Pods工程中就会出现本地组件化的代码</p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%B6%E6%9E%84.html'>架构</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15204087282870.html">
                
                  <h1>Jenkins + Fastlane 持续集成自动化打包</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <blockquote>
<p>本文使用 Jenkins 与 Fastlane 结合使用自动编译打包至蒲公英</p>
</blockquote>

<p>Fastlane 已在<a href="https://www.jianshu.com/p/de44b824f105">上篇文章</a>讲过，是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。</p>

<blockquote>
<p>Jenkins是一款自包含的开源自动化服务器，可用于自动执行与构建，测试和交付或部署软件有关的各种任务。</p>
</blockquote>

<h2 id="toc_0">Jenkins 安装</h2>

<ul>
<li>1. 命令行安装</li>
</ul>

<pre><code class="language-text">brew install jenkins 


</code></pre>

<p><code>若无homebrew，安装homebrew</code></p>

<pre><code class="language-text">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<ul>
<li>2. 官网下载安装</li>
</ul>

<pre><code class="language-text">https://jenkins.io/
</code></pre>

<p>使用 homebrew 安装成功，显示启动Jenkins方法，如下图<br/>
<img src="media/15204087282870/15204108387239.jpg" alt="" style="width:573px;"/></p>

<h2 id="toc_1">Jenkins 使用</h2>

<h4 id="toc_2">1. 启动Jenkins</h4>

<pre><code class="language-text">```
$ jenkins

```
</code></pre>

<h4 id="toc_3">2. 访问 <a href="http://localhost:8080/">http://localhost:8080/</a></h4>

<pre><code class="language-text">```
2.1 弹出Jenkins安装界面，会让你输入安全密码,输入完成之后选择默认安装。
（密码会在终端log日志中打印出来）

2.2 新建管理员账号密码
```
</code></pre>

<h4 id="toc_4">3. 安装插件</h4>

<pre><code class="language-text">创建账户之后会弹出插件安装选项，默认安装或选择安装，可根据需要自行选择

GitLab插件
在可选插件中选择GitLab和Gitlab Hook进行安装。

Xcode插件
在可选插件中选择Xcode进行安装。

...

以默认安装为例，（其实没有必要），后期可根据需要调整安装插件
</code></pre>

<h4 id="toc_5">4. 新建任务</h4>

<ul>
<li><p>进入主页面，点击新建任务，输入名称，选择&quot;构建一个自由风格的软件项目&quot;<br/>
<img src="media/15204087282870/15204124474811.jpg" alt="" style="width:1037px;"/></p></li>
<li><p>点击确认进入配置页面<br/>
<img src="media/15204087282870/15204126203878.jpg" alt="" style="width:971px;"/></p></li>
<li><p>配置源码管理，点击 Add 按钮，选择 Jenkins 填写仓库用户名、密码（或其他方式）<br/>
<img src="media/15204087282870/15204128400804.jpg" alt="" style="width:895px;"/></p></li>
<li><p>配置构建 - 上传至蒲公英</p>
<ol>
<li>输入项目中 fastlane 命令</li>
</ol>
<pre><code class="language-text">fastlane beta_pgyer
</code></pre>
<p><img src="media/15204087282870/15204130038565.jpg" alt="" style="width:936px;"/>   </p>
<ol>
<li><p>与工作区对应关系如下：（否则构建 Execte shell 添加 cd ../  找到fastlane对应目录）<br/>
<img src="media/15204087282870/15204132526762.jpg" alt="" style="width:704px;"/>   </p></li>
<li><p>fastlane 文件夹中 Fastfile 文件中对应操作如下：<br/>
<img src="media/15204087282870/15204134978253.jpg" alt="" style="width:469px;"/>         </p></li>
</ol></li>
</ul>

<h4 id="toc_6">5. 立即构建</h4>

<p><img src="media/15204087282870/15204140708308.jpg" alt="" style="width:569px;"/></p>

<p>至此，Jenkins与fastlane结合使用的一个简单的自动化构建可正常运行，其他更多构建任务配置信息（构建触发器、构建环境、构建后操作等）可自行根据需要修改</p>

<h2 id="toc_7">其他方式</h2>

<ul>
<li><p>Xcode 插件方式</p>
<p>安装 Xcode 插件， 构建选项中会出现Xcode，具体配置信息可自行尝试<br/>
<img src="media/15204087282870/15204142313802.jpg" alt="" style="width:574px;"/>   </p></li>
<li><p>jenkins与fastlane分工</p>
<p>jenkins配置项目相关参数，fastlane在fastfile脚本中使用。</p>
<p>例如：在jenkins构建时添加参数：scheme，configuration，version，build</p>
<p>然后在Execute Shell中使用命令：</p>
<pre><code class="language-text">fastlane beta_pgyer scheme:${scheme} configuration:${configuration}     version:${version} build:${build}
</code></pre>
<p>项目中Fastfile中可以这么使用：</p>
<pre><code class="language-text">lane :beta_pgyer do |options|
#这样就可以获取到jenkins中传入的scheme，configuration，version，build的值<br/>
#获取方式：options[:scheme]，options[:configuration]，options[: version]，  options[: build]<br/>
end
</code></pre></li>
</ul>

<h1 id="toc_8">文章目录</h1>

<ul>
<li>
<a href="#toc_0">Jenkins 安装</a>
</li>
<li>
<a href="#toc_1">Jenkins 使用</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_2">1. 启动Jenkins</a>
</li>
<li>
<a href="#toc_3">2. 访问 http://localhost:8080/</a>
</li>
<li>
<a href="#toc_4">3. 安装插件</a>
</li>
<li>
<a href="#toc_5">4. 新建任务</a>
</li>
<li>
<a href="#toc_6">5. 立即构建</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_7">其他方式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">文章目录</a>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='CI.html'>CI</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15196291080319.html">
                
                  <h1>FastLane - 上传到蒲公英</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">安装蒲公英的 Fastlane 插件</h2>

<ul>
<li>安装蒲公英的 Fastlane 插件
<code>
fastlane add_plugin pgyer
</code></li>
</ul>

<h2 id="toc_1">Fastfile文件中添加Lane，加入蒲公英插件的配置信息</h2>

<pre><code class="language-text">lane :beta do
  build_app(export_method: &quot;ad-hoc&quot;)
  pgyer(api_key: &quot;7f15xxxxxxxxxxxxxxxxxx141&quot;, user_key: &quot;4a5bcxxxxxxxxxxxxxxx3a9e&quot;)
end
</code></pre>

<p>注意：以上的 <code>api_key</code> 和 <code>user_key</code>，请开发者在自己账号下的 <code>应用管理</code> - <code>App概述</code> - <code>API</code> 中可以找到，并替换到以上相应的位置。<br/>
<img src="media/15196291080319/15196309745541.jpg" alt="" style="width:582px;"/></p>

<h2 id="toc_2">打包并自动上传 App 到蒲公英</h2>

<pre><code class="language-text">bundle exec fastlane beta_pgyer
</code></pre>

<p>打包上传成功截图如下：<br/>
<img src="media/15196291080319/15196292344319.jpg" alt="" style="width:614px;"/></p>

<h2 id="toc_3">参考</h2>

<p><a href="https://www.pgyer.com/doc/view/fastlane">使用 Fastlane 上传 App 到蒲公英</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='CI.html'>CI</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15196148245866.html">
                
                  <h1>Fastlane</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">简介</h2>

<p>fastlane是为iOS和Android应用程序自动化测试版部署和发布的最简单方法。🚀它处理所有繁琐的任务，例如生成屏幕截图，处理代码签名以及发布应用程序。</p>

<p>您可以从Fastfile存储库中创建一个文件开始，这里定义了您的测试版或App Store发布过程：</p>

<pre><code class="language-text">lane :beta do
  increment_build_number
  build_app
  upload_to_testflight
end

lane :release do
  capture_screenshots
  build_app                 
  upload_to_app_store       # Upload the screenshots and the binary to iTunes
  slack                     # Let your team-mates know the new version is live
end
</code></pre>

<pre><code class="language-text">gym         # alias for &quot;build_ios_app&quot;
build_app   # alias for &quot;build_ios_app&quot;
</code></pre>

<p>您只定义了2个不同的通道，一个用于测试版部署，另一个用于App Store。要在App Store中发布你的应用程序，你所要做的就是</p>

<pre><code class="language-text">fastlane release
</code></pre>

<h2 id="toc_1">安装使用fastlane</h2>

<ul>
<li><p>确保安装了最新版本的Xcode命令行工具：</p>
<pre><code class="language-text">xcode-select --install
</code></pre></li>
<li><p>使用安装fastlane</p>
<pre><code class="language-text">[sudo] gem install fastlane -NV 
</code></pre></li>
<li><p>导航到您的iOS或Android应用程序并运行</p>
<pre><code class="language-text">fastlane init
注:(对于Swift安装：fastlane init swift)
</code></pre>
<p>安装fastlane根据提示信息填写相关信息即可，生成如下文件目录：<br/>
<img src="media/15196148245866/15196248166965.jpg" alt=""/></p>
<ul>
<li><p>Appfile =&gt; 是用来存储一些公共信息的，<br/>
比如app_identifier，apple_id，team_id，itc_team_id等 <a href="https://docs.fastlane.tools/advanced/#appfile">Appfile帮助</a></p></li>
<li><p>Deliverfile =&gt; deliver的配置文件 <a href="https://docs.fastlane.tools/actions/deliver/">Deliverfile帮助</a></p></li>
<li><p>Fastfile，其中包含分发您的应用程序所需的所有信息。是最重要的一个文件，在这个里面可以编写和定制我们的自动化脚本，所有的流程控制功能都写在这个文件里面。<a href="https://github.com/fastlane/fastlane/tree/master/fastlane/docs#fastfile">Fastfile帮助</a></p></li>
</ul></li>
</ul>

<h2 id="toc_2">配置效果</h2>

<p><img src="media/15196148245866/15196262906220.jpg" alt=""/></p>

<pre><code class="language-text">increment_build_number_in_plist 需安装插件 fastlane-plugin-versioning
</code></pre>

<h2 id="toc_3">插件</h2>

<p>Fastlane的插件是一个或者一组action的打包，单独发布在fastlane之外。<a href="https://docs.fastlane.tools/plugins/create-plugin/">Fastlane Plugin 指南</a></p>

<ul>
<li><p>查看所有插件：</p>
<pre><code class="language-text">fastlane search_plugins
</code></pre></li>
<li><p>安装插件</p></li>
</ul>

<pre><code class="language-text">    fastlane add_plugin [插件名称]
    
    如:fastlane add_plugin versioning
</code></pre>

<h2 id="toc_4">环境变量<a href="https://docs.fastlane.tools/advanced/#environment-variables">Environment Variables</a></h2>

<p>有时候我们希望把账号信息、更新描述和版本号等信息单独放在一个配置文件。在这里Fastlane给我们提供了相应的解决方案。</p>

<p>我们可以在工程目录下创建一个名为 <code>.env</code> 的文件，自定义所需的临时变量，然后Fastlane的三个配置文件（<code>Appfile</code>、<code>Deliverfile</code>和<code>Fastfile</code>）分别从<code>.env</code>文件中读取配置信息</p>

<p>更多信息查看<a href="https://docs.fastlane.tools/advanced/#environment-variables">fastlane文档</a></p>

<h2 id="toc_5">其他 (辅助命令查看)</h2>

<h3 id="toc_6">1.0 fastlane actions</h3>

<p><em>fastlane actions</em>: 列出所有的 fastlane 的 actions，可以看到 fastlane 支持的所有 action<br/>
<img src="media/15196148245866/15196167896499.jpg" alt="" style="width:610px;"/></p>

<h3 id="toc_7">1.1 fastlane action [name]</h3>

<p><code>fastlane action [name]</code> 显示某一个特定的 action 的详细配置</p>

<p>例如：<code>fastlane action gym</code><br/>
<img src="media/15196148245866/15196172482949.jpg" alt="" style="width:610px;"/></p>

<h3 id="toc_8">2.0 fastlane lanes</h3>

<pre><code class="language-text">fastlane lanes: 列出所有的可用的 lane 及其描述。
这里显示的就是你的 Fastfile 里面定义的所有 lane
</code></pre>

<h3 id="toc_9">2.1 fastlane list</h3>

<pre><code class="language-text">fastlane list: 显示所有的 lane，但是不显示描述。
</code></pre>

<h2 id="toc_10">参考</h2>

<ol>
<li>更多信息请参看<a href="https://docs.fastlane.tools/">官方网站fastlane docs</a></li>
<li><a href="http://blog.devzeng.com/blog/ios-fastlane-in-action.html">iOS中fastlane的使用</a></li>
<li><a href="https://whlsxl.github.io/">Fastlane带来的全自动化发布</a></li>
</ol>

<h2 id="toc_11">值得借鉴</h2>

<p><a href="https://mp.weixin.qq.com/s/UDxe5eBVeLPMC14ed_DJhQ">iOS使用fastlane一键打包审核</a></p>

<h1 id="toc_12">文章目录</h1>

<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">安装使用fastlane</a>
</li>
<li>
<a href="#toc_2">配置效果</a>
</li>
<li>
<a href="#toc_3">插件</a>
</li>
<li>
<a href="#toc_4">环境变量Environment Variables</a>
</li>
<li>
<a href="#toc_5">其他 (辅助命令查看)</a>
<ul>
<li>
<a href="#toc_6">1.0 fastlane actions</a>
</li>
<li>
<a href="#toc_7">1.1 fastlane action [name]</a>
</li>
<li>
<a href="#toc_8">2.0 fastlane lanes</a>
</li>
<li>
<a href="#toc_9">2.1 fastlane list</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">参考</a>
</li>
<li>
<a href="#toc_11">值得借鉴</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">文章目录</a>

 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='CI.html'>CI</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15193516410111.html">
                
                  <h1>Continuous Integration in Xcode</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <p>在Xcode中，持续集成是自动化和简化Mac和iOS应用程序的构建，分析，测试和存档的过程，以确保它们始终处于可释放状态。在持续集成工作流程中，您可以在开发Mac上的Xcode本地编写应用程序，并将它们检入源代码存储库。然后将它们发送到OS X服务器提供的服务Xcode Server进行处理。在开发Mac上的Xcode中，您设置了运行在服务器上的僵尸程序。这些机器人使用存储库中的源代码处理您的应用程序，并报告结果。bot的每次运行称为集成，并且这些运行在整个应用程序的开发生命周期中定期发生<br/>
<img src="media/15193516410111/15193516796669.png" alt=""/></p>

<h2 id="toc_0">持续集成的目标是提高软件质量，实现这一目标有多种方式：</h2>

<p><em>快速，轻松，及早地捕捉问题。</em>每次将代码更改提交到源代码存储库，按照特定的时间表或者手动启动它们时，Bot集成都可以设置为运行。这使您可以在整个开发过程中识别代码问题，在问题发生时解决问题，并防止将较小的问题级联到较大的问题。</p>

<p><em>加强协作。</em>在持续集成工作流程中，您的整个团队（或选定的个人）可以创建机器人，触发集成，查看活动和下载构​​建。如果引入问题，代码更改导致失败的人将自动收到通知。</p>

<p><em>扩大测试覆盖范围。</em>在本地工作时，在具有多种配置的多个设备上测试您的应用程序是一项手动和时间密集型过程。在持续集成工作流程中，它自动且简单。只需将多个设备插入服务器或将工作流配置为使用多个模拟器，相应地配置您的机器人，并让系统为您完成工作。</p>

<p><em>随着时间的推移生成构建和测试统计。</em>在持续集成工作流程中，记录所有进度和失败。在任何时候，您都可以看到您的应用程序在开发过程中的位置以及它随着时间的推移如何成熟。</p>

<p>[关于iOS自动化打包的一些分享](<a href="https://mp.weixin.qq.com/s/2epELEgB1TGfJLDr2ax6eQ">https://mp.weixin.qq.com/s/2epELEgB1TGfJLDr2ax6eQ</a></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='CI.html'>CI</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
			<div class="article">
                <a class="clearlink" href="15176282030413.html">
                
                  <h1>OpenGL简单介绍及实践</h1>
                  <div class="a-content">
                      
                      
                      <div class="a-content-text">
                        
                        	<!-- <h2 id="toc_0">什么是<a href="https://zh.wikipedia.org/wiki/OpenGL">OpenGL</a> (Open Graphics Library)</h2>

<pre><code class="language-javascript">OpenGL 是一种应用程序编程接口（Application Programming Interface,API）,
用于渲染2D、3D矢量图形。    

</code></pre>

<h2 id="toc_1">相关程序库</h2>

<p>OpenGL被设计为只有输出的，所以它只提供渲染功能。核心API没有窗口系统、音频、打印、键盘／鼠标或其他输入设备的概念。</p>

<p><strong>几个库创建在OpenGL之上，提供了OpenGL本身没有的功能:</strong></p>

<ul>
<li>GLU</li>
<li>GLUT <code>(能够以可移植的方式提供基本的窗口功能)</code></li>
<li>GLUI</li>
<li>GLEW <code>(GLEW可以简化获取函数地址的过程，并且包含了可以跨平台使用的其他一些OpenGL编程方法)</code></li>
<li>GLEE </li>
<li>FREEGLUT <code>（GLUT已经于1998年不再更新了。于是就有了freeglut）</code></li>
<li>OpenGL Performer <code>(可以创建实时可视化仿真程序)</code></li>
<li>......</li>
</ul>

<p>当开发者需要使用最新的OpenGL扩展时，他们往往需要使用GLEW库或者是GLEE库提供的功能，可以在程序的运行期判断当前硬件是否支持相关的扩展，防止程序崩溃甚至造成硬件损坏。这类库利用动态加载技术（dlsym、GetProcAddress等函数）搜索各种扩展的信息。</p>

<h2 id="toc_2">实践</h2>

<ul>
<li>GLUT 库使用</li>
</ul>

<pre><code class="language-text">int main(int argc,char *argv[]) {
    //1. 初始化一个GLUT库
    glutInit(&amp;argc, (char **)argv);
        
    //2. 创建一个窗口并定制窗口名
    glutCreateWindow(&quot;OpenGL_Demo&quot;);
        
    //3. 注册一个绘图函数，操作系统在必要的时刻就会对窗体进行重绘制操作
    //它设置了一个现实回调（display callback）,即GLUT没在每次更新窗口内容时会自动调用改例程
    glutDisplayFunc(RenderScene);
        
        
    //这是一个无限执行的循环，它会负责一直处理窗口和操作系统的用户输入等操作。（
    //注意：不会执    行在glutMainLoop()之后的所有命令。）
    glutMainLoop();
        
        }
</code></pre>

<ul>
<li>GLEW 库使用</li>
</ul>

<p>可在程序运行操作前进行使用，确保驱动程序的初始化过程中没有任何问题</p>

<pre><code class="language-text">    /*
     初始化一个GLEW库,确保OpenGL API对程序完全可用。
     在试图做任何渲染之前，要检查确定驱动程序的初始化过程中没有任何问题
     */
    GLenum status = glewInit();
    if (GLEW_OK != status) {
        
        printf(&quot;GLEW Error:%s\n&quot;,glewGetErrorString(status));
        return 1;
        
    }
</code></pre>

<ul>
<li>详细过程</li>
</ul>

<pre><code class="language-text">int main(int argc,char *argv[])
{
    gltSetWorkingDirectory(argv[0]);//设置当前工作目录，针对MAC OS X
    glutInit(&amp;argc, argv);          //初始化一个GLUT库
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL);//显示类型模式 
    glutInitWindowSize(800, 600);   //GLUT窗口大小、窗口标题
    glutCreateWindow(&quot;OpenGL_Demo&quot;);//创建一个窗口并定制窗口名
    glutReshapeFunc(changeSize);    //改变窗口大小
    glutDisplayFunc(RenderScene);   //绘图函数
    glutSpecialFunc(SpeacialKeys);  //键盘操作
    
    //初始化一个GLEW库,确保OpenGL API对程序完全可用
    GLenum status = glewInit();
    if (GLEW_OK != status) {
        printf(&quot;GLEW Error:%s\n&quot;,glewGetErrorString(status));
        return 1;
    }
    
    setupRC();//设置我们的渲染环境  
      
    glutMainLoop();//这是一个无限执行的循环,相当于RunLoop

    return  0;
    
}


/*
 在窗口大小改变时，接收新的宽度&amp;高度。
 */
void changeSize(int w,int h)
{
    /*
     x,y 参数代表窗口中视图的左下角坐标，而宽度、高度是像素为表示，通常x,y 都是为0
     */
    glViewport(0, 0, w, h);

}

/*
    绘制界面
*/
void RenderScene(void)
{    
     //清除一个或者一组特定的缓存区
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

    //2.设置一组浮点数来表示红色
    GLfloat vRed[] = {1.0,0.0,0.0,1.0f};

    //单元着色器(类型，颜色)
    //shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);

    //提交着色器
    triangleBatch.Draw();

    //将后台缓冲区进行渲染，然后结束后交换给前台
    glutSwapBuffers();

}


/*
    移动图形 -- 修改图形坐标！
*/
void SpeacialKeys(int key,int x,int y) {
    
    // ...
    
    glutPostRedisplay();//重新绘制
}


/*
    设置我们的渲染环境 
*/
void setupRC()
{
    //设置清屏颜色（背景颜色）
    glClearColor(0.2f, 0.40f, 0.7f, 1);

    //初始化一个渲染管理器,没有着色器，在OpenGL 核心框架中是无法进行任何渲染的。
    shaderManager.InitializeStockShaders();

    //指定顶点
    //矩形
    GLfloat blockSize = 0.1f;
    GLfloat vVerts[] = {
        -blockSize,-blockSize,0.0f,
        blockSize,-blockSize,0.0f,
        blockSize,blockSize,0.0f,
        -blockSize,blockSize,0.0f
    };

    triangleBatch.Begin(GL_TRIANGLE_FAN, 4);
    triangleBatch.CopyVertexData3f(vVerts);//复制顶点数据到批处理中  
    triangleBatch.End();

}
</code></pre>

<p><a href="https://github.com/Caolongs/OpenGLDemo.git">Demo地址</a></p>

<h2 id="toc_3">附</h2>

<pre><code class="language-text">    /*
     GLUT_RGBA:RGBA颜色值模式
     GLUT_DOUBLE:双缓存窗口
     GLUT_DEPTH：
     GLUT_STENCIL：
     */
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL);
</code></pre>

<pre><code class="language-text">    /* 清除一个或者一组特定的缓存区
     缓冲区是一块存在图像信息的储存空间，红色、绿色、蓝色和alpha分量通常一起分量通常一起作为颜色缓存区或像素缓存区引用。
     OpenGL 中不止一种缓冲区（颜色缓存区、深度缓存区和模板缓存区）
     清除缓存区对数值进行预置
     参数：指定将要清除的缓存的
     GL_COLOR_BUFFER_BIT :指示当前激活的用来进行颜色写入缓冲区
     GL_DEPTH_BUFFER_BIT :指示深度缓存区
     GL_STENCIL_BUFFER_BIT:指示模板缓冲区
     */
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

</code></pre>

<pre><code class="language-text">    
    /* 平面着色器
     0.传递到存储着色器，即GLT_SHADER_IDENTITY着色器，
     这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形
     1.平移矩阵 mTransformMatrix 与 每个顶点 相乘 -&gt; 新顶点 （顶点着色器）
     2.将片元着色红色 (片元着色器)
     */
     shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);
     
     
     //单元着色器(类型，颜色)---第一种方法用到的
     shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);
</code></pre>

<pre><code class="language-text">    //在开始的设置openGL 窗口的时候，我们指定要一个双缓冲区的渲染环境。
    //这就意味着将在后台缓冲区进行渲染，渲染结束后交换给前台。
    //这种方式可以防止观察者看到可能伴随着动画帧与动画帧之间的闪烁的渲染过程。
    //缓冲区交换平台将以平台特定的方式进行。
    //将后台缓冲区进行渲染，然后结束后交换给前台
    glutSwapBuffers();
</code></pre>

<p><img src="media/15176282030413/QQ20180203-0.jpg" alt="QQ20180203-0"/></p>
 -->
                        

                      </div>

                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
    
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/Caolongs" title="GitHub">GitHub</a>

  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="UML.html"><strong>UML</strong></a>
        
            <a href="%E6%91%84%E5%BD%B1.html"><strong>摄影</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="%E6%9E%B6%E6%9E%84.html"><strong>架构</strong></a>
        
            <a href="CI.html"><strong>CI</strong></a>
        
            <a href="OpenGL.html"><strong>OpenGL</strong></a>
        
            <a href="%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html"><strong>逆向与安全</strong></a>
        
            <a href="AI.html"><strong>AI</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91.html"><strong>音视频</strong></a>
        
            <a href="Shell.html"><strong>Shell</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16010179174173.html">Android基础入门路线图![androidmap_00](media/16010179174173/androidmap_00.jpg)</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16006805464877.html">Fragment 向 Activity 传值</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15927958863936.html">反射C函数</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15870916897984.html">Xcode 配置常用变量</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15668937540139.html">Python 读取xlsx文件</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
