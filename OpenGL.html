<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  OpenGL - 
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="https://github.com/Caolongs">Alongs</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="https://github.com/Caolongs">Alongs</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E5%B7%A5%E5%85%B7.html">工具</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="%E6%9E%B6%E6%9E%84.html">架构</a></li>
        
            <li><a href="CI.html">CI</a></li>
        
            <li><a href="OpenGL.html">OpenGL</a></li>
        
            <li><a href="%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html">逆向与安全</a></li>
        
            <li><a href="AI.html">AI</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91.html">音视频</a></li>
        
            <li><a href="Shell.html">Shell</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15263723434422.html">
                
                  <h1>OpenGL - 渲染过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、基本图形硬件流水线设计</h2>

<p><img src="media/15263723434422/15263724067540.jpg" alt=""/><br/>
<mark>应⽤用程序层 -&gt; 硬件抽象层 -&gt; 硬件层</mark></p>

<p><strong>应⽤层</strong>: 游戏和应⽤用层软件开发⼈人员为主体，通过调⽤用API进行上层开发，不需要考虑移植性问题。 <br/>
<strong>硬件抽象层</strong>: 抽象出硬件的加速功能，进行有利于应用层开发的封装，并向应⽤层开发API <br/>
<strong>硬件层</strong>: 将硬件驱动提供给抽象层，以实现抽象层加速功能的有效性。</p>

<h2 id="toc_1">二、渲染流水线的具体流程</h2>

<h3 id="toc_2">1、应⽤层</h3>

<p>应⽤程序层主要与内存，CPU打交道，诸如碰撞检测，场景图监理，视锥裁剪等经典算法在此阶段执行。在阶段的末端，几何体的数据(顶点坐标，法向量，纹理坐标，纹理)等通过数据总线传送到图形硬件</p>

<h3 id="toc_3">2、硬件抽象层</h3>

<p>在这⼀层，我们目前使用的是DirectX与OpenGL。对于这⼀部分，主要是⼀些API等的调⽤</p>

<h3 id="toc_4">3、硬件层</h3>

<p>硬件层在渲染流水线中最为复杂，也最为重要。可编程渲染流水线与固定渲染流水线的区别在于是否对着色器进⾏编程。<br/>
  ⾸先我们先了解固定渲染流水线它主要分为以下几个阶段:<br/>
  顶点变换 -&gt; 图元转配与光栅化 -&gt; ⽚段纹理映射和着色 -&gt; 光栅化操作</p>

<h2 id="toc_5">三、硬件层—固定渲染管线流程图</h2>

<p><img src="media/15263723434422/15263732132633.jpg" alt=""/></p>

<p><strong>光栅化(Rasterization)</strong>:将顶点数据转换为片元的过程! 将具体的图转化为一个个栅格组成的图像的作⽤<br/>
⽚元中每个一个元素对于帧缓存区的一个像素; 光栅化其实是一个将几何图元变成一个二维图像的过程!!<br/>
光栅化的过程就是为了产出⽚元</p>

<h2 id="toc_6">四、硬件层—可编程渲染流水线流程图</h2>

<p><img src="media/15263723434422/15263733597135.jpg" alt=""/></p>

<h2 id="toc_7">五、GPU 图形渲染管线</h2>

<p><img src="media/15263723434422/15263734882629.jpg" alt=""/></p>

<p><strong>应用程序阶段</strong><br/>
主要是⾼级编程语言开发,C,OC,C++ <br/>
输出:通过数据总线,把几何体的数据(顶点坐标\法线\纹理理坐标\纹理理)等传送到GPU上</p>

<p><strong>⼏何阶段</strong><br/>
输入:应⽤程序末端的内容 <br/>
负责任务:顶点坐标变换,光照,裁剪,投影,屏幕映射 <br/>
输出:经过变换和投影之后的屏幕坐标,颜⾊,纹理坐标</p>

<p><strong>光栅化阶段</strong><br/>
见上</p>

<h3 id="toc_8">光栅化操作</h3>

<p>这⼀步我们将会对其进行各种测试，⽽假如它通过了所有的测试，⽚段将会显示在屏幕上<br/>
<img src="media/15263723434422/15263750349578.jpg" alt=""/></p>

<p><strong>抖动显示</strong>:一种能够使用较少的颜色种类模拟较多颜色的显示模式</p>

<h3 id="toc_9">⼏何处理阶段</h3>

<p>几何阶段主要负责大部分多边形操作和顶点操作，包括顶点着色、坐标变换、生成图元、投影、<br/>
 裁剪、屏幕映射等过程，其中顶点着色、坐标变换由顶点着色器完成</p>

<ol>
<li><strong>顶点着⾊器</strong> </li>
<li><strong>⽣成图元</strong>： 顶点数组或索引数组经由顶点着色程序生成三角形的组合</li>
<li><strong>投影</strong>： 透视投影，平行投影</li>
<li><strong>裁切</strong>： 仅保留视景体内部的图元进行渲染</li>
<li><strong>屏幕映射</strong>： 这个阶段是不可配置也不可编程的。主要用来实现图元的坐标转换到屏幕坐标</li>
</ol>

<h2 id="toc_10">六、其他</h2>

<h3 id="toc_11">Shader</h3>

<p><strong>Shader</strong>，中⽂名，着色器。着⾊器其实就是一段在GPU运行的程序。我们平时的程序，是在CPU运行。由于GPU的硬件设计结构与CPU有着很大的不同，所以GPU需要一些新的编程语言</p>

<p>渲染流水线分为两种，其中一种为<strong>可编程渲染流水线</strong>。另外一种为<strong>固定渲染流水线</strong>。(也称可编程管线或固定管线，管线就是流⽔线的意思)。渲染流⽔线可否编程，取决于程序猿能否在顶点着色器以及⽚段着色器上进⾏行编码。⽽现在的渲染流水线，基本都是可编程的，当然，它们也支持固定渲染流水线的功能</p>

<h3 id="toc_12">CPU 与 GPU 之间的关系</h3>

<p>GPU具有⾼并行的结构，所以在处理图形数据和复杂算法比CPU更加有效率</p>

<p><img src="media/15263723434422/15263738384864.jpg" alt=""/></p>

<p>CPU在执行任务的时候，⼀个时刻只会处理⼀个数据，不存在真正意义上的并行，⽽GPU则有多个处理器核，在⼀个时刻可以并行处理多个数据</p>

<h3 id="toc_13">三维坐标转变为二维屏幕坐标的过程</h3>

<p><img src="media/15263723434422/15263754091644.jpg" alt=""/></p>

<p>MC是建模坐标系，WC是世界坐标系，VC是观察坐标系，PC是投影坐标系，NPC是规格化投影坐标系，DC是设备坐标系</p>

<h3 id="toc_14">坐标系详细概念</h3>

<ul>
<li><strong>世界坐标系</strong> 坐标系统主要⽤于计算机图形场景中的所有图形对象的空间定位和定义</li>
<li><strong>局部坐标系</strong> 独立于世界坐标系来定义物体几何特性</li>
<li><strong>观察坐标系</strong> 观察坐标系通常是以视点的位置为原点，通过⽤户指定的一个向上的观察向量来定义整个坐标系统，观察坐标系主要⽤于从观察者的角度对整个世界坐标系内的对象进行重新定位和描述，从而简化⼏何物体在投影面的成像的数学推导和计算</li>
<li><strong>投影坐标系</strong> 物体从世界坐标描述转换到观察坐标后，可将三维物体投影到二维表面上，即投影到虚拟摄像机的胶片上，这个过程就是投影变换。以胶片中心为参考原点的空间坐标系称为投影坐标系，物体在投影坐标系中的坐标称为投影坐标。</li>
<li><strong>设备坐标系</strong> 是图形设备上采用的与具体设备相关的坐标系。设备坐标系一般采⽤用整数坐标，其坐标范围由具体设备的分辨率决定。设备坐标系上的⼀个点一般对应图形设备上的一个像素。由于具体设备的限制，设备坐标系的坐标范围一般是有限的。</li>
<li><strong>规格化设备坐标系</strong> 是为了避免设备相关性而定义的一种虚拟的设备坐标系。规格化坐标系的坐标范围一般从0到1，也有的是从-1到+1。采用规格化设备坐标系的好处是屏蔽了具体设备的分辨率，使得图形处理理能够尽量避开对具体设备坐标的考虑。实际图形处理时，先将世界坐标转换成对应的规格化设备坐标，然后再将规格化设备坐标映射到具体的设备坐标上去。</li>
<li><strong>屏幕坐标系统</strong> 也称设备坐标系统，它主要⽤于某⼀特殊的计算机图形显示设备(如光栅显示器)的表⾯的点的定义，在多数情况下，对于每一个具体的显示设备，都有一个单独的坐标系统，在定义了成像窗口的情况下，可进一步在屏幕坐标系统中定义称为视图区(view port)的有界区域，视图区中的成像即为实际所观察到的。</li>
</ul>

<h2 id="toc_15">参照</h2>

<p>简书 MissCC： <a href="https://www.jianshu.com/u/1b4c832fb2ca">简书 MissCC</a></p>

<ul>
<li>
<a href="#toc_0">一、基本图形硬件流水线设计</a>
</li>
<li>
<a href="#toc_1">二、渲染流水线的具体流程</a>
<ul>
<li>
<a href="#toc_2">1、应⽤层</a>
</li>
<li>
<a href="#toc_3">2、硬件抽象层</a>
</li>
<li>
<a href="#toc_4">3、硬件层</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">三、硬件层—固定渲染管线流程图</a>
</li>
<li>
<a href="#toc_6">四、硬件层—可编程渲染流水线流程图</a>
</li>
<li>
<a href="#toc_7">五、GPU 图形渲染管线</a>
<ul>
<li>
<a href="#toc_8">光栅化操作</a>
</li>
<li>
<a href="#toc_9">⼏何处理阶段</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">六、其他</a>
<ul>
<li>
<a href="#toc_11">Shader</a>
</li>
<li>
<a href="#toc_12">CPU 与 GPU 之间的关系</a>
</li>
<li>
<a href="#toc_13">三维坐标转变为二维屏幕坐标的过程</a>
</li>
<li>
<a href="#toc_14">坐标系详细概念</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">参照</a>
</li>
</ul>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15263715509093.html">
                
                  <h1>Open GL - GLSL着色器语言</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>GLSL(OpenGL Shading Language) 是一个以C语言为基础的高阶着色语言</p>

<h2 id="toc_0">作用</h2>

<p>可用于 OpenGL 可编程管线<br/>
能够让你对OpenGL渲染其中的一些着色环节来自定义（如顶点着色器，片元着色器）<br/>
类似UIVIewController的自定义控件</p>

<p>固定管线<br/>
相当于已经封装了的高级API，让你通过传递参数来实现效果</p>

<h2 id="toc_1">自定义环节</h2>

<ul>
<li>顶点着色器： 处理每个顶点，确定位置以及变换</li>
<li>片元着色器： 片元</li>
</ul>

<h2 id="toc_2">GLSL 数据类型</h2>

<ul>
<li>void – 用于没有返回值的函式</li>
<li>bool – 条件类型，其值可以是真或假</li>
<li>int – 带负号整数</li>
<li>float – 浮点数</li>
<li>vec2 – 2 个浮点数组成的向量</li>
<li>vec3 – 3 个浮点数组成的向量</li>
<li>vec4 – 4 个浮点数组成的向量</li>
<li>bvec2 – 2 个布尔组成的向量</li>
<li>bvec3 – 3 个布尔组成的向量</li>
<li>bvec4 – 4 个布尔组成的向量</li>
<li>ivec2 – 2 个整数组成的向量</li>
<li>ivec3 – 3 个整数组成的向量</li>
<li>ivec4 – 4 个整数组成的向量</li>
<li>mat2 – 浮点数的 2X2 矩阵</li>
<li>mat3 – 浮点数的 3X3 矩阵</li>
<li>mat4 – 浮点数的 4X4 矩阵</li>
<li>sampler1D – 用来存取一维纹理的句柄（handle）（或：操作，作名词解。）</li>
<li>sampler2D – 用来存取二维纹理的句柄</li>
<li>sampler3D – 用来存取三维纹理的句柄</li>
<li>samplerCube – 用来存取立方映射纹理的句柄</li>
<li>sampler1Dshadow – 用来存取一维深度纹理的句柄</li>
<li>sampler2Dshadow – 用来存取二维深度纹理的句柄</li>
</ul>

<h2 id="toc_3">存储修饰符</h2>

<p><strong>1. 常量修饰符 const</strong></p>

<pre><code class="language-text">1. 任何使用const声明的变量在其所属的着色器中均是只读的。
2. const 用来修饰任何基本数据类型
3. const 不能用来修饰包含数组的数组、结构体
</code></pre>

<p><strong>2. Attribute</strong></p>

<pre><code class="language-text">1. 用于修饰声明通过OpenGL ES 应用程序传递顶点着色器的变量值，在其他任何非顶点着⾊器的着色器程序中声明attribute变量是错误的
</code></pre>

<p><strong>3. Uniform</strong></p>

<pre><code class="language-text">1. ⽤来修饰那些被整个图元在被处理过程中保持不变的全局变量
2. 所有uniform变量都是只读的
3. uniform修饰符可以和任意基本数据类型一起使用，或者包含基本数据类型元素的数组和结构体
</code></pre>

<p><strong>4. Varying</strong></p>

<pre><code class="language-text">1. varying变量提供了顶点着⾊器，⽚元着色器和二者通讯控制模块之间的接口
2. 顶点着⾊器计算每个顶点的值(颜⾊，纹理坐标等)并将它们写到 varying 变量中。顶点着⾊器也会从 varying 变量中读值，获取和它写入相同的值
3. ⽚元着⾊器会读取varying变量的值，并且被读取的值将会作为插值器，作为图元中片元位置的一个功能信息。varying 变量对于⽚元着⾊器来说是只读的。
</code></pre>

<h2 id="toc_4">精度修饰符</h2>

<p><strong>highp</strong>：  浮点数的范围 (-2<sup>62</sup> - 2<sup>62)</sup> ，整型范围 (-2<sup>16</sup> - 2<sup>16)</sup><br/>
<strong>mediump</strong>：浮点数的范围 (-2<sup>14</sup> - 2<sup>14)，</sup> 整型范围 (-2<sup>10</sup> - 2<sup>10)</sup><br/>
<strong>lowp</strong>：   浮点数的范围 (-2,2)，         整型范围(-2<sup>8</sup> - 2<sup>8)</sup></p>

<h2 id="toc_5">官方的shader范例:</h2>

<h3 id="toc_6">Vertex Shader:</h3>

<pre><code class="language-text">uniform mat4 mvp_matrix; //透视矩阵 * 视图矩阵 * 模型变换矩阵
uniform mat3 normal_matrix; //法线变换矩阵(用于物体变换后法线跟着变换)
uniform vec3 ec_light_dir; //光照方向
attribute vec4 a_vertex; // 顶点坐标
attribute vec3 a_normal; //顶点法线
attribute vec2 a_texcoord; //纹理坐标
varying float v_diffuse; //法线与入射光的夹角
varying vec2 v_texcoord; //2d纹理坐标
void main(void)
{
 //归一化法线
 vec3 ec_normal = normalize(normal_matrix * a_normal);
 //v_diffuse 是法线与光照的夹角.根据向量点乘法则,当两向量长度为1是 乘积即cosθ值
 v_diffuse = max(dot(ec_light_dir, ec_normal), 0.0);
 v_texcoord = a_texcoord;
 gl_Position = mvp_matrix * a_vertex;
}
</code></pre>

<h3 id="toc_7">Fragment Shader:</h3>

<pre><code class="language-text">precision mediump float;
uniform sampler2D t_reflectance;
uniform vec4 i_ambient;
varying float v_diffuse;
varying vec2 v_texcoord;
void main (void)
{
 vec4 color = texture2D(t_reflectance, v_texcoord);
 //这里分解开来是 color*vec3(1,1,1)*v_diffuse + color*i_ambient
 //色*光*夹角cos + 色*环境光
 gl_FragColor = color*(vec4(v_diffuse) + i_ambient);
}
</code></pre>

<h2 id="toc_8">目录</h2>

<ul>
<li>
<a href="#toc_0">作用</a>
</li>
<li>
<a href="#toc_1">自定义环节</a>
</li>
<li>
<a href="#toc_2">GLSL 数据类型</a>
</li>
<li>
<a href="#toc_3">存储修饰符</a>
</li>
<li>
<a href="#toc_4">精度修饰符</a>
</li>
<li>
<a href="#toc_5">官方的shader范例:</a>
<ul>
<li>
<a href="#toc_6">Vertex Shader:</a>
</li>
<li>
<a href="#toc_7">Fragment Shader:</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">目录</a>
</li>
</ul>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15263712692654.html">
                
                  <h1>OpenGL 常见概念性理解整理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">什么叫光栅化（Rasterize/rasteriztion）？</h3>

<p>栅格化或者像素化，就是把矢量图形转化成像素点儿的过程</p>

<p>我们屏幕上显示的画面都是由像素组成，而三维物体都是点线面构成的。要让点线面，变成能在屏幕上显示的像素，就需要Rasterize这个过程。就是从矢量的点线面的描述，变成像素的描述</p>

<h3 id="toc_1">图元是什么？</h3>

<p>图元可以理解为组成图形的基本单元<br/>
 比如点、线、三角形。 我们可以通过一系列函数或顶点数据帮助我们实现多种多样的图形。</p>

<h3 id="toc_2">什么叫管线？</h3>

<p>管线(pipeline),可以理解为渲染流水线。<strong>管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程</strong>。<br/>
图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>

<h3 id="toc_3">什么叫固定管线？</h3>

<p>可以简单理解为渲染图像的这个过程，我们只能通过调用GLShaderManager类的固定管线效果实现我们一系列的着色器处理。</p>

<h3 id="toc_4">什么可编程管线？</h3>

<p>可以简单理解， 在我们处理图形的过程，我们必须使用顶点着色器和片元着色过程。我们可以才有GLSL自行编写着色器程序，来执行这个过程的事情。</p>

<h3 id="toc_5">顶点着色器调⽤次数与⽚元着⾊器调⽤次数与什么有关?谁⽐较多?</h3>

<p>片元着⾊色器次数比较多!<br/>
顶点着色器调⽤次数与顶点数量相关，<br/>
⽚元着色器调用与像素多少相关</p>

<h3 id="toc_6">为什么需要对三维空间的顶点进行坐标空间转换?</h3>

<p>输⼊到计算机当中一系列三维坐标的点,但是我们看到的屏<br/>
幕是二维坐标点.所以需要转换<br/>
ObjectSpace(物体空间/模型空间)-&gt; WorldSpace(世界空<br/>
间)-&gt;EyeSpace(观察空间)-&gt;ClicpAndProjectSpace(屏幕<br/>
空间)</p>

<h3 id="toc_7">在OpenGL 中有5种坐标系。</h3>

<p>1.局部坐标系(物体空间)<br/>
2.世界空间<br/>
3.观察空间(视觉空间)<br/>
4.裁剪空间<br/>
5.屏幕空间</p>

<p>这是一个顶点最终转化到片段之前需要经历的所有不同的状态变化。</p>

<p>那这些变换通过什么？<br/>
比如模型、观察、投影三个矩阵的。<br/>
<img src="media/15263712692654/15264383184522.jpg" alt=""/></p>

<h3 id="toc_8">背面剔除和深度测试使用场景</h3>

<p>背面剔除是为了解决自身图片背部可见问题<br/>
深度测试是为了解决图形重叠的问题</p>

<h3 id="toc_9">Shader</h3>

<p><strong>Shader</strong>，中⽂名，着色器。着⾊器其实就是一段在GPU运行的程序（图形硬件设计所执行的一类特殊的函数，可以理解为图像处理单元（GPU）编译的一种小型程序）。<br/>
我们平时的程序，是在CPU运行。由于GPU的硬件设计结构与CPU有着很大的不同，所以GPU需要一些新的编程语言</p>

<h3 id="toc_10">术语理解</h3>

<p><strong>渲染</strong>:表示计算机从模型创建最终图像的过程。OpenGL 只是一种基于光栅化的系统。<br/>
<strong>模型（场景对象）</strong>：通过几何图元（点、线、三角形）来构建的。<br/>
<strong>着色器</strong>，它是图形硬件设计所执行的一类特殊的函数。可以理解为图像处理单元（GPU）编译的一种小型程序。<br/>
<strong>四种不同的着色阶段（shander stage）</strong>，其中最常用的包括顶点着色器（vertex shader）以及片元着色器，前者用于处理顶点数据，后者用于处理光栅化后的片元数据。所有OpenGL程序都需要用到这两类着色器<br/>
<strong>帧缓存（framebuffer）</strong>，像素（pixel），是显示器上最小的可见单元。计算机系统将所有的像素保存到帧缓存当中，后者是有图形硬件设备管理的一块独立内存区域，可以直接映射到最终的显示设备上</p>

<h3 id="toc_11">OpenGL 渲染图像的OpenGL 程序需要执行的操作：</h3>

<ul>
<li>从OpenGL的几何图元中设置数据，用于构建形状。</li>
<li>使用不同的着色器（shader）对输入的图元数据执行计算操作，判断它们的位置、颜色，以及其他渲染属性。</li>
<li>将输入图元的数学描述转化为与屏幕位置对应的像素片元（fragment）。这一步也称为光栅化（rasterization）。</li>
<li>最后，针对光栅化过程产生的每个片元，执行片元着色器（fragment shader），从而决定这个片元的最终颜色和位置。</li>
<li>如果有必要，还需要对每个片元执行一些额外的操作，例如判断片元对应的对象是否可见，或者将片元的颜色与当前屏幕位置的颜色进行融合。</li>
</ul>

<h3 id="toc_12">OpenGL 常见流程</h3>

<p><img src="media/15262868956417/15262888985785.jpg" alt=""/></p>

<ul>
<li>顶点着色器 和 片元着色器是必需的。细分和几何着色器是可选的捕捉。</li>
<li>OpenGL 需要将所有的数据都保存到缓存对象中（buffer object）</li>
</ul>

<h3 id="toc_13">屏幕渲染⽅式</h3>

<h4 id="toc_14">On-Screen Rendering(当前屏幕渲染)</h4>

<p>指的是GPU的渲染操作是在当前用于显示的屏幕缓存区中进行的。</p>

<h4 id="toc_15">Off-Screen Rendering(离幕渲染)</h4>

<p>指的是GPU在当前屏幕缓存区以外新开辟一个缓存区进行渲染操作</p>

<p>一般情况下，OpenGL ES 会将应用提供到渲染服务的动画直接渲染显示(使用基本的渲染的流程) 但对于一些复杂的图像动画的渲染，并不能够直接渲染叠加显示出来。而是需要根据 <code>Command Buffer</code> 分通道进⾏行渲染再组合。这个组合过程中，就有些渲染通道是不会直接显示出来的。标记此次渲染需要更多的渲染通道和合并步骤，⽽这些没有直接渲染显示在屏幕上的通道就是离屏渲染通道。</p>

<h4 id="toc_16">离屏渲染为什么会卡顿?</h4>

<p>离屏渲染需要更多的渲染通道，而不同的渲染通道间切换需要消耗⼀定的时间，这个时间内GPU会闲置。当通道数量足够时，对性能也会较大的影响。</p>

<h3 id="toc_17">离屏渲染的体现</h3>

<h4 id="toc_18">1、相⽐于当前屏幕渲染，离屏渲染的代价相对⽽言较高。主要有以下2个原因:</h4>

<p>1.创建新的缓存区<br/>
2.上下文切换</p>

<h4 id="toc_19">2、那些情况会使⽤离屏渲染(off-Screen Render)?</h4>

<ol>
<li>drawRect</li>
<li>layer.shouldRasterize = true; </li>
<li>有mask或者阴影(layer.makesToBounds) shouldRasterize(光栅化)、masks(遮罩)、shadows(阴影) edge antialiasing(抗锯⻮齿)、group opacity(不不透明)</li>
<li>Text(UILabel,CATextLayer,CoreText)</li>
</ol>

<h2 id="toc_20">参照</h2>

<p><a href="https://www.jianshu.com/p/fac6c39deec7">OpenGL 绘制基础图形</a></p>

<p>简书 MissCC： <a href="https://www.jianshu.com/u/1b4c832fb2ca">简书 MissCC</a></p>

<h2 id="toc_21">目录</h2>

<ul>
<li>
<a href="#toc_0">什么叫光栅化（Rasterize/rasteriztion）？</a>
</li>
<li>
<a href="#toc_1">图元是什么？</a>
</li>
<li>
<a href="#toc_2">什么叫管线？</a>
</li>
<li>
<a href="#toc_3">什么叫固定管线？</a>
</li>
<li>
<a href="#toc_4">什么可编程管线？</a>
</li>
<li>
<a href="#toc_5">顶点着色器调⽤次数与⽚元着⾊器调⽤次数与什么有关?谁⽐较多?</a>
</li>
<li>
<a href="#toc_6">为什么需要对三维空间的顶点进行坐标空间转换?</a>
</li>
<li>
<a href="#toc_7">在OpenGL 中有5种坐标系。</a>
</li>
<li>
<a href="#toc_8">背面剔除和深度测试使用场景</a>
</li>
<li>
<a href="#toc_9">Shader</a>
</li>
<li>
<a href="#toc_10">术语理解</a>
</li>
<li>
<a href="#toc_11">OpenGL 渲染图像的OpenGL 程序需要执行的操作：</a>
</li>
<li>
<a href="#toc_12">OpenGL 常见流程</a>
</li>
<li>
<a href="#toc_13">屏幕渲染⽅式</a>
<ul>
<li>
<a href="#toc_14">On-Screen Rendering(当前屏幕渲染)</a>
</li>
<li>
<a href="#toc_15">Off-Screen Rendering(离幕渲染)</a>
</li>
<li>
<a href="#toc_16">离屏渲染为什么会卡顿?</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">离屏渲染的体现</a>
<ul>
<li>
<a href="#toc_18">1、相⽐于当前屏幕渲染，离屏渲染的代价相对⽽言较高。主要有以下2个原因:</a>
</li>
<li>
<a href="#toc_19">2、那些情况会使⽤离屏渲染(off-Screen Render)?</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_20">参照</a>
<ul>
<li>
<a href="#toc_21">目录</a>
</li>
</ul>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15263696340511.html">
                
                  <h1>OpenGL FrameBuffer Objects,RenderBuffer Objects and Textures</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">RenderBuffer</h3>

<blockquote>
<p>A renderbuffer object is a 2D image buffer allocated by the application. The renderbuffer can be used to allocate and store color, depth, or stencil values and can be used as a color, depth, or stencil attachment in a framebuffer object. A renderbuffer is similar to an off-screen window system provided drawable surface, such as a pbuffer. A renderbuffer, however, cannot be directly used as a GL texture.</p>

<p>渲染缓冲区对象是由应用程序分配的2D图像缓冲区。渲染缓冲区可用于分配和存储颜色，深度或模板值，并可用作帧缓冲区对象中的颜色，深度或模板附件。渲染缓冲器类似于提供可绘制表面的离屏窗口系统，例如pbuffer。但是，渲染缓冲区不能直接用作GL纹理。</p>
</blockquote>

<h3 id="toc_1">FrameBuffer</h3>

<blockquote>
<p>A framebuffer object (often referred to as an FBO) is a collection of color, depth, and stencil buffer attachment points; state that describes properties such as the size and format of the color, depth, and stencil buffers attached to the FBO; and the names of the texture and renderbuffer objects attached to the FBO. Various 2D images can be attached to the color attachment point in the framebuffer object. These include a renderbuffer object that stores color values, a mip-level of a 2D texture or a cubemap face, or even a mip-level of a 2D slice in a 3D texture. Similarly, various 2D images contain- ing depth values can be attached to the depth attachment point of an FBO. These can include a renderbuffer, a mip-level of a 2D texture or a cubemap face that stores depth values. The only 2D image that can be attached to the stencil attachment point of an FBO is a renderbuffer object that stores stencil values.</p>

<p>⼀个 frameBuffer 对象(通常被称为⼀个FBO)。是一个收集颜色、深度和模板缓存区的附着点。描述属性的状态，例如颜⾊、深度和模板缓存区的大小和格式，都关联到FBO(Frame Buffer Object)。并且纹理的名字和 renderBuffer 对象也都是关联于FBO。各种各样的2D图形能够被附着framebuffer对象的颜色附着点。它们包含了renderbuffer对象存储的颜⾊色值、⼀个2D纹理或⽴方体贴图。或者⼀一个mip-level的二维切面在 3D纹理。同样，各种各样的2D图形包含了当时的深度值可以附加到⼀个FBO的深度附着点中去。唯⼀的⼆维图像，能够附着在FBO的模板附着点，是一个renderbuffer对象存储模板值。</p>
</blockquote>

<p><img src="media/15263696340511/15263708418675.jpg" alt="FrameBuffer Objects,RenderBuffer Objects and Textures"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15263628382501.html">
                
                  <h1>OpenGL 与 OpenGL ES</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、什么是图形编程接⼝</h2>

<p><strong>2D图形编程接⼝</strong>: GDI, Skiz, OpenVG <br/>
<strong>3D图形编程接口</strong>: DirectX, OpenGL/OpenGL ES, Embedded Systems</p>

<h2 id="toc_1">二、图形编程接口与图形硬件的关系</h2>

<p>OpenGL，图形编程的接口<br/>
GPU 图形硬件，图形处理器</p>

<p>简单理解为：</p>

<blockquote>
<p>当应用需要图形的绘制以及渲染时，它会通过OpenGL ES框架，向GPU传输相应绘制指令，GPU收到指令后会进行相应操作），最终将渲染结果在屏幕上绘制出来。</p>
</blockquote>

<h2 id="toc_2">三、OpenGL 的特点</h2>

<p>1.跨操作系统平台运⾏<br/>
2.隐藏底层硬件信息 <br/>
3.专⽤渲染接⼝</p>

<h2 id="toc_3">四、OpenGL ES</h2>

<p>OpenGL for Embedded Systems（OpenGL ES）是OpenGL的简化版本（专门为嵌入式系统设计，在移动端操作系统中应用广泛），该版本消除了冗余功能，提供了更易学习且易于在移动图形硬件中实现的库。</p>

<h2 id="toc_4">五、OpenGL ES 的版本</h2>

<ul>
<li>OpenGL ES 1.X :针对固定功能流⽔水管线硬件 </li>
<li>OpenGL ES 2.X :针对可编程流⽔水管线硬件 </li>
<li>OpenGL ES 3.X :OpenGL ES 2.0的扩展</li>
</ul>

<h2 id="toc_5">六、着色器渲染过程</h2>

<p>在渲染过程中，必须存储2种着色器，分别是顶点着色器、片元着色器。顶点着色器是第一个着⾊器、片元着色器是最后一个。顶点着⾊器中处理顶点、片元着⾊器处理理像素点颜⾊。<br/>
<img src="media/15263628382501/15263637921501.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15212766930412.html">
                
                  <h1>OpenGL ES - - GLKit（GLKBaseEffect）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>Speed up OpenGL ES or OpenGL app development. Use math libraries, background texture loading, pre-created shader effects, and a standard view and view controller to implement your rendering loop.<br/>
加快OpenGL ES或OpenGL应用程序开发。 使用数学库，背景纹理加载，预先创建的着色器效果以及标准视图和视图控制器来实现渲染循环。</p>
</blockquote>

<p><img src="media/15212766930412/GLKit.png" alt="GLKit"/></p>

<h3 id="toc_0">以一个简单的案例来使用 GLKBaseEffect</h3>

<blockquote>
<p>GLKBaseEffect is designed to simplify visual effects common to many OpenGL applications today. <br/>
 GLKBaseEffect旨在简化当今许多OpenGL应用程序常见的视觉效果。</p>

<p>GLKBaseEffect is program based and, with the binding of its underlying GLSL program<br/>
GLKBaseEffect是基于程序的，并且通过其基础GLSL程序的绑定</p>

<p>GLKBaseEffect requires at least an OpenGL Core Profile.  An appropriate context must be created and made current prior to instantiating and initializing GLKBaseEffect objects.</p>
</blockquote>

<h4 id="toc_1">使用GLKBaseEffect的规范步骤是</h4>

<ul>
<li><p>(1) 分配并初始化GLKBaseEffect的一个实例</p>
<pre><code class="language-text">directionalLightEffect = [[GLKBaseEffect alloc] init];
</code></pre></li>
<li><p>(2) 在效果上设置所需的属性</p>
<pre><code class="language-text"> // Configure light0
  directionalLightEffect.light0.position = lightPosition;<br/>
  directionalLightEffect.light0.diffuseColor = diffuseColor;<br/>
  directionalLightEffect.light0.ambientColor = ambientColor;<br/>
  // Configure material<br/>
  directionalLightEffect.material.diffuseColor = materialDiffuseColor;<br/>
  directionalLightEffect.material.ambientColor = materialAmbientColor;<br/>
  directionalLightEffect.material.specularColor = materialSpecularColor;<br/>
  directionalLightEffect.material.shininess = 10.0;
</code></pre></li>
<li><p>(3) 优选用顶点数组对象初始化顶点属性/顶点数组状态为要绘制的模型或场景</p>
<pre><code class="language-text">    glGenVertexArraysOES(1, &amp;vaoName);
    glBindVertexArrayOES(vaoName);<br/>
  // 为每个顶点属性创建并初始化VBO<br/>
  // 下面的例子展示了一个设置位置顶点属性的例子.<br/>
  // 为每个额外的所需属性重复以下步骤：normal，color，texCoord0，texCoord1.<br/>
  glGenBuffers(1, &amp;positionVBO);<br/>
  glBindBuffer(GL_ARRAY_BUFFER, positionVBO);<br/>
  glBufferData(GL_ARRAY_BUFFER, vboSize, dataBufPtr, GL_STATIC_DRAW);<br/>
  glVertexAttribPointer(GLKVertexAttribPosition, size, type, normalize, stride, NULL);<br/>
  glEnableVertexAttribArray(GLKVertexAttribPosition);<br/>
  ...针对其他所需的顶点属性重复上述步骤<br/>
  glBindVertexArrayOES(0);   // unbind the VAO we created above
</code></pre></li>
<li><p>(4) 对于每个绘制的帧：更新每帧更改的属性。 通过调用 - [GLKBaseEffect prepareToDraw] 同步更改的效果状态。用效果画出模型.  用效果画出模型</p>
<pre><code class="language-text">    directionalLightEffect.transform.modelviewMatrix = modelviewMatrix;
    [directionalLightEffect prepareToDraw];<br/>
    glBindVertexArrayOES(vaoName);<br/>
    glDrawArrays(GL_TRIANGLE_STRIP, 0, vertCt);
</code></pre></li>
</ul>

<p>详细代码：<a href="https://github.com/Caolongs/OpenGL-ES---GLKit">DEMO</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15211019198288.html">
                
                  <h1>OpenGL ES - GLSL</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>不采用GLKBaseEffect，使用编译链接自定义的着色器（shader）。用简单的glsl语言来实现顶点、片元着色器，并图形进行简单的变换。</p>

<p><img src="media/15211019198288/OpenGL%20ES%20-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8-.png" alt="OpenGL ES -自定义的着色器-"/></p>

<h3 id="toc_0">一、创建图层</h3>

<p><code>CAEAGLLayer</code></p>

<blockquote>
<p>/* CAEAGLLayer is a layer that implements the EAGLDrawable protocol,<br/>
 * allowing it to be used as an OpenGLES render target. Use the<br/>
 * `drawableProperties&#39; property defined by the protocol to configure<br/>
 * the created surface. */</p>

<p>CAEAGLLayer是一个实现EAGLDrawable协议的层，<br/>
  *允许它用作OpenGLES渲染目标。 使用<br/>
  *协议定义的`drawableProperties&#39;属性进行配置<br/>
  *创建的表面。</p>
</blockquote>

<ol>
<li>创建图层</li>
<li><p>设置放大倍数</p>
<pre><code class="language-text">[self setContentScaleFactor:[[UIScreen mainScreen]scale]];
</code></pre></li>
<li><p>将图层设为不透明（默认是透明的）</p>
<pre><code class="language-text">self.myEagLayer.opaque = YES;
</code></pre></li>
<li><p>设置 <code>drawableProperties</code> 属性,这里设置不维持渲染内容以及颜色格式为RGBA8</p>
<pre><code class="language-text">self.myEagLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:false],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat,nil];
</code></pre></li>
</ol>

<pre><code class="language-text">/************************************************************************/
/* Keys for EAGLDrawable drawableProperties dictionary                  */
/*                                                                      */
/* kEAGLDrawablePropertyRetainedBacking:                                */
/*  Type: NSNumber (boolean)                                            */
/*  Legal Values: True/False                                            */
/*  Default Value: False                                                */
/*  Description: True if EAGLDrawable contents are retained after a     */
/*               call to presentRenderbuffer.  False, if they are not   */
/*                                                                      */
/* kEAGLDrawablePropertyColorFormat:                                    */
/*  Type: NSString                                                      */
/*  Legal Values: kEAGLColorFormat*                                     */
/*  Default Value: kEAGLColorFormatRGBA8                                */
/*  Description: Format of pixels in renderbuffer                       */
/************************************************************************/
</code></pre>

<ul>
<li>kEAGLDrawablePropertyRetainedBacking: 表示绘图表面显示后，是否保留其内容。这个key的值，是一个通过NSNumber包装的bool值。如果是false，则显示内容后不能依赖于相同的内容，ture表示显示后内容不变。一般只有在需要内容保存不变的情况下，才建议设置使用,因为会导致性能降低、内存使用量增减。一般设置为flase.</li>
<li>kEAGLDrawablePropertyColorFormat: 可绘制表面的内部颜色缓存区格式，这个key对应的值是一个NSString指定特定颜色缓存区对象。默认是kEAGLColorFormatRGBA8
<ul>
<li>kEAGLColorFormatRGBA8：32位RGBA的颜色，4*8=32位</li>
<li>kEAGLColorFormatRGB565：16位RGB的颜色，</li>
<li>kEAGLColorFormatSRGBA8：sRGB代表了标准的红、绿、蓝，即CRT显示器、LCD显示器、投影机、打印机以及其他设备中色彩再现所使用的三个基本色素。sRGB的色彩空间基于独立的色彩坐标，可以使色彩在不同的设备使用传输中对应于同一个色彩坐标体系，而不受这些设备各自具有的不同色彩坐标的影响。</li>
</ul></li>
</ul>

<h3 id="toc_1">二、创建上下文</h3>

<ol>
<li><p>指定OpenGL ES 渲染API版本，我们使用2.0</p>
<pre><code class="language-text">EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2;
</code></pre></li>
<li><p>创建图形上下文</p>
<pre><code class="language-text">EAGLContext *context = [[EAGLContext alloc] initWithAPI:api];
</code></pre></li>
<li><p>判断是否创建成功</p>
<pre><code class="language-text">if (!context) {
    NSLog(@&quot;Create context failed!&quot;);<br/>
    return;<br/>
}
</code></pre></li>
<li><p>设置图形上下文</p>
<pre><code class="language-text">if (![EAGLContext setCurrentContext:context]) {
    NSLog(@&quot;setCurrentContext failed!&quot;);<br/>
    return;<br/>
}
</code></pre></li>
<li><p>将局部context，变成全局的</p>
<pre><code class="language-text">self.myContext = context;
</code></pre></li>
</ol>

<h3 id="toc_2">三、清空缓存区</h3>

<ol>
<li><p>导入框架#import <OpenGLES/ES2/gl.h></p></li>
<li><p>创建2个帧缓存区，渲染缓存区，帧缓存区</p>
<pre><code class="language-text"> @property (nonatomic , assign) GLuint myColorRenderBuffer;
 @property (nonatomic , assign) GLuint myColorFrameBuffer;
</code></pre></li>
<li><p>清空缓存区 </p>
<pre><code class="language-text">glDeleteBuffers(1, &amp;_myColorRenderBuffer);
self.myColorRenderBuffer = 0;<br/>
glDeleteBuffers(1, &amp;_myColorFrameBuffer);<br/>
self.myColorFrameBuffer = 0;
</code></pre></li>
</ol>

<h3 id="toc_3">四、设置RenderBuffer</h3>

<ol>
<li><p>定义一个缓存区</p>
<pre><code class="language-text">GLuint buffer;
</code></pre></li>
<li><p>申请一个缓存区标志</p>
<pre><code class="language-text">glGenRenderbuffers(1, &amp;buffer);
//同 glGenRenderbuffers(1, &amp;buffer);<br/>
//赋值<br/>
self.myColorRenderBuffer = buffer;
</code></pre></li>
<li><p>将标识符绑定到GL_RENDERBUFFER</p>
<pre><code class="language-text">glBindRenderbuffer(GL_RENDERBUFFER, self.myColorRenderBuffer);
</code></pre></li>
<li><p>myColorRenderBuffer渲染缓存区分配存储空间</p>
<pre><code class="language-text">[self.myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.myEagLayer];
</code></pre>
<pre><code class="language-text">注意：frame buffer仅仅是管理者，不需要分配空间；
render buffer的存储空间的分配，对于不同的render buffer，使用不同的API进行分配，<br/>
而只有分配空间的时候，render buffer句柄才确定其类型
</code></pre></li>
</ol>

<h3 id="toc_4">五、设置FrameBuffer</h3>

<ol>
<li><p>定义一个缓存区</p>
<pre><code class="language-text">GLuint buffer;
</code></pre></li>
<li><p>申请一个缓存区标志</p>
<pre><code class="language-text">glGenRenderbuffers(1, &amp;buffer);
//赋值<br/>
self.myColorFrameBuffer = buffer;
</code></pre></li>
<li><p>将标识符绑定到GL_FRAMEBUFFER</p>
<pre><code class="language-text">glBindFramebuffer(GL_FRAMEBUFFER, self.myColorFrameBuffer);
</code></pre></li>
<li><p>renderbuffer跟framebuffer进行绑定,将_myColorRenderBuffer 通过glFramebufferRenderbuffer函数绑定到GL_COLOR_ATTACHMENT0上。</p>
<pre><code class="language-text">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.myColorRenderBuffer);
</code></pre>
<p>//接下来，可以调用OpenGL ES进行绘制处理，最后则需要在EGALContext的OC方法进行最终的渲染绘制。这里渲染的color buffer,这个方法会将buffer渲染到CALayer上。- (BOOL)presentRenderbuffer:(NSUInteger)target;</p></li>
</ol>

<h3 id="toc_5">六、开始绘制</h3>

<ol>
<li><p>设置颜色、设置视口大小</p>
<pre><code class="language-text">//设置清屏颜色
glClearColor(0.0f, 1.0f, 0.0f, 1.0f);<br/>
//清除屏幕<br/>
glClear(GL_COLOR_BUFFER_BIT);<br/>
CGFloat scale = [[UIScreen mainScreen]scale];<br/>
//设置视口大小<br/>
glViewport(self.frame.origin.x * scale, self.frame.origin.y * scale, self.frame.size.width * scale, self.frame.size.height * scale);
</code></pre></li>
<li><p>读取顶点着色程序、片元着色程序</p>
<pre><code class="language-text">NSString *vertFile = [[NSBundle mainBundle]pathForResource:@&quot;shaderv&quot; ofType:@&quot;vsh&quot;];
NSString *fragFile = [[NSBundle mainBundle]pathForResource:@&quot;shaderf&quot; ofType:@&quot;fsh&quot;];
</code></pre></li>
<li><p>加载shader</p>
<pre><code class="language-text">self.myPrograme = [self loadShaders:vertFile Withfrag:fragFile];//见附
</code></pre></li>
<li><p>链接</p>
<pre><code class="language-text">glLinkProgram(self.myPrograme);
GLint linkStatus;<br/>
//获取链接状态<br/>
glGetProgramiv(self.myPrograme, GL_LINK_STATUS, &amp;linkStatus);<br/>
if (linkStatus == GL_FALSE) {<br/>
    GLchar message[512];<br/>
    glGetProgramInfoLog(self.myPrograme, sizeof(message), 0, &amp;message[0]);<br/>
    NSString *messageString = [NSString stringWithUTF8String:message];<br/>
    NSLog(@&quot;Program Link Error:%@&quot;,messageString);<br/>
    return;<br/>
}
</code></pre></li>
<li><p>使用program</p>
<pre><code class="language-text">glUseProgram(self.myPrograme);
</code></pre></li>
<li><p>设置顶点、纹理坐标</p>
<pre><code class="language-text">...
</code></pre></li>
<li><p>处理顶点数据</p>
<pre><code class="language-text">glVertexAttribPointer(position, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, NULL);
</code></pre></li>
<li><p>处理纹理数据</p>
<pre><code class="language-text">glVertexAttribPointer(textCoor, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, (float *)NULL + 3);
</code></pre></li>
<li><p>加载纹理</p>
<ul>
<li><p>获取图片的CGImageRef</p></li>
<li><p>读取图片的大小，宽和高</p></li>
<li><p>获取图片字节数 宽<em>高</em>4（RGBA）</p></li>
<li><p>创建上下文</p></li>
<li><p>在CGContextRef上绘图 ,解决图片倒置的方法</p></li>
<li><p>画图完毕就释放上下文</p></li>
<li><p>绑定纹理到默认的纹理ID（这里只有一张图片，故而相当于默认于片元着色器里面的 </p></li>
<li><p>设置纹理属性</p></li>
<li><p>载入纹理2D数据</p></li>
<li><p>绑定纹理</p></li>
<li><p>释放spriteData</p></li>
</ul></li>
<li><p>获取shader里面的变量, 模型视图变换传值</p></li>
<li><p>绘制并显示缓存数据 presentRenderbuffer </p>
<pre><code class="language-text">glDrawArrays(GL_TRIANGLES, 0, 6);
[self.myContext presentRenderbuffer:GL_RENDERBUFFER];
</code></pre></li>
</ol>

<h3 id="toc_6">附</h3>

<ol>
<li>frame buffer 和 render buffer 关系</li>
</ol>

<pre><code class="language-text">buffer分为frame buffer 和 render buffer2个大类。其中frame buffer 相当于render buffer的管理者。frame buffer object即称FBO，常用于离屏渲染缓存等。render buffer则又可分为3类。colorBuffer、depthBuffer、stencilBuffer。
</code></pre>

<ol>
<li><p>加载shader</p>
<ul>
<li>定义2个零时着色器对象</li>
<li>创建program</li>
<li>编译顶点着色程序、片元着色器程序
<ul>
<li>读取文件路径字符串</li>
<li>创建一个shader（根据type类型）</li>
<li>将顶点着色器源码附加到着色器对象上</li>
<li>把着色器源代码编译成目标代码</li>
</ul></li>
<li>创建最终的程序</li>
<li>释放不需要的shader</li>
</ul></li>
</ol>

<pre><code class="language-text">-(GLuint)loadShaders:(NSString *)vert Withfrag:(NSString *)frag {
    //定义2个零时着色器对象
    GLuint verShader, fragShader;
    //创建program
    GLint program = glCreateProgram();
    
    //编译顶点着色程序、片元着色器程序
    //参数1：编译完存储的底层地址
    //参数2：编译的类型，GL_VERTEX_SHADER（顶点）、GL_FRAGMENT_SHADER(片元)
    //参数3：文件路径
    [self compileShader:&amp;verShader type:GL_VERTEX_SHADER file:vert];
    [self compileShader:&amp;fragShader type:GL_FRAGMENT_SHADER file:frag];
    
    //创建最终的程序
    glAttachShader(program, verShader);
    glAttachShader(program, fragShader);
    
    //释放不需要的shader
    glDeleteShader(verShader);
    glDeleteShader(fragShader);
    
    return program;
}
</code></pre>

<pre><code class="language-text">//链接shader
- (void)compileShader:(GLuint *)shader type:(GLenum)type file:(NSString *)file{
    
    //读取文件路径字符串
    NSString* content = [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil];
    const GLchar* source = (GLchar *)[content UTF8String];
    
    //创建一个shader（根据type类型）
    *shader = glCreateShader(type);
    
    //将顶点着色器源码附加到着色器对象上。
    //参数1：shader,要编译的着色器对象 *shader
    //参数2：numOfStrings,传递的源码字符串数量 1个
    //参数3：strings,着色器程序的源码（真正的着色器程序源码）
    //参数4：lenOfStrings,长度，具有每个字符串长度的数组，或NULL，这意味着字符串是NULL终止的
    glShaderSource(*shader, 1, &amp;source,NULL);
    
    //把着色器源代码编译成目标代码
    glCompileShader(*shader);
    
}
</code></pre>

<ol>
<li>设置纹理</li>
</ol>

<pre><code class="language-text">//设置纹理
- (GLuint)setupTexture:(NSString *)fileName {
    //1、获取图片的CGImageRef
    CGImageRef spriteImage = [UIImage imageNamed:fileName].CGImage;
    
    //判断图片是否获取成功
    if (!spriteImage) {
        NSLog(@&quot;Failed to load image %@&quot;, fileName);
        exit(1);
    }
    
    //2、读取图片的大小，宽和高
    size_t width = CGImageGetWidth(spriteImage);
    size_t height = CGImageGetHeight(spriteImage);
    
    //3.获取图片字节数 宽*高*4（RGBA）
    GLubyte * spriteData = (GLubyte *) calloc(width * height * 4, sizeof(GLubyte));
    
    //4.创建上下文
    /*
     参数1：data,指向要渲染的绘制图像的内存地址
     参数2：width,bitmap的宽度，单位为像素
     参数3：height,bitmap的高度，单位为像素
     参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8
     参数5：bytesPerRow,bitmap的没一行的内存所占的比特数
     参数6：colorSpace,bitmap上使用的颜色空间  kCGImageAlphaPremultipliedLast：RGBA
     */
    CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4,CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast);
    
    
    
    //5、在CGContextRef上绘图
    /*
     CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。
     CGContextDrawImage 
     参数1：绘图上下文
     参数2：rect坐标
     参数3：绘制的图片
     */
    CGRect rect = CGRectMake(0, 0, width, height);
    //使用默认方式绘制，发现图片是倒的。
    CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage);
    /*
     解决图片倒置的方法(2):
     CGContextTranslateCTM(spriteContext, rect.origin.x, rect.origin.y);
     CGContextTranslateCTM(spriteContext, 0, rect.size.height);
     CGContextScaleCTM(spriteContext, 1.0, -1.0);
     CGContextTranslateCTM(spriteContext, -rect.origin.x, -rect.origin.y);
     CGContextDrawImage(spriteContext, rect, spriteImage);
     */
   
    //6、画图完毕就释放上下文
    CGContextRelease(spriteContext);
    
    //5、绑定纹理到默认的纹理ID（这里只有一张图片，故而相当于默认于片元着色器里面的colorMap，如果有多张图不可以这么做）
    glBindTexture(GL_TEXTURE_2D, 0);
    
    //设置纹理属性
    /*
     参数1：纹理维度
     参数2：线性过滤、为s,t坐标设置模式
     参数3：wrapMode,环绕模式
     */
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    float fw = width, fh = height;
    //载入纹理2D数据
    /*
     参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D
     参数2：加载的层次，一般设置为0
     参数3：纹理的颜色值GL_RGBA
     参数4：宽
     参数5：高
     参数6：border，边界宽度
     参数7：format
     参数8：type
     参数9：纹理数据
     */
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, fw, fh, 0, GL_RGBA, GL_UNSIGNED_BYTE, spriteData);
    
    //绑定纹理
    /*
     参数1：纹理维度
     参数2：纹理ID,因为只有一个纹理，给0就可以了。
     */
    glBindTexture(GL_TEXTURE_2D, 0);
    
    //释放spriteData
    free(spriteData);
    
    return 0;
}
</code></pre>

<p>详细代码：<a href="https://github.com/Caolongs/OpenGL-ES---GLSL">DEMO</a></p>

<h1 id="toc_7">文章目录</h1>

<ul>
<li>
<a href="#toc_0">一、创建图层</a>
</li>
<li>
<a href="#toc_1">二、创建上下文</a>
</li>
<li>
<a href="#toc_2">三、清空缓存区</a>
</li>
<li>
<a href="#toc_3">四、设置RenderBuffer</a>
</li>
<li>
<a href="#toc_4">五、设置FrameBuffer</a>
</li>
<li>
<a href="#toc_5">六、开始绘制</a>
</li>
<li>
<a href="#toc_6">附</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_7">文章目录</a>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15176282030413.html">
                
                  <h1>OpenGL简单介绍及实践</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">什么是<a href="https://zh.wikipedia.org/wiki/OpenGL">OpenGL</a> (Open Graphics Library)</h2>

<pre><code class="language-javascript">OpenGL 是一种应用程序编程接口（Application Programming Interface,API）,
用于渲染2D、3D矢量图形。    

</code></pre>

<h2 id="toc_1">相关程序库</h2>

<p>OpenGL被设计为只有输出的，所以它只提供渲染功能。核心API没有窗口系统、音频、打印、键盘／鼠标或其他输入设备的概念。</p>

<p><strong>几个库创建在OpenGL之上，提供了OpenGL本身没有的功能:</strong></p>

<ul>
<li>GLU</li>
<li>GLUT <code>(能够以可移植的方式提供基本的窗口功能)</code></li>
<li>GLUI</li>
<li>GLEW <code>(GLEW可以简化获取函数地址的过程，并且包含了可以跨平台使用的其他一些OpenGL编程方法)</code></li>
<li>GLEE </li>
<li>FREEGLUT <code>（GLUT已经于1998年不再更新了。于是就有了freeglut）</code></li>
<li>OpenGL Performer <code>(可以创建实时可视化仿真程序)</code></li>
<li>......</li>
</ul>

<p>当开发者需要使用最新的OpenGL扩展时，他们往往需要使用GLEW库或者是GLEE库提供的功能，可以在程序的运行期判断当前硬件是否支持相关的扩展，防止程序崩溃甚至造成硬件损坏。这类库利用动态加载技术（dlsym、GetProcAddress等函数）搜索各种扩展的信息。</p>

<h2 id="toc_2">实践</h2>

<ul>
<li>GLUT 库使用</li>
</ul>

<pre><code class="language-text">int main(int argc,char *argv[]) {
    //1. 初始化一个GLUT库
    glutInit(&amp;argc, (char **)argv);
        
    //2. 创建一个窗口并定制窗口名
    glutCreateWindow(&quot;OpenGL_Demo&quot;);
        
    //3. 注册一个绘图函数，操作系统在必要的时刻就会对窗体进行重绘制操作
    //它设置了一个现实回调（display callback）,即GLUT没在每次更新窗口内容时会自动调用改例程
    glutDisplayFunc(RenderScene);
        
        
    //这是一个无限执行的循环，它会负责一直处理窗口和操作系统的用户输入等操作。（
    //注意：不会执    行在glutMainLoop()之后的所有命令。）
    glutMainLoop();
        
        }
</code></pre>

<ul>
<li>GLEW 库使用</li>
</ul>

<p>可在程序运行操作前进行使用，确保驱动程序的初始化过程中没有任何问题</p>

<pre><code class="language-text">    /*
     初始化一个GLEW库,确保OpenGL API对程序完全可用。
     在试图做任何渲染之前，要检查确定驱动程序的初始化过程中没有任何问题
     */
    GLenum status = glewInit();
    if (GLEW_OK != status) {
        
        printf(&quot;GLEW Error:%s\n&quot;,glewGetErrorString(status));
        return 1;
        
    }
</code></pre>

<ul>
<li>详细过程</li>
</ul>

<pre><code class="language-text">int main(int argc,char *argv[])
{
    gltSetWorkingDirectory(argv[0]);//设置当前工作目录，针对MAC OS X
    glutInit(&amp;argc, argv);          //初始化一个GLUT库
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL);//显示类型模式 
    glutInitWindowSize(800, 600);   //GLUT窗口大小、窗口标题
    glutCreateWindow(&quot;OpenGL_Demo&quot;);//创建一个窗口并定制窗口名
    glutReshapeFunc(changeSize);    //改变窗口大小
    glutDisplayFunc(RenderScene);   //绘图函数
    glutSpecialFunc(SpeacialKeys);  //键盘操作
    
    //初始化一个GLEW库,确保OpenGL API对程序完全可用
    GLenum status = glewInit();
    if (GLEW_OK != status) {
        printf(&quot;GLEW Error:%s\n&quot;,glewGetErrorString(status));
        return 1;
    }
    
    setupRC();//设置我们的渲染环境  
      
    glutMainLoop();//这是一个无限执行的循环,相当于RunLoop

    return  0;
    
}


/*
 在窗口大小改变时，接收新的宽度&amp;高度。
 */
void changeSize(int w,int h)
{
    /*
     x,y 参数代表窗口中视图的左下角坐标，而宽度、高度是像素为表示，通常x,y 都是为0
     */
    glViewport(0, 0, w, h);

}

/*
    绘制界面
*/
void RenderScene(void)
{    
     //清除一个或者一组特定的缓存区
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

    //2.设置一组浮点数来表示红色
    GLfloat vRed[] = {1.0,0.0,0.0,1.0f};

    //单元着色器(类型，颜色)
    //shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);

    //提交着色器
    triangleBatch.Draw();

    //将后台缓冲区进行渲染，然后结束后交换给前台
    glutSwapBuffers();

}


/*
    移动图形 -- 修改图形坐标！
*/
void SpeacialKeys(int key,int x,int y) {
    
    // ...
    
    glutPostRedisplay();//重新绘制
}


/*
    设置我们的渲染环境 
*/
void setupRC()
{
    //设置清屏颜色（背景颜色）
    glClearColor(0.2f, 0.40f, 0.7f, 1);

    //初始化一个渲染管理器,没有着色器，在OpenGL 核心框架中是无法进行任何渲染的。
    shaderManager.InitializeStockShaders();

    //指定顶点
    //矩形
    GLfloat blockSize = 0.1f;
    GLfloat vVerts[] = {
        -blockSize,-blockSize,0.0f,
        blockSize,-blockSize,0.0f,
        blockSize,blockSize,0.0f,
        -blockSize,blockSize,0.0f
    };

    triangleBatch.Begin(GL_TRIANGLE_FAN, 4);
    triangleBatch.CopyVertexData3f(vVerts);//复制顶点数据到批处理中  
    triangleBatch.End();

}
</code></pre>

<p><a href="https://github.com/Caolongs/OpenGLDemo.git">Demo地址</a></p>

<h2 id="toc_3">附</h2>

<pre><code class="language-text">    /*
     GLUT_RGBA:RGBA颜色值模式
     GLUT_DOUBLE:双缓存窗口
     GLUT_DEPTH：
     GLUT_STENCIL：
     */
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL);
</code></pre>

<pre><code class="language-text">    /* 清除一个或者一组特定的缓存区
     缓冲区是一块存在图像信息的储存空间，红色、绿色、蓝色和alpha分量通常一起分量通常一起作为颜色缓存区或像素缓存区引用。
     OpenGL 中不止一种缓冲区（颜色缓存区、深度缓存区和模板缓存区）
     清除缓存区对数值进行预置
     参数：指定将要清除的缓存的
     GL_COLOR_BUFFER_BIT :指示当前激活的用来进行颜色写入缓冲区
     GL_DEPTH_BUFFER_BIT :指示深度缓存区
     GL_STENCIL_BUFFER_BIT:指示模板缓冲区
     */
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

</code></pre>

<pre><code class="language-text">    
    /* 平面着色器
     0.传递到存储着色器，即GLT_SHADER_IDENTITY着色器，
     这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形
     1.平移矩阵 mTransformMatrix 与 每个顶点 相乘 -&gt; 新顶点 （顶点着色器）
     2.将片元着色红色 (片元着色器)
     */
     shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);
     
     
     //单元着色器(类型，颜色)---第一种方法用到的
     shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);
</code></pre>

<pre><code class="language-text">    //在开始的设置openGL 窗口的时候，我们指定要一个双缓冲区的渲染环境。
    //这就意味着将在后台缓冲区进行渲染，渲染结束后交换给前台。
    //这种方式可以防止观察者看到可能伴随着动画帧与动画帧之间的闪烁的渲染过程。
    //缓冲区交换平台将以平台特定的方式进行。
    //将后台缓冲区进行渲染，然后结束后交换给前台
    glutSwapBuffers();
</code></pre>

<p><img src="media/15176282030413/QQ20180203-0.jpg" alt="QQ20180203-0"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OpenGL.html'>OpenGL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/Caolongs" title="GitHub">GitHub</a>

  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="%E6%9E%B6%E6%9E%84.html"><strong>架构</strong></a>
        
            <a href="CI.html"><strong>CI</strong></a>
        
            <a href="OpenGL.html"><strong>OpenGL</strong></a>
        
            <a href="%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8.html"><strong>逆向与安全</strong></a>
        
            <a href="AI.html"><strong>AI</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91.html"><strong>音视频</strong></a>
        
            <a href="Shell.html"><strong>Shell</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15396681011495.html">Shell</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15283573748540.html">iOS逆向-砸壳（Clutch & dumpdecrypted）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15271533818539.html">Mac上搭建直播服务器 Nginx+HLS</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15271456510220.html">Mac上搭建直播服务器 Nginx+rtmp</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15264613640203.html">Logos语法</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
